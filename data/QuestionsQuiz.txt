Voici **50 questions de quiz sur le th√®me ‚ÄúPatterns‚Äù**, toutes en QCM avec **A, B, C, D**.
Elles sont pens√©es pour l‚Äôexam C / 42 : reconna√Ætre les sch√©mas r√©currents, pas r√©citer du code au hasard.

---

## 1)

Quel pattern est utilis√© dans `ft_split` avant d‚Äôappeler malloc pour le tableau ?

A) remplir ‚Üí compter ‚Üí terminer
B) compter ‚Üí malloc ‚Üí remplir ‚Üí terminer
C) malloc ‚Üí remplir ‚Üí compter
D) free ‚Üí malloc ‚Üí remplir

R√©ponse attendue : B

---

## 2)

Quel est le pattern classique pour convertir un int en string (itoa) ?

A) remplir ‚Üí malloc ‚Üí compter
B) compter ‚Üí remplir ‚Üí malloc
C) g√©rer signe ‚Üí compter ‚Üí malloc ‚Üí remplir √† l‚Äôenvers
D) malloc ‚Üí signe ‚Üí remplir

R√©ponse : C

---

## 3)

Dans `union`, quel pattern √©vite les doublons ?

A) tri pr√©alable
B) compteur global
C) tableau seen[256]
D) malloc dynamique

R√©ponse : C

---

## 4)

Quel pattern sert √† parcourir une liste cha√Æn√©e ?

A) for(i=0;i<n;i++)
B) while(node) node = node->next
C) do while
D) r√©cursion obligatoire

R√©ponse : B

---

## 5)

Dans `ft_list_remove_if`, quel pattern g√®re la t√™te ?

A) cur = begin
B) boucle while sur *begin
C) for
D) swap data

R√©ponse : B

---

## 6)

Quel pattern permet d‚Äô√©viter de perdre l‚Äôadresse d‚Äôun maillon supprim√© ?

A) tmp = cur
B) tmp = cur->next
C) free(cur)
D) continue

R√©ponse : B

---

## 7)

Quel est le pattern pour remplir une string termin√©e ?

A) '\n' au d√©but
B) '\0' √† la fin
C) '\t' au milieu
D) free √† la fin

R√©ponse : B

---

## 8)

Quel pattern permet de g√©rer INT_MIN dans itoa ?

A) cast en float
B) cast en long
C) malloc double
D) memcpy

R√©ponse : B

---

## 9)

Quel pattern sert √† ignorer les s√©parateurs ?

A) if unique
B) while(is_sep) avancer
C) break
D) free

R√©ponse : B

---

## 10)

Dans `sort_list`, quel pattern indique la fin du tri ?

A) i == n
B) cmp == 0
C) swapped == 0
D) cur == NULL

R√©ponse : C

---

## 11)

Quel pattern est utilis√© pour compter des chiffres ?

A) while(n) { n/=10; }
B) for(i=0;i<n;i++)
C) malloc
D) strcpy

R√©ponse : A

---

## 12)

Quel pattern est commun √† strdup et split ?

A) strcpy direct
B) compter longueur ‚Üí malloc ‚Üí copier
C) free
D) sort

R√©ponse : B

---

## 13)

Quel pattern garantit la fin d‚Äôun tableau de strings ?

A) '\0'
B) NULL final
C) free
D) sizeof

R√©ponse : B

---

## 14)

Quel pattern emp√™che une boucle infinie lors d‚Äôun comptage ?

A) continue
B) break
C) modifier la variable test√©e
D) malloc

R√©ponse : C

---

## 15)

Dans wdmatch, quel pattern est utilis√© ?

A) deux boucles imbriqu√©es invers√©es
B) parcourir argv[1] seulement
C) parcourir argv[2] en avan√ßant dans argv[1]
D) tri pr√©alable

R√©ponse : C

---

## 16)

Quel pattern est utilis√© pour supprimer plusieurs t√™tes successives ?

A) if
B) while
C) for
D) goto

R√©ponse : B

---

## 17)

Quel pattern est commun √† atoi et itoa ?

A) modulo
B) strlen
C) memcpy
D) sort

R√©ponse : A

---

## 18)

Quel pattern est utilis√© pour swap deux data dans sort_list ?

A) malloc
B) tmp variable
C) free
D) break

R√©ponse : B

---

## 19)

Quel pattern permet de g√©rer start > end dans ft_range ?

A) for fixe
B) step = +1 ou -1
C) free
D) goto

R√©ponse : B

---

## 20)

Quel pattern permet d‚Äôallouer un tableau d‚Äôint ?

A) malloc(n)
B) malloc(sizeof(int))
C) malloc(sizeof(int) * n)
D) calloc(1)

R√©ponse : C

---

## 21)

Quel pattern est utilis√© pour d√©tecter la fin d‚Äôune string ?

A) '\n'
B) '\t'
C) '\0'
D) EOF

R√©ponse : C

---

## 22)

Quel pattern est utilis√© pour compter les mots ?

A) while(str)
B) transitions s√©parateur ‚Üí lettre
C) strlen
D) atoi

R√©ponse : B

---

## 23)

Quel pattern sert √† prot√©ger malloc ?

A) if(ptr) free
B) if(!ptr) return NULL
C) break
D) exit obligatoire

R√©ponse : B

---

## 24)

Quel pattern est utilis√© pour remplir une string depuis la droite ?

A) index croissant
B) index d√©croissant
C) memcpy
D) strcpy

R√©ponse : B

---

## 25)

Quel pattern sert √† √©viter de sauter un √©l√©ment apr√®s suppression ?

A) avancer toujours
B) ne pas avancer apr√®s unlink
C) free double
D) goto

R√©ponse : B

---

## 26)

Quel pattern est commun √† union et inter ?

A) bubble sort
B) seen[256]
C) recursion
D) free

R√©ponse : B

---

## 27)

Quel pattern sert √† g√©rer argc ?

A) strcmp
B) if(argc != attendu)
C) malloc
D) break

R√©ponse : B

---

## 28)

Quel pattern est utilis√© pour remplir un tableau avec une suite ?

A) while
B) step + incr√©ment
C) recursion
D) goto

R√©ponse : B

---

## 29)

Quel pattern est utilis√© pour parcourir argv ?

A) argv++
B) while(argv[i])
C) strcpy
D) free

R√©ponse : B

---

## 30)

Quel pattern est commun √† toutes les fonctions avec sortie texte ?

A) printf
B) write + '\n'
C) scanf
D) fgets

R√©ponse : B

---

## 31)

Quel pattern est utilis√© pour stocker l‚Äô√©tat des cartes rat√©es ?

A) tableau fixe
B) compteur par carte
C) free
D) strcpy

R√©ponse : B

---

## 32)

Quel pattern sert √† calculer une taille inclusive ?

A) end-start
B) abs(end-start)
C) abs(end-start)+1
D) sizeof

R√©ponse : C

---

## 33)

Quel pattern sert √† parcourir jusqu‚Äô√† NULL ?

A) while(ptr)
B) for
C) if
D) break

R√©ponse : A

---

## 34)

Quel pattern est utilis√© pour rep√©rer un d√©but de mot ?

A) lettre + lettre
B) s√©parateur + lettre
C) lettre + s√©parateur
D) EOF

R√©ponse : B

---

## 35)

Quel pattern est utilis√© pour remplir un tableau dynamique ?

A) malloc puis indexation
B) realloc constant
C) recursion
D) goto

R√©ponse : A

---

## 36)

Quel pattern sert √† convertir un char chiffre en int ?

A) c * 10
B) c + '0'
C) c - '0'
D) atoi

R√©ponse : C

---

## 37)

Quel pattern sert √† convertir un int en char chiffre ?

A) n + '0'
B) n - '0'
C) n * '0'
D) atoi

R√©ponse : A

---

## 38)

Quel pattern est utilis√© pour nettoyer un pointeur apr√®s free ?

A) ptr++
B) ptr = NULL
C) malloc
D) break

R√©ponse : B

---

## 39)

Quel pattern est commun √† tous les parcours ?

A) condition + avancement
B) malloc
C) free
D) sizeof

R√©ponse : A

---

## 40)

Quel pattern est utilis√© pour stocker temporairement une valeur ?

A) static
B) tmp
C) free
D) sizeof

R√©ponse : B

---

## 41)

Quel pattern est utilis√© pour parcourir une string ?

A) for sans condition
B) while(str[i])
C) free
D) malloc

R√©ponse : B

---

## 42)

Quel pattern sert √† s‚Äôarr√™ter sur un s√©parateur ?

A) while(!sep)
B) break
C) free
D) goto

R√©ponse : A

---

## 43)

Quel pattern sert √† copier un mot ?

A) strcpy
B) boucle char par char
C) memcpy uniquement
D) free

R√©ponse : B

---

## 44)

Quel pattern est commun √† toutes les allocations ?

A) malloc + free
B) sizeof
C) if(!ptr)
D) A + C

R√©ponse : D

---

## 45)

Quel pattern est utilis√© pour tester la fin d‚Äôun tableau de strings ?

A) '\0'
B) NULL
C) EOF
D) 0xFF

R√©ponse : B

---

## 46)

Quel pattern sert √† g√©rer un cas sp√©cial ?

A) if initial
B) free
C) malloc
D) goto

R√©ponse : A

---

## 47)

Quel pattern est utilis√© pour inverser une string ?

A) malloc
B) deux indices i/j
C) recursion
D) sizeof

R√©ponse : B

---

## 48)

Quel pattern est utilis√© pour faire un tri simple ?

A) quicksort
B) bubble sort
C) mergesort
D) heapsort

R√©ponse : B

---

## 49)

Quel pattern est utilis√© pour stocker une erreur ?

A) flag
B) free
C) sizeof
D) goto

R√©ponse : A

---

## 50)

Quel pattern est commun √† tous les exos d‚Äôexam r√©ussis ?

A) vitesse
B) √©crire direct
C) checklist mentale
D) copier internet

R√©ponse : C

---

Voici **50 questions de quiz sur le th√®me ‚ÄúPi√®ges‚Äù**, toutes en QCM avec **A, B, C, D**, orient√©es exam C / 42 : erreurs fr√©quentes, d√©tails qui font tomber les tests, comportements ind√©finis, sorties strictes, edge cases.

---

## 1)

Quel oubli provoque le plus souvent un d√©passement m√©moire lors d‚Äôune copie de string ?

A) oublier sizeof
B) oublier '\0'
C) oublier free
D) oublier argc

R√©ponse : B

---

## 2)

Dans un exo d‚Äôexam, que faut-il afficher si argc est incorrect ?

A) message d‚Äôerreur
B) rien
C) juste '\n'
D) exit(1)

R√©ponse : C

---

## 3)

Quel est le pi√®ge principal dans wdmatch ?

A) malloc
B) mauvais sens de parcours
C) tri
D) free

R√©ponse : B

---

## 4)

Quel est le pi√®ge classique dans split ?

A) free trop t√¥t
B) ne pas compter les mots
C) malloc trop grand
D) utiliser printf

R√©ponse : B

---

## 5)

Pourquoi seen[256] doit √™tre index√© avec unsigned char ?

A) optimisation
B) √©viter indices n√©gatifs
C) style
D) tri

R√©ponse : B

---

## 6)

Quel pi√®ge survient si on avance cur apr√®s avoir supprim√© cur->next ?

A) double free
B) fuite
C) saut d‚Äô√©l√©ment
D) segfault imm√©diat

R√©ponse : C

---

## 7)

Dans itoa, que se passe-t-il si on ne traite pas INT_MIN ?

A) fuite
B) overflow
C) boucle infinie
D) segmentation fault

R√©ponse : B

---

## 8)

Quel pi√®ge arrive si on oublie de v√©rifier malloc ?

A) warning
B) free manquant
C) segfault
D) compilation impossible

R√©ponse : C

---

## 9)

Pourquoi dst[i] = "\0" est faux ?

A) trop long
B) type incorrect
C) compile mais bug
D) lent

R√©ponse : B

---

## 10)

Quel est le pi√®ge avec while(n) quand n vaut 0 ?

A) crash
B) boucle infinie
C) boucle ignor√©e
D) double free

R√©ponse : C

---

## 11)

Quel oubli cause une boucle infinie ?

A) break
B) incr√©ment
C) free
D) malloc

R√©ponse : B

---

## 12)

Quel pi√®ge avec start > end dans ft_range ?

A) segfault
B) rien
C) oublier step n√©gatif
D) malloc

R√©ponse : C

---

## 13)

Que se passe-t-il si on √©crit malloc(len) au lieu de malloc(len + 1) ?

A) fuite
B) un caract√®re manquant
C) √©criture hors limites
D) compile pas

R√©ponse : C

---

## 14)

Pourquoi '\n' final est obligatoire dans beaucoup d‚Äôexos ?

A) style
B) tests automatiques
C) malloc
D) free

R√©ponse : B

---

## 15)

Quel pi√®ge survient si on ne remet pas √† z√©ro seen[256] ?

A) crash
B) doublons rat√©s
C) faux positifs
D) segmentation fault

R√©ponse : C

---

## 16)

Pourquoi modifier directement nbr dans itoa est dangereux ?

A) fuite
B) on perd la valeur originale
C) segmentation fault
D) compile pas

R√©ponse : B

---

## 17)

Quel est le pi√®ge avec char sign√© utilis√© comme index ?

A) lent
B) overflow
C) index n√©gatif
D) fuite

R√©ponse : C

---

## 18)

Que provoque un prototype diff√©rent de l‚Äô√©nonc√© ?

A) warning
B) runtime error
C) compilation KO
D) fuite

R√©ponse : C

---

## 19)

Quel pi√®ge avec printf quand write est impos√© ?

A) lent
B) mauvais output
C) interdit
D) compile pas

R√©ponse : C

---

## 20)

Pourquoi il faut traiter le cas string vide ?

A) sinon crash
B) sinon sortie fausse
C) sinon warning
D) sinon tri

R√©ponse : B

---

## 21)

Quel pi√®ge arrive si on free sans unlink ?

A) fuite
B) segfault
C) double free
D) corruption

R√©ponse : D

---

## 22)

Quel pi√®ge si on oublie de mettre NULL dans un tableau de strings ?

A) fuite
B) parcours infini
C) compile pas
D) segmentation fault

R√©ponse : B

---

## 23)

Pourquoi il faut travailler sur une copie pour compter ?

A) performance
B) √©viter modifier l‚Äôoriginal
C) style
D) free

R√©ponse : B

---

## 24)

Quel pi√®ge avec while(ptr->next) ?

A) saute la t√™te
B) oublie dernier
C) segfault
D) fuite

R√©ponse : B

---

## 25)

Quel pi√®ge avec cmp mal utilis√© ?

A) segfault
B) tri invers√©
C) doublons
D) compile pas

R√©ponse : B

---

## 26)

Que se passe-t-il si on swap les pointeurs au lieu des data dans sort_list sans pr√©caution ?

A) fuite
B) casse la liste
C) lent
D) rien

R√©ponse : B

---

## 27)

Pourquoi argc doit √™tre strictement v√©rifi√© ?

A) style
B) s√©curit√©
C) tests
D) compilation

R√©ponse : C

---

## 28)

Quel pi√®ge avec free(tmp) avant reconnecter ?

A) fuite
B) segfault
C) corruption
D) rien

R√©ponse : C

---

## 29)

Pourquoi while(*begin_list) est n√©cessaire au d√©but ?

A) performance
B) style
C) supprimer plusieurs t√™tes
D) malloc

R√©ponse : C

---

## 30)

Quel pi√®ge avec index mal initialis√© ?

A) fuite
B) valeur ind√©finie
C) lent
D) free

R√©ponse : B

---

## 31)

Quel pi√®ge si on oublie d‚Äôinitialiser len ?

A) segmentation fault
B) fuite
C) taille al√©atoire
D) compile pas

R√©ponse : C

---

## 32)

Pourquoi ne pas utiliser des guillemets typographiques ?

A) style
B) pas ASCII
C) compile pas
D) lent

R√©ponse : C

---

## 33)

Quel pi√®ge avec for(i<=len) ?

A) saute un
B) d√©passe
C) boucle infinie
D) fuite

R√©ponse : B

---

## 34)

Pourquoi il faut caster en unsigned char dans union ?

A) performance
B) norme
C) s√©curit√© index
D) free

R√©ponse : C

---

## 35)

Quel pi√®ge si on affiche trop de texte ?

A) style
B) compile pas
C) tests KO
D) lent

R√©ponse : C

---

## 36)

Pourquoi il ne faut pas avancer cur apr√®s suppression ?

A) fuite
B) sauter un
C) boucle infinie
D) compile pas

R√©ponse : B

---

## 37)

Quel pi√®ge avec return pr√©matur√© ?

A) fuite
B) style
C) optimisation
D) compile pas

R√©ponse : A

---

## 38)

Quel pi√®ge avec malloc(sizeof(ptr) * n) ?

A) trop petit
B) trop grand
C) lent
D) segmentation fault

R√©ponse : A

---

## 39)

Quel pi√®ge avec while(str[i] != '\n') ?

A) ignore '\0'
B) segfault
C) fuite
D) compile pas

R√©ponse : A

---

## 40)

Pourquoi ne pas oublier le free dans remove_if ?

A) style
B) performance
C) fuite m√©moire
D) compile pas

R√©ponse : C

---

## 41)

Quel pi√®ge avec un tableau global non remis √† z√©ro ?

A) lent
B) pollution d‚Äô√©tat
C) segfault
D) compile pas

R√©ponse : B

---

## 42)

Pourquoi un include interdit peut faire rater ?

A) warning
B) runtime
C) r√®gles exam
D) fuite

R√©ponse : C

---

## 43)

Quel pi√®ge avec strcmp au lieu de comparer chars ?

A) lent
B) hors sujet
C) interdit
D) segmentation fault

R√©ponse : C

---

## 44)

Pourquoi oublier le cast long peut casser ?

A) lent
B) overflow
C) fuite
D) compile pas

R√©ponse : B

---

## 45)

Quel pi√®ge avec while(cur) au lieu de while(cur->next) dans remove_if ?

A) saute t√™te
B) impossible supprimer dernier
C) segfault
D) fuite

R√©ponse : B

---

## 46)

Quel pi√®ge avec free deux fois ?

A) fuite
B) segmentation fault
C) OK
D) style

R√©ponse : B

---

## 47)

Pourquoi oublier de g√©rer liste vide est dangereux ?

A) rien
B) crash
C) lent
D) compile pas

R√©ponse : B

---

## 48)

Quel pi√®ge avec printf en exam ?

A) lent
B) interdit
C) mauvais output
D) B et C

R√©ponse : D

---

## 49)

Quel pi√®ge avec malloc(1000) ‚Äúau hasard‚Äù ?

A) fuite
B) impr√©cis
C) tests limites rat√©s
D) tout

R√©ponse : D

---

## 50)

Quel est le pi√®ge num√©ro un √† l‚Äôexam ?

A) coder lentement
B) ne pas lire l‚Äô√©nonc√©
C) trop commenter
D) optimiser

R√©ponse : B

---

Voici **50 questions de quiz sur le th√®me ‚ÄúR√©flexes m√©moire‚Äù**, toutes en QCM avec **A, B, C, D**, orient√©es exam C / 42 : automatiser les bons gestes avec malloc, free, tailles, NULL, ownership, copies, protection.

---

## 1)

Pourquoi √©crit-on toujours malloc(len + 1) pour une string ?

A) performance
B) '\n'
C) '\0'
D) sizeof

R√©ponse : C

---

## 2)

Pourquoi utiliser sizeof(type) * n ?

A) rapidit√©
B) lisibilit√©
C) octets corrects
D) norme

R√©ponse : C

---

## 3)

Quel est le premier r√©flexe apr√®s malloc ?

A) √©crire dedans
B) free
C) v√©rifier NULL
D) memset

R√©ponse : C

---

## 4)

Quand faut-il free un maillon supprim√© ?

A) avant unlink
B) apr√®s unlink
C) jamais
D) √† la fin du programme

R√©ponse : B

---

## 5)

Pourquoi allouer len + sign + 1 dans itoa ?

A) padding
B) '\0' + '-'
C) norme
D) vitesse

R√©ponse : B

---

## 6)

Que doit contenir la derni√®re case d‚Äôun tableau de strings ?

A) '\0'
B) EOF
C) NULL
D) 0xFF

R√©ponse : C

---

## 7)

Pourquoi travailler sur une copie lors d‚Äôun comptage ?

A) performance
B) ne pas modifier l‚Äôoriginal
C) malloc
D) free

R√©ponse : B

---

## 8)

Que fait if (!ptr) return NULL ?

A) fuite
B) protection
C) free
D) segfault

R√©ponse : B

---

## 9)

Pourquoi ne pas free avant reconnecter une liste ?

A) fuite
B) segfault
C) corruption
D) double free

R√©ponse : C

---

## 10)

Pourquoi ne pas oublier free apr√®s unlink ?

A) style
B) norme
C) fuite m√©moire
D) compile

R√©ponse : C

---

## 11)

Pourquoi caster en long dans itoa ?

A) vitesse
B) √©viter overflow
C) style
D) norme

R√©ponse : B

---

## 12)

Que risque malloc(sizeof(ptr) * n) ?

A) trop petit
B) trop grand
C) correct
D) fuite

R√©ponse : A

---

## 13)

Pourquoi initialiser len √† 0 ?

A) style
B) √©viter valeur ind√©finie
C) norme
D) free

R√©ponse : B

---

## 14)

Pourquoi remettre seen[256] √† z√©ro ?

A) style
B) performance
C) √©viter pollution
D) norme

R√©ponse : C

---

## 15)

Que doit-on faire apr√®s free(ptr) ?

A) rien
B) ptr++
C) ptr = NULL
D) malloc

R√©ponse : C

---

## 16)

Pourquoi utiliser unsigned char pour indexer ?

A) vitesse
B) s√©curit√©
C) style
D) norme

R√©ponse : B

---

## 17)

Pourquoi ne pas √©crire malloc(1000) ‚Äúau hasard‚Äù ?

A) lent
B) impr√©cis
C) tests rat√©s
D) B et C

R√©ponse : D

---

## 18)

Quand doit-on free un tableau retourn√© par split ?

A) dans split
B) jamais
C) appelant
D) OS

R√©ponse : C

---

## 19)

Pourquoi v√©rifier argc ?

A) norme
B) s√©curit√© m√©moire
C) tests
D) style

R√©ponse : B

---

## 20)

Que provoque une variable non initialis√©e ?

A) warning
B) valeur ind√©finie
C) fuite
D) style

R√©ponse : B

---

## 21)

Pourquoi mettre '\0' √† la fin d‚Äôune string ?

A) affichage
B) style
C) norme
D) A et C

R√©ponse : D

---

## 22)

Pourquoi malloc retourne void * ?

A) casting auto
B) g√©n√©rique
C) norme
D) free

R√©ponse : B

---

## 23)

Pourquoi v√©rifier malloc m√™me en exam ?

A) style
B) norme
C) √©viter crash
D) free

R√©ponse : C

---

## 24)

Pourquoi on ne free pas argv ?

A) static
B) OS
C) interdit
D) norme

R√©ponse : A

---

## 25)

Pourquoi malloc(sizeof(char) * n) reste recommand√© ?

A) style
B) portabilit√©
C) norme
D) lent

R√©ponse : B

---

## 26)

Pourquoi √©viter les pointeurs sauvages ?

A) style
B) segfault
C) fuite
D) lent

R√©ponse : B

---

## 27)

Que se passe-t-il si on oublie de free en boucle ?

A) crash imm√©diat
B) fuite m√©moire
C) style
D) compile

R√©ponse : B

---

## 28)

Pourquoi ne pas √©crire free(NULL) ?

A) interdit
B) crash
C) inutile mais s√ªr
D) lent

R√©ponse : C

---

## 29)

Pourquoi s√©parer allocation et remplissage ?

A) style
B) lisibilit√©
C) d√©bogage
D) toutes

R√©ponse : D

---

## 30)

Pourquoi un double pointeur implique vigilance m√©moire ?

A) lent
B) risque de fuite
C) modification structure
D) C et B

R√©ponse : D

---

## 31)

Pourquoi malloc(sizeof(int)) est insuffisant pour n ints ?

A) lent
B) manque de place
C) style
D) free

R√©ponse : B

---

## 32)

Pourquoi une string doit √™tre termin√©e avant retour ?

A) affichage
B) norme
C) s√©curit√©
D) toutes

R√©ponse : D

---

## 33)

Pourquoi v√©rifier la taille inclusive dans range ?

A) style
B) off-by-one
C) free
D) norme

R√©ponse : B

---

## 34)

Pourquoi allouer un tableau de pointeurs avant les mots ?

A) style
B) pattern
C) m√©moire structur√©e
D) toutes

R√©ponse : D

---

## 35)

Pourquoi free apr√®s unlink et pas avant ?

A) fuite
B) corruption
C) segfault
D) toutes

R√©ponse : D

---

## 36)

Pourquoi ne pas r√©utiliser un pointeur free ?

A) style
B) segfault
C) fuite
D) lent

R√©ponse : B

---

## 37)

Pourquoi toujours compter avant malloc ?

A) style
B) s√©curit√©
C) taille exacte
D) B et C

R√©ponse : D

---

## 38)

Pourquoi allouer len + 2 pour "-5" ?

A) padding
B) '-'+ '\0'
C) norme
D) style

R√©ponse : B

---

## 39)

Pourquoi un tableau dynamique doit √™tre NULL-termin√© ?

A) affichage
B) parcours
C) norme
D) toutes

R√©ponse : D

---

## 40)

Pourquoi √©viter de modifier l‚Äôargument original ?

A) style
B) lisibilit√©
C) bug potentiel
D) toutes

R√©ponse : D

---

## 41)

Pourquoi initialiser les pointeurs ?

A) style
B) crash
C) s√©curit√©
D) B et C

R√©ponse : D

---

## 42)

Pourquoi sizeof(char) est souvent omis ?

A) toujours 1
B) norme
C) style
D) inutile

R√©ponse : A

---

## 43)

Pourquoi tester fin de liste avec NULL ?

A) style
B) norme
C) s√©curit√©
D) toutes

R√©ponse : D

---

## 44)

Pourquoi malloc(len) pour une string est faux ?

A) trop petit
B) lent
C) style
D) free

R√©ponse : A

---

## 45)

Pourquoi g√©rer le cas 0 s√©par√©ment ?

A) style
B) boucle saute
C) norme
D) free

R√©ponse : B

---

## 46)

Pourquoi lib√©rer dans remove_if est obligatoire ?

A) style
B) tests
C) fuite
D) norme

R√©ponse : C

---

## 47)

Pourquoi ne pas allouer un buffer fixe ?

A) lent
B) impr√©cis
C) dangereux
D) toutes

R√©ponse : D

---

## 48)

Pourquoi utiliser long dans itoa ?

A) style
B) overflow
C) norme
D) free

R√©ponse : B

---

## 49)

Pourquoi remettre √† z√©ro des compteurs ?

A) style
B) s√©curit√©
C) √©viter faux calcul
D) toutes

R√©ponse : D

---

## 50)

Pourquoi v√©rifier pointeur avant deref ?

A) style
B) crash
C) norme
D) B et C

R√©ponse : D

---

Voici **50 questions de quiz** pour le th√®me **‚ÄúLes Pointeurs et malloc‚Äù** :

‚Ä¢ **25 questions sur les pointeurs**
‚Ä¢ **25 questions sur malloc / allocation m√©moire**
Toutes en QCM avec **A, B, C, D**.

---

# üß† PARTIE 1 ‚Äî POINTEURS (1‚Äì25)

---

## 1)

Que contient une variable de type `int *p` ?

A) un entier
B) une adresse
C) un tableau
D) une taille

R√©ponse : B

---

## 2)

Que fait `*p` si `p` est un pointeur ?

A) donne l‚Äôadresse
B) modifie p
C) acc√®de √† la valeur point√©e
D) alloue

R√©ponse : C

---

## 3)

Pourquoi utiliser `t_list **` ?

A) parcourir plus vite
B) modifier la t√™te
C) √©viter malloc
D) trier

R√©ponse : B

---

## 4)

Quelle ligne fait avancer dans une liste ?

A) `cur++`
B) `*cur = cur->next`
C) `cur = cur->next`
D) `cur.next`

R√©ponse : C

---

## 5)

Apr√®s `free(ptr)`, que faut-il faire id√©alement ?

A) ptr++
B) rien
C) ptr = NULL
D) malloc

R√©ponse : C

---

## 6)

Quelle erreur provoque `*p = NULL` quand p est un pointeur non initialis√© ?

A) style
B) fuite
C) segfault
D) warning

R√©ponse : C

---

## 7)

Quelle est la diff√©rence entre `char *s` et `char s[10]` ?

A) aucune
B) l‚Äôun est dynamique
C) tableau vs pointeur
D) vitesse

R√©ponse : C

---

## 8)

Quand faut-il utiliser un pointeur temporaire `tmp` ?

A) pour free apr√®s unlink
B) pour printf
C) pour trier
D) pour compter

R√©ponse : A

---

## 9)

Quel op√©rateur permet d‚Äôacc√©der √† un champ struct via pointeur ?

A) .
B) *
C) ->
D) &

R√©ponse : C

---

## 10)

Que fait `&x` ?

A) copie
B) valeur
C) adresse
D) malloc

R√©ponse : C

---

## 11)

Quel est le danger d‚Äôun pointeur non initialis√© ?

A) lent
B) fuite
C) comportement ind√©fini
D) warning

R√©ponse : C

---

## 12)

Pourquoi ne pas avancer cur apr√®s suppression ?

A) fuite
B) on saute un √©l√©ment
C) segfault
D) compile

R√©ponse : B

---

## 13)

Que signifie dereferencer ?

A) malloc
B) copier
C) acc√©der √† la valeur point√©e
D) lib√©rer

R√©ponse : C

---

## 14)

Quelle ligne modifie la t√™te d‚Äôune liste ?

A) `begin = begin->next`
B) `*begin = (*begin)->next`
C) `begin++`
D) `cur->next`

R√©ponse : B

---

## 15)

Quel est le r√¥le de `NULL` dans un pointeur ?

A) valeur magique
B) fin
C) adresse invalide
D) B et C

R√©ponse : D

---

## 16)

Pourquoi ne pas utiliser un pointeur apr√®s free ?

A) lent
B) fuite
C) dangling pointer
D) warning

R√©ponse : C

---

## 17)

Que fait `p = &x` ?

A) copie x
B) pointe sur x
C) alloue
D) free

R√©ponse : B

---

## 18)

Que fait `*p = 42` ?

A) change l‚Äôadresse
B) modifie la valeur point√©e
C) malloc
D) free

R√©ponse : B

---

## 19)

Quelle est l‚Äôerreur dans `cur = *cur->next` ?

A) priorit√© op√©rateurs
B) fuite
C) free
D) style

R√©ponse : A

---

## 20)

Pourquoi pr√©f√©rer swap des data plut√¥t que des liens ?

A) style
B) plus simple
C) rapide
D) norme

R√©ponse : B

---

## 21)

Que fait `void *` ?

A) interdit
B) pointeur g√©n√©rique
C) fuite
D) tableau

R√©ponse : B

---

## 22)

Quand faut-il v√©rifier un pointeur avant deref ?

A) jamais
B) toujours
C) en debug
D) apr√®s free

R√©ponse : B

---

## 23)

Pourquoi argv est un char ** ?

A) tableau dynamique
B) liste
C) tableau de strings
D) malloc

R√©ponse : C

---

## 24)

Quelle ligne est fausse ?

A) `p = &x;`
B) `*p = 3;`
C) `p = malloc(4);`
D) `*p = malloc(4);`

R√©ponse : D

---

## 25)

Quel est le danger principal d‚Äôun double pointeur ?

A) lent
B) fuite
C) modifier mauvaise adresse
D) compile

R√©ponse : C

---

# üíæ PARTIE 2 ‚Äî MALLOC (26‚Äì50)

---

## 26)

Que retourne malloc en cas d‚Äô√©chec ?

A) 0
B) -1
C) NULL
D) errno

R√©ponse : C

---

## 27)

Pourquoi √©crire malloc(sizeof(int) * n) ?

A) style
B) octets corrects
C) norme
D) free

R√©ponse : B

---

## 28)

Pourquoi ajouter +1 pour une string ?

A) '\n'
B) '\0'
C) padding
D) norme

R√©ponse : B

---

## 29)

Qui doit free la m√©moire retourn√©e ?

A) malloc
B) OS
C) appelant
D) compilateur

R√©ponse : C

---

## 30)

Que provoque malloc(1000) ‚Äúau hasard‚Äù ?

A) s√©curit√©
B) impr√©cision
C) tests rat√©s
D) B et C

R√©ponse : D

---

## 31)

Pourquoi v√©rifier le retour de malloc ?

A) style
B) √©viter crash
C) norme
D) lent

R√©ponse : B

---

## 32)

Que fait free(NULL) ?

A) segfault
B) interdit
C) rien
D) fuite

R√©ponse : C

---

## 33)

Pourquoi malloc(sizeof(ptr) * n) est souvent faux ?

A) trop petit
B) trop grand
C) lent
D) OK

R√©ponse : A

---

## 34)

Pourquoi ne pas free avant unlink ?

A) fuite
B) corruption
C) segfault
D) norme

R√©ponse : B

---

## 35)

Pourquoi allouer tableau de pointeurs avant mots ?

A) style
B) pattern
C) structure
D) toutes

R√©ponse : D

---

## 36)

Quand lib√©rer dans remove_if ?

A) avant
B) apr√®s unlink
C) jamais
D) √† la fin

R√©ponse : B

---

## 37)

Pourquoi malloc(len) pour string est faux ?

A) trop petit
B) lent
C) style
D) free

R√©ponse : A

---

## 38)

Que fait realloc ?

A) free
B) agrandit/r√©duit
C) copie
D) malloc+free

R√©ponse : B

---

## 39)

Pourquoi √©viter fuite m√©moire ?

A) style
B) crash
C) consommation
D) C et B

R√©ponse : D

---

## 40)

Que fait sizeof(char) ?

A) d√©pend
B) 1
C) 4
D) 8

R√©ponse : B

---

## 41)

Pourquoi ne pas allouer buffer fixe ?

A) lent
B) impr√©cis
C) dangereux
D) toutes

R√©ponse : D

---

## 42)

Pourquoi v√©rifier taille inclusive ?

A) norme
B) off-by-one
C) style
D) free

R√©ponse : B

---

## 43)

Que devient un pointeur apr√®s free ?

A) valide
B) dangling
C) NULL
D) 0

R√©ponse : B

---

## 44)

Pourquoi mettre ptr = NULL apr√®s free ?

A) style
B) √©viter reuse
C) norme
D) debug

R√©ponse : B

---

## 45)

Pourquoi malloc pour tableau 2D ?

A) style
B) dynamique
C) norme
D) free

R√©ponse : B

---

## 46)

Que fait calloc ?

A) malloc
B) initialise √† z√©ro
C) free
D) realloc

R√©ponse : B

---

## 47)

Pourquoi s√©parer allocation et remplissage ?

A) style
B) lisibilit√©
C) debug
D) toutes

R√©ponse : D

---

## 48)

Pourquoi lib√©rer tout en cas d‚Äôerreur interm√©diaire ?

A) style
B) fuite
C) norme
D) lent

R√©ponse : B

---

## 49)

Pourquoi malloc retourne void * ?

A) style
B) g√©n√©rique
C) norme
D) free

R√©ponse : B

---

## 50)

Quel est le r√©flexe absolu avec malloc ?

A) √©crire
B) free
C) v√©rifier NULL
D) cast

R√©ponse : C

---

Voici **50 questions de quiz sur les listes cha√Æn√©es**, toutes en QCM avec **A, B, C, D**, orient√©es exam C / 42 : parcours, suppression, double pointeur, tri, pi√®ges, conditions limites.

---

## 1)

√Ä quoi sert le champ `next` dans un maillon ?

A) stocker la donn√©e
B) stocker la taille
C) pointer vers le suivant
D) allouer

R√©ponse : C

---

## 2)

Que signifie `t_list *cur` ?

A) un maillon
B) une adresse de maillon
C) un tableau
D) une taille

R√©ponse : B

---

## 3)

Quand utilise-t-on `t_list **begin` ?

A) pour parcourir
B) pour modifier la t√™te
C) pour afficher
D) pour trier

R√©ponse : B

---

## 4)

Comment parcourt-on une liste ?

A) for(i<n)
B) while(cur) cur = cur->next
C) recursion obligatoire
D) malloc

R√©ponse : B

---

## 5)

Quelle ligne supprime le maillon suivant ?

A) free(cur->next)
B) cur->next = cur->next->next
C) cur = cur->next
D) begin = NULL

R√©ponse : B

---

## 6)

Pourquoi stocker `tmp = cur->next` avant unlink ?

A) compter
B) afficher
C) free ensuite
D) trier

R√©ponse : C

---

## 7)

Que devient la liste apr√®s suppression de B ?

```
A -> B -> C
```

A) A -> NULL
B) B -> C
C) A -> C
D) A -> B

R√©ponse : C

---

## 8)

Pourquoi nettoyer la t√™te avec une boucle while ?

A) performance
B) style
C) supprimer plusieurs t√™tes
D) free

R√©ponse : C

---

## 9)

Apr√®s nettoyage de t√™te, quel pointeur sert au parcours ?

A) t_list **
B) t_list *
C) int *
D) char **

R√©ponse : B

---

## 10)

Que se passe-t-il si on avance `cur` juste apr√®s suppression ?

A) rien
B) fuite
C) on saute un maillon
D) crash

R√©ponse : C

---

## 11)

Comment tester fin de liste ?

A) cur->next == 0
B) cur == NULL
C) free
D) break

R√©ponse : B

---

## 12)

Dans remove_if, sur quel √©l√©ment applique-t-on cmp ?

A) cur
B) cur->next
C) begin
D) tmp

R√©ponse : B

---

## 13)

Quand faut-il free un maillon supprim√© ?

A) avant unlink
B) apr√®s unlink
C) jamais
D) √† la fin

R√©ponse : B

---

## 14)

Quel est le pi√®ge si on free avant reconnecter ?

A) fuite
B) segfault
C) corruption
D) warning

R√©ponse : C

---

## 15)

Que contient `*begin` ?

A) une adresse
B) la t√™te
C) un tableau
D) une taille

R√©ponse : B

---

## 16)

Quelle ligne fait changer la t√™te ?

A) begin = begin->next
B) *begin = (*begin)->next
C) cur = cur->next
D) free(begin)

R√©ponse : B

---

## 17)

Pourquoi utiliser bubble sort sur liste ?

A) optimal
B) simple √† impl√©menter
C) rapide
D) r√©cursif

R√©ponse : B

---

## 18)

Que swap-on dans sort_list exam ?

A) pointeurs
B) data
C) malloc
D) free

R√©ponse : B

---

## 19)

Quand le tri est-il termin√© ?

A) cur == NULL
B) cmp toujours vrai
C) swapped == 0
D) fin premier tour

R√©ponse : C

---

## 20)

Que repr√©sente une liste vide ?

A) malloc
B) pointeur NULL
C) tableau vide
D) erreur

R√©ponse : B

---

## 21)

Pourquoi v√©rifier begin_list avant deref ?

A) style
B) crash
C) norme
D) free

R√©ponse : B

---

## 22)

Quel est le bug de while(cur->next) ?

A) saute t√™te
B) oublie dernier
C) segfault
D) fuite

R√©ponse : B

---

## 23)

Comment compter les √©l√©ments ?

A) strlen
B) while(lst) count++
C) malloc
D) cmp

R√©ponse : B

---

## 24)

Pourquoi tmp est indispensable ?

A) style
B) √©viter perdre adresse
C) free double
D) trier

R√©ponse : B

---

## 25)

Que se passe-t-il si tous les √©l√©ments sont supprim√©s ?

A) fuite
B) begin reste
C) begin devient NULL
D) crash

R√©ponse : C

---

## 26)

Pourquoi passer un double pointeur ?

A) vitesse
B) modifier structure
C) free
D) trier

R√©ponse : B

---

## 27)

Que fait cur = cur->next ?

A) supprime
B) avance
C) free
D) copie

R√©ponse : B

---

## 28)

Pourquoi ne pas swap les liens facilement ?

A) lent
B) complexe
C) interdit
D) free

R√©ponse : B

---

## 29)

Quel est le r√¥le du dernier maillon ?

A) stocker
B) next = NULL
C) data = NULL
D) free

R√©ponse : B

---

## 30)

Que signifie next == NULL ?

A) erreur
B) t√™te
C) fin
D) malloc

R√©ponse : C

---

## 31)

Que se passe-t-il si begin vaut NULL ?

A) crash
B) liste vide
C) warning
D) malloc

R√©ponse : B

---

## 32)

Pourquoi ne pas faire cur++ ?

A) interdit
B) liste pas contigu√´
C) segfault
D) norme

R√©ponse : B

---

## 33)

Quel pi√®ge avec cur->next->next sans test ?

A) lent
B) segfault
C) fuite
D) free

R√©ponse : B

---

## 34)

Pourquoi utiliser tmp ?

A) performance
B) style
C) lib√©rer apr√®s
D) trier

R√©ponse : C

---

## 35)

Que contient un maillon ?

A) next uniquement
B) data uniquement
C) data + next
D) taille

R√©ponse : C

---

## 36)

Quel test prot√®ge l‚Äôacc√®s suivant ?

A) if(cur)
B) if(cur->next)
C) free
D) break

R√©ponse : B

---

## 37)

Pourquoi une boucle infinie peut arriver ?

A) free
B) next jamais modifi√©
C) malloc
D) cmp

R√©ponse : B

---

## 38)

Pourquoi ne pas modifier data_ref ?

A) style
B) norme
C) comparaison
D) free

R√©ponse : C

---

## 39)

Que se passe-t-il si cmp est invers√© ?

A) tri faux
B) crash
C) fuite
D) compile

R√©ponse : A

---

## 40)

Pourquoi v√©rifier cur->next avant cmp ?

A) style
B) s√©curit√©
C) norme
D) free

R√©ponse : B

---

## 41)

Comment supprimer le premier maillon ?

A) free(begin)
B) *begin = (*begin)->next
C) cur->next = cur->next->next
D) begin++

R√©ponse : B

---

## 42)

Pourquoi on ne free pas begin directement ?

A) fuite
B) perdre acc√®s
C) lent
D) style

R√©ponse : B

---

## 43)

Que fait lstsize ?

A) free
B) compter
C) trier
D) malloc

R√©ponse : B

---

## 44)

Pourquoi next doit √™tre NULL au dernier ?

A) style
B) arr√™t parcours
C) norme
D) toutes

R√©ponse : D

---

## 45)

Quel est le danger principal des listes ?

A) lenteur
B) erreurs pointeurs
C) malloc
D) style

R√©ponse : B

---

## 46)

Pourquoi ne pas utiliser r√©cursion en exam ?

A) style
B) pile
C) interdit
D) lent

R√©ponse : B

---

## 47)

Quand arr√™ter remove_if ?

A) cur == NULL
B) cur->next == NULL
C) begin == NULL
D) swapped

R√©ponse : B

---

## 48)

Pourquoi nettoyer la t√™te d‚Äôabord ?

A) style
B) absence de pr√©c√©dent
C) performance
D) norme

R√©ponse : B

---

## 49)

Quel est le pattern universel ?

A) for
B) while(ptr)
C) recursion
D) goto

R√©ponse : B

---

## 50)

Quel est le pi√®ge le plus courant en listes ?

A) malloc
B) oublier free
C) avancer au mauvais moment
D) style

R√©ponse : C

---

Voici **50 questions de quiz sur le th√®me ‚ÄúConditions limites‚Äù**, toutes en QCM avec **A, B, C, D**, cibl√©es exam C / 42 : cas extr√™mes, entr√©es atypiques mais valides, pi√®ges classiques.

---

## 1)

Dans itoa, quel est le cas limite principal ?

A) 1
B) -5
C) INT_MIN
D) 42

R√©ponse : C

---

## 2)

Que doit faire split avec une string vide ?

A) crash
B) retourner NULL
C) retourner tableau avec NULL
D) afficher

R√©ponse : C

---

## 3)

Que doit renvoyer ft_range(0,0) ?

A) NULL
B) tableau vide
C) {0}
D) segfault

R√©ponse : C

---

## 4)

Dans wdmatch, que faire si argv[1] est vide ?

A) afficher argv[2]
B) afficher argv[1]
C) juste '\n'
D) segfault

R√©ponse : B

---

## 5)

Que vaut begin_list si la liste est vide ?

A) malloc
B) -1
C) NULL
D) free

R√©ponse : C

---

## 6)

Dans remove_if, si tous les √©l√©ments correspondent ?

A) liste inchang√©e
B) begin pointe dernier
C) begin devient NULL
D) segfault

R√©ponse : C

---

## 7)

Que doit faire atoi("") ?

A) crash
B) 0
C) -1
D) undefined

R√©ponse : B

---

## 8)

Que doit faire split si la string ne contient que des s√©parateurs ?

A) NULL
B) tableau vide
C) tableau avec NULL
D) segfault

R√©ponse : C

---

## 9)

Quel est le cas limite d‚Äôune liste √† un seul √©l√©ment dans sort_list ?

A) crash
B) tri inutile
C) swap obligatoire
D) free

R√©ponse : B

---

## 10)

Que doit faire wdmatch si un caract√®re manque ?

A) afficher argv[1]
B) afficher argv[2]
C) afficher '\n'
D) free

R√©ponse : C

---

## 11)

Dans ft_range(start,end), si start > end ?

A) NULL
B) tableau d√©croissant
C) segfault
D) malloc(0)

R√©ponse : B

---

## 12)

Que vaut len dans itoa(0) ?

A) 0
B) 1
C) 2
D) -1

R√©ponse : B

---

## 13)

Que se passe-t-il si begin_list == NULL dans foreach ?

A) crash
B) rien
C) segfault
D) free

R√©ponse : B

---

## 14)

Que doit faire remove_if si aucune data ne correspond ?

A) vider
B) crash
C) ne rien changer
D) free tout

R√©ponse : C

---

## 15)

Que doit contenir le tableau retourn√© par split ?

A) '\0'
B) EOF
C) NULL final
D) free

R√©ponse : C

---

## 16)

Que vaut atoi("-0") ?

A) 0
B) -0
C) -1
D) erreur

R√©ponse : A

---

## 17)

Dans union, que faire avec string vide ?

A) crash
B) afficher rien
C) afficher '\n'
D) free

R√©ponse : B

---

## 18)

Dans itoa, si n = 0 ?

A) NULL
B) "0"
C) ""
D) segfault

R√©ponse : B

---

## 19)

Que vaut *begin si la liste devient vide ?

A) dernier
B) malloc
C) NULL
D) free

R√©ponse : C

---

## 20)

Que doit faire ft_range(-3,0) ?

A) {0,-1,-2,-3}
B) {-3,-2,-1,0}
C) NULL
D) segfault

R√©ponse : B

---

## 21)

Que doit afficher un programme si argc est incorrect ?

A) erreur
B) rien
C) '\n'
D) exit

R√©ponse : C

---

## 22)

Que doit faire split si un seul mot sans s√©parateurs ?

A) NULL
B) tableau avec ce mot + NULL
C) segfault
D) free

R√©ponse : B

---

## 23)

Dans remove_if, si seule la t√™te correspond ?

A) supprimer t√™te
B) crash
C) rien
D) free tout

R√©ponse : A

---

## 24)

Que se passe-t-il si une liste n‚Äôa qu‚Äôun √©l√©ment et qu‚Äôon le supprime ?

A) begin reste
B) begin devient NULL
C) segfault
D) fuite

R√©ponse : B

---

## 25)

Dans sort_list, une liste vide ?

A) crash
B) retourner NULL
C) free
D) malloc

R√©ponse : B

---

## 26)

Que doit faire atoi avec espaces au d√©but ?

A) crash
B) 0
C) ignorer
D) erreur

R√©ponse : C

---

## 27)

Que doit faire split avec "\n\t " ?

A) NULL
B) tableau NULL
C) crash
D) free

R√©ponse : B

---

## 28)

Que se passe-t-il si wdmatch re√ßoit 3 arguments ?

A) afficher erreur
B) ignorer
C) '\n'
D) segfault

R√©ponse : C

---

## 29)

Que vaut ft_range(5,5) ?

A) NULL
B) {5}
C) {}
D) segfault

R√©ponse : B

---

## 30)

Que doit faire remove_if si begin_list est NULL ?

A) crash
B) rien
C) free
D) malloc

R√©ponse : B

---

## 31)

Que doit faire split si str == NULL ? (si non pr√©cis√©)

A) crash
B) retourner NULL
C) comportement ind√©fini
D) free

R√©ponse : C

---

## 32)

Que doit faire atoi avec "+" ?

A) 0
B) erreur
C) segfault
D) undefined

R√©ponse : D

---

## 33)

Que se passe-t-il si seen n‚Äôest pas r√©initialis√© ?

A) crash
B) doublons supprim√©s √† tort
C) fuite
D) segfault

R√©ponse : B

---

## 34)

Que vaut ft_range(-1,-1) ?

A) NULL
B) {-1}
C) {}
D) segfault

R√©ponse : B

---

## 35)

Que doit faire sort_list avec 1 √©l√©ment ?

A) crash
B) free
C) retourner tel quel
D) swap

R√©ponse : C

---

## 36)

Dans itoa, que vaut "-1" ?

A) impossible
B) "-1"
C) "1-"
D) "-01"

R√©ponse : B

---

## 37)

Que doit faire union si aucun caract√®re commun ?

A) NULL
B) afficher rien
C) afficher '\n'
D) segfault

R√©ponse : B

---

## 38)

Dans split, que faire si dernier mot sans s√©parateur ?

A) ignorer
B) perdre mot
C) ajouter mot
D) crash

R√©ponse : C

---

## 39)

Dans remove_if, si seul dernier correspond ?

A) ne rien faire
B) crash
C) supprimer dernier
D) free tout

R√©ponse : C

---

## 40)

Que doit faire foreach sur liste vide ?

A) crash
B) free
C) rien
D) malloc

R√©ponse : C

---

## 41)

Que vaut atoi("-2147483648") ?

A) overflow
B) crash
C) d√©pend impl√©mentation
D) undefined

R√©ponse : C

---

## 42)

Que doit faire wdmatch si argv[1] == "" ?

A) afficher rien
B) afficher "\n"
C) afficher argv[2]
D) segfault

R√©ponse : A

---

## 43)

Que vaut ft_range(0,-3) ?

A) {0,-1,-2,-3}
B) {-3,-2,-1,0}
C) NULL
D) segfault

R√©ponse : A

---

## 44)

Dans split, si malloc √©choue √† mi-chemin ?

A) continuer
B) fuite
C) free ce qui a √©t√© allou√©
D) segfault

R√©ponse : C

---

## 45)

Que doit faire itoa avec n = 10 ?

A) "01"
B) "10"
C) "010"
D) "-10"

R√©ponse : B

---

## 46)

Dans remove_if, que faire si begin_list == NULL ?

A) crash
B) free
C) return
D) malloc

R√©ponse : C

---

## 47)

Que doit faire sort_list si tous les √©l√©ments sont √©gaux ?

A) crash
B) trier
C) laisser tel quel
D) B et C

R√©ponse : D

---

## 48)

Que vaut atoi("   42") ?

A) 0
B) segfault
C) 42
D) erreur

R√©ponse : C

---

## 49)

Que faire si string contient seulement '\0' ?

A) crash
B) un mot
C) z√©ro mot
D) segfault

R√©ponse : C

---

## 50)

Pourquoi tester les conditions limites en premier ?

A) style
B) gagner du temps
C) √©viter crash
D) C et B

R√©ponse : D

---

Voici **50 questions de quiz sur le th√®me ‚ÄúR√®gles implicites des √©nonc√©s‚Äù**, toutes en QCM avec **A, B, C, D**, cibl√©es exam C / 42 : ce que l‚Äô√©nonc√© ne r√©p√®te pas mais que les tests attendent strictement.

---

## 1)

Si argc est incorrect, que faut-il afficher dans beaucoup d‚Äôexos ?

A) message d‚Äôerreur
B) rien
C) juste `\n`
D) exit(1)

R√©ponse : C

---

## 2)

Que se passe-t-il si le nom du fichier est faux ?

A) warning
B) OK
C) compilation refus√©e
D) runtime error

R√©ponse : C

---

## 3)

Si write est la seule fonction autoris√©e, utiliser printf est :

A) tol√©r√©
B) lent
C) interdit
D) optionnel

R√©ponse : C

---

## 4)

Pourquoi la sortie doit √™tre *exactement* conforme ?

A) style
B) optimisation
C) tests stricts
D) lisibilit√©

R√©ponse : C

---

## 5)

Quand l‚Äô√©nonc√© dit ‚Äúdisplay a \n‚Äù, cela signifie :

A) afficher espace
B) afficher rien
C) afficher un retour ligne
D) free

R√©ponse : C

---

## 6)

Que signifie ‚ÄúExpected files : wdmatch.c‚Äù ?

A) un fichier optionnel
B) plusieurs fichiers
C) un seul fichier nomm√© ainsi
D) n‚Äôimporte quel nom

R√©ponse : C

---

## 7)

Que faire si un include n‚Äôest pas autoris√© ?

A) l‚Äôutiliser quand m√™me
B) commenter
C) ne pas l‚Äôutiliser
D) remplacer printf

R√©ponse : C

---

## 8)

Si le prototype ne correspond pas exactement ?

A) warning
B) runtime
C) compile pas
D) free

R√©ponse : C

---

## 9)

Quand l‚Äô√©nonc√© dit ‚ÄúDo not turn in list.h‚Äù, cela veut dire :

A) ne pas l‚Äôinclure
B) l‚Äô√©crire mais pas rendre
C) l‚Äôignorer
D) l‚Äô√©diter

R√©ponse : B

---

## 10)

Si l‚Äô√©nonc√© impose une structure, peut-on la modifier ?

A) oui
B) oui si mieux
C) non
D) parfois

R√©ponse : C

---

## 11)

Si rien n‚Äôest pr√©cis√© sur malloc qui √©choue, que faire ?

A) ignorer
B) crash
C) prot√©ger
D) printf

R√©ponse : C

---

## 12)

Que faut-il faire quand une fonction est interdite ?

A) la cacher
B) la remplacer
C) l‚Äôutiliser quand m√™me
D) macro

R√©ponse : B

---

## 13)

Quand l‚Äô√©nonc√© ne parle pas d‚Äôaffichage d‚Äôerreur, on affiche :

A) un message
B) stderr
C) rien ou juste \n
D) exit

R√©ponse : C

---

## 14)

Si ‚ÄúInputs will always be consistent‚Äù, cela signifie :

A) pas de malloc
B) pas besoin de v√©rifier pointeurs
C) pas d‚Äôentr√©es invalides
D) pas de NULL

R√©ponse : C

---

## 15)

Que signifie ‚ÄúDuplications must remain‚Äù ?

A) supprimer doublons
B) conserver doublons
C) trier unique
D) free

R√©ponse : B

---

## 16)

Si une fonction autoris√©e n‚Äôest pas list√©e ?

A) OK
B) autoris√©e
C) interdite
D) warning

R√©ponse : C

---

## 17)

Que faire si argc est diff√©rent de ce qui est demand√© ?

A) continuer
B) segfault
C) afficher \n
D) free

R√©ponse : C

---

## 18)

Quand un tableau de strings est attendu, il doit finir par :

A) '\0'
B) EOF
C) NULL
D) free

R√©ponse : C

---

## 19)

Pourquoi ne pas afficher d‚Äôespaces en trop ?

A) style
B) tests √©chouent
C) lent
D) norme

R√©ponse : B

---

## 20)

Quand l‚Äô√©nonc√© donne un exemple avec `| cat -e`, √ßa sert √† :

A) debug
B) montrer caract√®res invisibles
C) compiler
D) free

R√©ponse : B

---

## 21)

Si on imprime plus que demand√© :

A) OK
B) warning
C) tests KO
D) bonus

R√©ponse : C

---

## 22)

Quand une fonction doit retourner un pointeur, on retourne :

A) copie
B) adresse valide
C) variable locale
D) NULL

R√©ponse : B

---

## 23)

Que faire avec une variable locale renvoy√©e par adresse ?

A) OK
B) warning
C) interdit
D) segfault futur

R√©ponse : D

---

## 24)

Quand l‚Äô√©nonc√© pr√©cise un type exact, on peut le changer ?

A) oui
B) oui si logique
C) non
D) parfois

R√©ponse : C

---

## 25)

Si l‚Äô√©nonc√© n‚Äôautorise que malloc, utiliser calloc est :

A) OK
B) mieux
C) interdit
D) warning

R√©ponse : C

---

## 26)

Que signifie ‚ÄúYou must include list.h but must not turn it in‚Äù ?

A) ignorer
B) copier
C) compiler avec, pas rendre
D) modifier

R√©ponse : C

---

## 27)

Pourquoi ne pas ajouter de debug prints ?

A) style
B) tests stricts
C) lent
D) norme

R√©ponse : B

---

## 28)

Quand l‚Äô√©nonc√© demande ‚Äúreturns pointer to first element‚Äù ?

A) dernier
B) milieu
C) t√™te
D) free

R√©ponse : C

---

## 29)

Quand argc est bon mais argv vide ?

A) undefined
B) traiter normalement
C) segfault
D) free

R√©ponse : B

---

## 30)

Que signifie ‚ÄúAllowed functions: write‚Äù ?

A) write + printf
B) toutes
C) uniquement write
D) aucune

R√©ponse : C

---

## 31)

Quand l‚Äô√©nonc√© ne mentionne pas free, doit-on lib√©rer ?

A) jamais
B) parfois
C) oui si n√©cessaire
D) interdit

R√©ponse : C

---

## 32)

Pourquoi ne pas changer l‚Äôordre d‚Äôaffichage ?

A) style
B) lisibilit√©
C) tests
D) norme

R√©ponse : C

---

## 33)

Quand une fonction doit afficher et retourner, on :

A) affiche seulement
B) retourne seulement
C) fait les deux
D) free

R√©ponse : C

---

## 34)

Quand l‚Äô√©nonc√© parle d‚Äôarguments, cela inclut :

A) argv[0]
B) programme
C) argv[1..]
D) free

R√©ponse : C

---

## 35)

Si rien n‚Äôest dit sur les erreurs internes ?

A) afficher
B) ignorer
C) rester silencieux
D) exit

R√©ponse : C

---

## 36)

Pourquoi ne pas utiliser des macros interdites ?

A) style
B) norme
C) r√®gles exam
D) free

R√©ponse : C

---

## 37)

Quand on dit ‚Äúreturns NULL-terminated array‚Äù :

A) '\0' final
B) EOF
C) pointeur NULL
D) free

R√©ponse : C

---

## 38)

Si le sujet dit ‚Äúdo not print anything else‚Äù, on :

A) ajoute debug
B) affiche erreurs
C) respecte strictement
D) free

R√©ponse : C

---

## 39)

Quand l‚Äô√©nonc√© dit ‚ÄúInputs will always be consistent‚Äù, peut-on ignorer argc ?

A) oui
B) parfois
C) non
D) free

R√©ponse : C

---

## 40)

Pourquoi lire l‚Äô√©nonc√© deux fois ?

A) style
B) comprendre pi√®ges
C) lent
D) norme

R√©ponse : B

---

## 41)

Si l‚Äô√©nonc√© demande un retour ligne final, l‚Äôoublier provoque :

A) warning
B) OK
C) test KO
D) free

R√©ponse : C

---

## 42)

Quand une fonction est interdite, peut-on l‚Äôimpl√©menter soi-m√™me ?

A) non
B) oui
C) parfois
D) free

R√©ponse : B

---

## 43)

Quand l‚Äô√©nonc√© donne un exemple pr√©cis, il est :

A) indicatif
B) d√©coratif
C) contractuel
D) free

R√©ponse : C

---

## 44)

Si on affiche dans stderr au lieu de stdout ?

A) OK
B) mieux
C) tests KO
D) free

R√©ponse : C

---

## 45)

Que faire si une fonction autoris√©e est absente ?

A) inventer
B) coder autrement
C) utiliser printf
D) free

R√©ponse : B

---

## 46)

Quand un comportement n‚Äôest pas pr√©cis√© ?

A) inventer
B) faire ce qu‚Äôon veut
C) rester minimal
D) free

R√©ponse : C

---

## 47)

Pourquoi ne pas ajouter de texte explicatif ?

A) style
B) tests stricts
C) lent
D) norme

R√©ponse : B

---

## 48)

Quand l‚Äô√©nonc√© dit ‚Äúreturns pointer‚Äù, renvoyer malloc est :

A) faux
B) correct
C) interdit
D) lent

R√©ponse : B

---

## 49)

Pourquoi respecter noms de fonctions ?

A) style
B) linker
C) compilation
D) B et C

R√©ponse : D

---

## 50)

La r√®gle implicite num√©ro un √† l‚Äôexam :

A) coder vite
B) relire l‚Äô√©nonc√©
C) optimiser
D) commenter

R√©ponse : B

---

Tu as maintenant **les 7 th√®mes complets** :

‚Ä¢ Patterns
‚Ä¢ Pi√®ges
‚Ä¢ R√©flexes m√©moire
‚Ä¢ Pointeurs & malloc
‚Ä¢ Listes cha√Æn√©es
‚Ä¢ Conditions limites
‚Ä¢ R√®gles implicites

