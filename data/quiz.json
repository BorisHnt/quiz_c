[
  {
    "theme": "patterns",
    "question": "ft_split : tu dois produire un tableau de mots. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Compter les mots, allouer `nb_mots + 1` pointeurs, copier chaque mot, puis poser le NULL final.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En ft_split, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_split",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_split : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En ft_split, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_split",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_split : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer d’abord sur les séparateurs, puis sur les caractères du mot sans sauter d’index.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En ft_split, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_split",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_split : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En ft_split, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_split",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_split : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Une entrée vide ou composée uniquement de séparateurs.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En ft_split, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_split",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_range : tu dois produire un tableau d'int entre start et end. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Calculer la taille inclusive, allouer le tableau, remplir avec un step `+1` ou `-1`, puis retourner le pointeur.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En ft_range, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_range",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_range : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En ft_range, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_range",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_range : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Mettre à jour la valeur courante avec `value += step` à chaque itération.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En ft_range, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_range",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_range : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En ft_range, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_range",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_range : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Le cas `start == end`, qui doit retourner un tableau de taille 1.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En ft_range, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_range",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_list_remove_if : tu dois produire une liste nettoyée des maillons à supprimer. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Nettoyer les têtes correspondantes, parcourir avec `cur`, reconnecter, free, puis continuer le parcours.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En ft_list_remove_if, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_list_remove_if : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En ft_list_remove_if, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_list_remove_if : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Ne pas avancer `cur` juste après suppression de `cur->next`.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En ft_list_remove_if, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_list_remove_if : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En ft_list_remove_if, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "ft_list_remove_if : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Plusieurs maillons en tête correspondent au critère de suppression.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En ft_list_remove_if, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "sort_list : tu dois produire une liste triée en place. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Parcourir la liste, swap les data quand `cmp > 0`, marquer swapped, relancer tant qu’il y a eu échange.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En sort_list, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "sort_list",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "sort_list : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En sort_list, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "sort_list",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "sort_list : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer `cur = cur->next` pendant le passage, puis recommencer au début si swapped.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En sort_list, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "sort_list",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "sort_list : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Arrêter quand un passage complet se fait sans swap.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En sort_list, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "sort_list",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "sort_list : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Liste vide ou liste d'un seul élément.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En sort_list, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "sort_list",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "itoa : tu dois produire la chaîne représentant l’entier. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Gérer signe et cas spéciaux, caster en long, compter les caractères, allouer, poser `\\0`, remplir à l’envers.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En itoa, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "itoa",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "itoa : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En itoa, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "itoa",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "itoa : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Décrémenter l’index de fin pendant le remplissage de la chaîne.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En itoa, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "itoa",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "itoa : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En itoa, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "itoa",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "itoa : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Les valeurs `0` et `INT_MIN`.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En itoa, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "itoa",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "wdmatch : tu dois produire un affichage conditionnel de argv[1]. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Vérifier argc, parcourir argv[2], avancer index argv[1] sur match, valider quand argv[1] est entièrement consommé.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En wdmatch, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "wdmatch",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "wdmatch : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En wdmatch, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "wdmatch",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "wdmatch : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer l’index de argv[1] uniquement quand un caractère match dans argv[2].",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En wdmatch, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "wdmatch",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "wdmatch : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En wdmatch, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "wdmatch",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "wdmatch : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Le cas où argv[1] est vide.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En wdmatch, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "wdmatch",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "union : tu dois produire une sortie sans doublons provenant de deux chaînes. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Initialiser seen[256], parcourir la première chaîne puis la seconde, afficher un char inédit, marquer seen.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En union, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "union",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "union : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En union, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "union",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "union : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Parcourir chaque chaîne caractère par caractère jusqu’à `\\0`.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En union, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "union",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "union : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Toujours terminer par un `\\n` unique.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En union, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "union",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "union : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Les chaînes vides doivent être gérées sans accès hors borne.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En union, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "union",
      "edge_case"
    ]
  },
  {
    "theme": "patterns",
    "question": "atoi : tu dois produire la valeur entière convertie. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Ignorer espaces, lire le signe, accumuler les chiffres, arrêter au premier non-chiffre.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "En atoi, l’ordre des étapes est évalué directement par les tests de l’exam. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "atoi",
      "sequence"
    ]
  },
  {
    "theme": "patterns",
    "question": "atoi : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "En atoi, l’ordre des étapes est évalué directement par les tests de l’exam. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "atoi",
      "fail_path"
    ]
  },
  {
    "theme": "patterns",
    "question": "atoi : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Incrémenter l’index à chaque étape consommée.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "En atoi, l’ordre des étapes est évalué directement par les tests de l’exam. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "atoi",
      "loop"
    ]
  },
  {
    "theme": "patterns",
    "question": "atoi : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "En atoi, l’ordre des étapes est évalué directement par les tests de l’exam. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "atoi",
      "finalize"
    ]
  },
  {
    "theme": "patterns",
    "question": "atoi : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Chaîne vide, signe seul, ou `-0`.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "En atoi, l’ordre des étapes est évalué directement par les tests de l’exam. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "atoi",
      "edge_case"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_split : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Ajouter la case de terminaison (`+1`) pour stocker le pointeur NULL final.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_split. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_split",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_split : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_split. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_split",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_split : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Conserver un index de mot stable pour ne pas perdre les allocations intermédiaires.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_split. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_split",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_split : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_split. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_split",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_split : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_split. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_split",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_range : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Calculer `abs(end - start) + 1` pour éviter le off-by-one.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_range. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_range",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_range : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_range. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_range",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_range : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Conserver un pointeur de base pour le return final.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_range. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_range",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_range : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_range. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_range",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_range : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_range. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_range",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_list_remove_if : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Faire `tmp = cur->next`, puis unlink, puis free(tmp), dans cet ordre strict.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_list_remove_if. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_list_remove_if : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_list_remove_if. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_list_remove_if : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser `t_list **begin_list` pour modifier la tête depuis la fonction.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_list_remove_if. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_list_remove_if : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_list_remove_if. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "ft_list_remove_if : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur ft_list_remove_if. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "sort_list : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Swapper les `data` plutôt que les liens si tu n’as pas une gestion complète des pointeurs.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur sort_list. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "sort_list",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "sort_list : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Arrêter quand un passage complet se fait sans swap.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur sort_list. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "sort_list",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "sort_list : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser une variable temporaire pour le swap de data.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur sort_list. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "sort_list",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "sort_list : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur sort_list. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "sort_list",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "sort_list : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur sort_list. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "sort_list",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "itoa : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Caster en `long` avant de manipuler la valeur négative.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur itoa. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "itoa",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "itoa : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur itoa. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "itoa",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "itoa : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Remplir depuis la fin pour éviter un second renversement de chaîne.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur itoa. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "itoa",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "itoa : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur itoa. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "itoa",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "itoa : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur itoa. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "itoa",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "wdmatch : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Conserver le sens de parcours: on scanne argv[2], pas l’inverse.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur wdmatch. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "wdmatch",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "wdmatch : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur wdmatch. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "wdmatch",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "wdmatch : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser deux index indépendants pour garder l’ordre des caractères.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur wdmatch. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "wdmatch",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "wdmatch : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur wdmatch. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "wdmatch",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "wdmatch : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur wdmatch. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "wdmatch",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "union : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Indexer seen avec `(unsigned char)c` pour éviter les index négatifs.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur union. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "union",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "union : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Toujours terminer par un `\\n` unique.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur union. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "union",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "union : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Caster le caractère avant indexation dans seen.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur union. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "union",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "union : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur union. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "union",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "union : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur union. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "union",
      "defensive"
    ]
  },
  {
    "theme": "pieges",
    "question": "atoi : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Vérifier l’incrément dans toutes les branches de boucle pour éviter la boucle infinie.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur atoi. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "atoi",
      "trap"
    ]
  },
  {
    "theme": "pieges",
    "question": "atoi : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur atoi. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "atoi",
      "output_bug"
    ]
  },
  {
    "theme": "pieges",
    "question": "atoi : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Travailler avec un index de lecture stable pour ne pas perdre la position.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur atoi. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "atoi",
      "order"
    ]
  },
  {
    "theme": "pieges",
    "question": "atoi : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur atoi. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "atoi",
      "output_contract"
    ]
  },
  {
    "theme": "pieges",
    "question": "atoi : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège classique qui compile mais échoue en correction automatique sur atoi. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "atoi",
      "defensive"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_split : ta fonction renvoie un tableau de mots. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant libère chaque mot puis le tableau retourné.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_split sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_split : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_split sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_split : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_split sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_split : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `(nb_mots + 1) * sizeof(char *)` pour le tableau de pointeurs.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_split sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_split : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_split sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_range : ta fonction renvoie un tableau d'int entre start et end. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant libère le tableau d'int retourné.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_range sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_range : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_range sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_range : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_range sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_range : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `size * sizeof(int)` avec `size = abs(end - start) + 1`.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_range sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_range : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_range sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : ta fonction renvoie une liste nettoyée des maillons à supprimer. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "La fonction free uniquement les maillons supprimés, pas les maillons conservés.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_list_remove_if sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_list_remove_if sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_list_remove_if sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation: la fonction modifie la liste en place.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_list_remove_if sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise ft_list_remove_if sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "sort_list : ta fonction renvoie une liste triée en place. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucun free à faire dans le tri: on réordonne sans libérer.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise sort_list sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "sort_list : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise sort_list sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "sort_list : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise sort_list sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "sort_list : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation: tri in-place sur la liste existante.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise sort_list sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "sort_list : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise sort_list sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "itoa : ta fonction renvoie la chaîne représentant l’entier. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant est responsable du free de la chaîne retournée.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise itoa sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "itoa : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise itoa sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "itoa : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise itoa sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "itoa : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `(digits + sign + 1) * sizeof(char)`.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise itoa sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "itoa : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise itoa sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "wdmatch : ta fonction renvoie un affichage conditionnel de argv[1]. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans l’implémentation standard.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise wdmatch sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "wdmatch : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise wdmatch sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "wdmatch : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise wdmatch sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "wdmatch : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique n’est nécessaire pour la logique.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise wdmatch sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "wdmatch : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise wdmatch sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "union : ta fonction renvoie une sortie sans doublons provenant de deux chaînes. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans cette approche.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise union sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "union",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "union : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise union sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "union",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "union : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise union sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "union",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "union : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique: tableau seen local de 256 cases.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise union sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "union",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "union : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise union sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "union",
      "dangling"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "atoi : ta fonction renvoie la valeur entière convertie. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer pour atoi.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise atoi sans ajouter de complexité inutile. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "ownership"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "atoi : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "À l’exam, ce réflexe mémoire sécurise atoi sans ajouter de complexité inutile. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "guard"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "atoi : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise atoi sans ajouter de complexité inutile. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "cleanup"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "atoi : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique n’est requise.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "À l’exam, ce réflexe mémoire sécurise atoi sans ajouter de complexité inutile. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "size"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "atoi : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "À l’exam, ce réflexe mémoire sécurise atoi sans ajouter de complexité inutile. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "dangling"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_split : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Conserver un index de mot stable pour ne pas perdre les allocations intermédiaires.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_split sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_split",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_split : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_split sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_split",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_split : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_split sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_split",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_split : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer d’abord sur les séparateurs, puis sur les caractères du mot sans sauter d’index.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_split sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_split",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_split : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_split sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_split",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_range : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Conserver un pointeur de base pour le return final.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_range sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_range",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_range : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_range sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_range",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_range : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_range sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_range",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_range : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Mettre à jour la valeur courante avec `value += step` à chaque itération.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_range sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_range",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_range : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_range sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_range",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_list_remove_if : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser `t_list **begin_list` pour modifier la tête depuis la fonction.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_list_remove_if sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_list_remove_if : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_list_remove_if sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_list_remove_if : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_list_remove_if sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_list_remove_if : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Ne pas avancer `cur` juste après suppression de `cur->next`.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_list_remove_if sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "ft_list_remove_if : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de ft_list_remove_if sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "sort_list : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser une variable temporaire pour le swap de data.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de sort_list sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "sort_list",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "sort_list : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de sort_list sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "sort_list",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "sort_list : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de sort_list sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "sort_list",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "sort_list : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer `cur = cur->next` pendant le passage, puis recommencer au début si swapped.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de sort_list sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "sort_list",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "sort_list : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Arrêter quand un passage complet se fait sans swap.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de sort_list sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "sort_list",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "itoa : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Remplir depuis la fin pour éviter un second renversement de chaîne.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de itoa sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "itoa",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "itoa : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de itoa sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "itoa",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "itoa : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de itoa sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "itoa",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "itoa : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Décrémenter l’index de fin pendant le remplissage de la chaîne.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de itoa sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "itoa",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "itoa : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de itoa sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "itoa",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "wdmatch : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser deux index indépendants pour garder l’ordre des caractères.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de wdmatch sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "wdmatch : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de wdmatch sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "wdmatch : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de wdmatch sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "wdmatch : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer l’index de argv[1] uniquement quand un caractère match dans argv[2].",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de wdmatch sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "wdmatch : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de wdmatch sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "union : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Caster le caractère avant indexation dans seen.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de union sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "union",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "union : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de union sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "union",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "union : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de union sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "union",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "union : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Parcourir chaque chaîne caractère par caractère jusqu’à `\\0`.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de union sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "union",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "union : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Toujours terminer par un `\\n` unique.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de union sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "union",
      "return_pointer"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "atoi : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Travailler avec un index de lecture stable pour ne pas perdre la position.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de atoi sur les cas réels. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "atoi",
      "indirection"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "atoi : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de atoi sur les cas réels. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "atoi",
      "tmp"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "atoi : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de atoi sur les cas réels. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "atoi",
      "deref_guard"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "atoi : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Incrémenter l’index à chaque étape consommée.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de atoi sur les cas réels. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "atoi",
      "advance"
    ]
  },
  {
    "theme": "pointeurs",
    "question": "atoi : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la décision de pointeur conditionne la stabilité de atoi sur les cas réels. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "atoi",
      "return_pointer"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_split : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire un tableau de mots avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_split : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `(nb_mots + 1) * sizeof(char *)` pour le tableau de pointeurs.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_split : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_split : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_split",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_split : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant libère chaque mot puis le tableau retourné.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_split",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_range : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire un tableau d'int entre start et end avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_range : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `size * sizeof(int)` avec `size = abs(end - start) + 1`.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_range : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_range : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur ft_range, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_range",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_range : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant libère le tableau d'int retourné.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_range",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_list_remove_if : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_list_remove_if : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation: la fonction modifie la liste en place.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_list_remove_if : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_list_remove_if : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur ft_list_remove_if, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "ft_list_remove_if : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "La fonction free uniquement les maillons supprimés, pas les maillons conservés.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "sort_list : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "sort_list : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation: tri in-place sur la liste existante.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "sort_list : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "sort_list : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur sort_list, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "sort_list",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "sort_list : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucun free à faire dans le tri: on réordonne sans libérer.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "sort_list",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "itoa : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire la chaîne représentant l’entier avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur itoa, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "itoa : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `(digits + sign + 1) * sizeof(char)`.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur itoa, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "itoa : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur itoa, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "itoa : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur itoa, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "itoa",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "itoa : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant est responsable du free de la chaîne retournée.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur itoa, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "itoa",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "wdmatch : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "wdmatch : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique n’est nécessaire pour la logique.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "wdmatch : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "wdmatch : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur wdmatch, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "wdmatch",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "wdmatch : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans l’implémentation standard.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "wdmatch",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "union : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur union, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "union",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "union : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique: tableau seen local de 256 cases.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur union, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "union",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "union : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur union, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "union",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "union : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur union, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "union",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "union : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans cette approche.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur union, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "union",
      "free_contract"
    ]
  },
  {
    "theme": "malloc",
    "question": "atoi : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Sur atoi, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_need"
    ]
  },
  {
    "theme": "malloc",
    "question": "atoi : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique n’est requise.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Sur atoi, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_size"
    ]
  },
  {
    "theme": "malloc",
    "question": "atoi : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Sur atoi, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_fail"
    ]
  },
  {
    "theme": "malloc",
    "question": "atoi : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Sur atoi, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "atoi",
      "sizing_reflex"
    ]
  },
  {
    "theme": "malloc",
    "question": "atoi : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer pour atoi.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Sur atoi, cette décision d’allocation évite les crashs et les fuites pendant les tests limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "atoi",
      "free_contract"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_split : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Une entrée vide ou composée uniquement de séparateurs.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de ft_split cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_split : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Le dernier mot n’est pas suivi d’un séparateur.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de ft_split cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_split : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de ft_split cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_split : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de ft_split cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_split : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Ajouter la case de terminaison (`+1`) pour stocker le pointeur NULL final.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de ft_split cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_range : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Le cas `start == end`, qui doit retourner un tableau de taille 1.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de ft_range cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_range : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Le cas `start > end`, qui impose un parcours décroissant.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de ft_range cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_range : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de ft_range cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_range : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de ft_range cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_range : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Calculer `abs(end - start) + 1` pour éviter le off-by-one.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de ft_range cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Plusieurs maillons en tête correspondent au critère de suppression.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de ft_list_remove_if cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Suppression du dernier maillon sans perdre la chaîne.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de ft_list_remove_if cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de ft_list_remove_if cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de ft_list_remove_if cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Faire `tmp = cur->next`, puis unlink, puis free(tmp), dans cet ordre strict.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de ft_list_remove_if cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "sort_list : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Liste vide ou liste d'un seul élément.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de sort_list cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "sort_list : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Tous les éléments égaux, le tri doit rester stable sans boucle infinie.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de sort_list cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "sort_list : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de sort_list cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "sort_list : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de sort_list cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "sort_list : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Swapper les `data` plutôt que les liens si tu n’as pas une gestion complète des pointeurs.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de sort_list cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "itoa : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Les valeurs `0` et `INT_MIN`.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de itoa cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "itoa",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "itoa : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "INT_MIN ne peut pas être négaté en int sans overflow.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de itoa cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "itoa",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "itoa : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de itoa cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "itoa",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "itoa : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de itoa cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "itoa",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "itoa : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Caster en `long` avant de manipuler la valeur négative.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de itoa cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "itoa",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "wdmatch : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Le cas où argv[1] est vide.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de wdmatch cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "wdmatch : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Un caractère manquant doit invalider immédiatement le match.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de wdmatch cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "wdmatch : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de wdmatch cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "wdmatch : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de wdmatch cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "wdmatch : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Conserver le sens de parcours: on scanne argv[2], pas l’inverse.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de wdmatch cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "union : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Les chaînes vides doivent être gérées sans accès hors borne.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de union cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "union",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "union : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Caractères hors ASCII standard avec char signé.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de union cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "union",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "union : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de union cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "union",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "union : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de union cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "union",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "union : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Indexer seen avec `(unsigned char)c` pour éviter les index négatifs.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de union cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "union",
      "off_by_one"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "atoi : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Chaîne vide, signe seul, ou `-0`.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "La correction de atoi cible d’abord ce cas limite. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "atoi",
      "edge_priority"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "atoi : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Entrée avec espaces puis signe, ex: \"   -42\".",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "La correction de atoi cible d’abord ce cas limite. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "atoi",
      "limit_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "atoi : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "La correction de atoi cible d’abord ce cas limite. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "atoi",
      "input_guard"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "atoi : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "La correction de atoi cible d’abord ce cas limite. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "atoi",
      "minimal_case"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "atoi : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Vérifier l’incrément dans toutes les branches de boucle pour éviter la boucle infinie.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "La correction de atoi cible d’abord ce cas limite. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "atoi",
      "off_by_one"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_split : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_split, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_split : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_split, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_split : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Si les arguments du main de test sont invalides, écrire uniquement un retour ligne.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans ft_split, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_split : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_split, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_split : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_split, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_range : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_range, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_range : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_range, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_range : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter exactement le prototype demandé par l’énoncé pour la correction.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans ft_range, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_range : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_range, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_range : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_range, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_list_remove_if, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_list_remove_if, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Garder exactement la signature imposée (`t_list **begin_list`, cmp, free_fct).",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans ft_list_remove_if, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_list_remove_if, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans ft_list_remove_if, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "sort_list : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans sort_list, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "sort_list : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans sort_list, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "sort_list : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter strictement la fonction de comparaison imposée par l’énoncé.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans sort_list, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "sort_list : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans sort_list, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "sort_list : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans sort_list, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "itoa : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans itoa, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "itoa",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "itoa : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans itoa, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "itoa",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "itoa : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Ne rien afficher: itoa doit uniquement retourner une chaîne.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans itoa, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "itoa",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "itoa : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans itoa, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "itoa",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "itoa : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans itoa, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "itoa",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "wdmatch : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans wdmatch, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "wdmatch : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans wdmatch, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "wdmatch : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Sortie stricte: aucun texte annexe, juste le résultat attendu et `\\n`.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans wdmatch, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "wdmatch : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans wdmatch, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "wdmatch : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans wdmatch, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "union : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans union, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "union",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "union : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans union, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "union",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "union : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter la sortie exacte attendue, sans espace ni message supplémentaire.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans union, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "union",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "union : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans union, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "union",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "union : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans union, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "union",
      "final_check"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "atoi : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans atoi, la non-conformité au sujet fait tomber la note. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "atoi",
      "allowed_functions"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "atoi : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans atoi, la non-conformité au sujet fait tomber la note. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "atoi",
      "prototype"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "atoi : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "La fonction retourne une valeur; elle ne doit pas produire de sortie texte.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même avec une bonne logique dans atoi, la non-conformité au sujet fait tomber la note. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "atoi",
      "argc_contract"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "atoi : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans atoi, la non-conformité au sujet fait tomber la note. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "atoi",
      "exact_output"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "atoi : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même avec une bonne logique dans atoi, la non-conformité au sujet fait tomber la note. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "atoi",
      "final_check"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En listes chaînées, l’ordre pointeur/reconnexion/free fait la différence dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ]
  }
]
