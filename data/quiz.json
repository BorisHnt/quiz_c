[
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé dans `ft_split` avant d’appeler malloc pour le tableau ?",
    "choices": [
      "remplir → compter → terminer",
      "compter → malloc → remplir → terminer",
      "malloc → remplir → compter (fonction/pattern standard en C)",
      "free → malloc → remplir (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) compter → malloc → remplir → terminer. Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel est le pattern classique pour convertir un int en string (itoa) ?",
    "choices": [
      "remplir → malloc → compter (fonction/pattern standard en C)",
      "compter → remplir → malloc (fonction/pattern standard en C)",
      "gérer signe → compter → malloc → remplir à l’envers",
      "malloc → signe → remplir (fonction/pattern standard en C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) gérer signe → compter → malloc → remplir à l’envers. Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans `union`, quel pattern évite les doublons ?",
    "choices": [
      "tri préalable (algorithme de tri spécifique)",
      "compteur global (stratégie de suivi d'état)",
      "tableau seen[256] (pattern/instruction C)",
      "malloc dynamique (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tableau seen[256] (pattern/instruction C). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à parcourir une liste chaînée ?",
    "choices": [
      "for(i=0;i<n;i++) (pattern/instruction C)",
      "while(node) node = node->next",
      "do while (pattern/instruction C)",
      "récursion obligatoire (fonction/pattern standard en C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(node) node = node->next. En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans `ft_list_remove_if`, quel pattern gère la tête ?",
    "choices": [
      "cur = begin (pattern/instruction C)",
      "boucle while sur *begin (pattern/instruction C)",
      "for (boucle à compteur)",
      "swap data (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) boucle while sur *begin (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern permet d’éviter de perdre l’adresse d’un maillon supprimé ?",
    "choices": [
      "tmp = cur (pattern/instruction C)",
      "tmp = cur->next (pattern/instruction C)",
      "free(cur) (pattern/instruction C)",
      "continue (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tmp = cur->next (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel est le pattern pour remplir une string terminée ?",
    "choices": [
      "'\\n' au début (pattern/instruction C)",
      "'\\0' à la fin (pattern/instruction C)",
      "'\\t' au milieu (pattern/instruction C)",
      "free à la fin (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) '\\0' à la fin (pattern/instruction C). En C, une chaîne correcte se termine par `\\0`; sans ce marqueur, la lecture peut dépasser la zone mémoire prévue. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern permet de gérer INT_MIN dans itoa ?",
    "choices": [
      "cast en float (conversion de type pour adapter le calcul)",
      "cast en long (conversion de type pour adapter le calcul)",
      "malloc double (pattern/instruction C)",
      "memcpy (copie mémoire brute)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) cast en long (conversion de type pour adapter le calcul). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à ignorer les séparateurs ?",
    "choices": [
      "if unique (pattern/instruction C)",
      "while(is_sep) avancer (pattern/instruction C)",
      "break (sortie anticipée de boucle)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(is_sep) avancer (pattern/instruction C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans `sort_list`, quel pattern indique la fin du tri ?",
    "choices": [
      "i == n (pattern/instruction C)",
      "cmp == 0 (pattern/instruction C)",
      "swapped == 0 (pattern/instruction C)",
      "cur == NULL (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) swapped == 0 (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour compter des chiffres ?",
    "choices": [
      "while(n) { n/=10; } (pattern/instruction C)",
      "for(i=0;i<n;i++) (pattern/instruction C)",
      "malloc (allocation dynamique mémoire)",
      "strcpy (copie de chaîne standard)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) while(n) { n/=10; } (pattern/instruction C). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à strdup et split ?",
    "choices": [
      "strcpy direct (fonction/pattern standard en C)",
      "compter longueur → malloc → copier",
      "free (libération explicite de la mémoire allouée)",
      "sort (algorithme de tri spécifique)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) compter longueur → malloc → copier. Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern garantit la fin d’un tableau de strings ?",
    "choices": [
      "'\\0' (caractère de fin de chaîne)",
      "NULL final (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) NULL final (pattern/instruction C). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern empêche une boucle infinie lors d’un comptage ?",
    "choices": [
      "continue (mécanisme de contrôle du flux ou des pointeurs)",
      "break (sortie anticipée de boucle)",
      "modifier la variable testée (mécanisme de contrôle du flux ou des pointeurs)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) modifier la variable testée (mécanisme de contrôle du flux ou des pointeurs). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans wdmatch, quel pattern est utilisé ?",
    "choices": [
      "deux boucles imbriquées inversées",
      "parcourir argv[1] seulement (instruction/pattern C explicite)",
      "parcourir argv[2] en avançant dans argv[1]",
      "tri préalable (algorithme de tri spécifique)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) parcourir argv[2] en avançant dans argv[1]. Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour supprimer plusieurs têtes successives ?",
    "choices": [
      "if (pattern/instruction C)",
      "while (pattern/instruction C)",
      "for (boucle à compteur)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while (pattern/instruction C). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à atoi et itoa ?",
    "choices": [
      "modulo (opération arithmétique basée sur le reste)",
      "strlen (calcul de longueur de chaîne)",
      "memcpy (copie mémoire brute)",
      "sort (algorithme de tri spécifique)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) modulo (opération arithmétique basée sur le reste). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour swap deux data dans sort_list ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "tmp variable (mécanisme de contrôle du flux ou des pointeurs)",
      "free (libération explicite de la mémoire allouée)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tmp variable (mécanisme de contrôle du flux ou des pointeurs). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern permet de gérer start > end dans ft_range ?",
    "choices": [
      "for fixe (pattern/instruction C)",
      "step = +1 ou -1 (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) step = +1 ou -1 (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern permet d’allouer un tableau d’int ?",
    "choices": [
      "malloc(n) (pattern/instruction C)",
      "malloc(sizeof(int)) (pattern/instruction C)",
      "malloc(sizeof(int) * n) (pattern/instruction C)",
      "calloc(1) (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) malloc(sizeof(int) * n) (pattern/instruction C). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour détecter la fin d’une string ?",
    "choices": [
      "'\\n' (retour ligne)",
      "'\\t' (pattern/instruction C)",
      "'\\0' (caractère de fin de chaîne)",
      "EOF (fin de flux/entrée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) '\\0' (caractère de fin de chaîne). En C, une chaîne correcte se termine par `\\0`; sans ce marqueur, la lecture peut dépasser la zone mémoire prévue. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour compter les mots ?",
    "choices": [
      "while(str) (pattern/instruction C)",
      "transitions séparateur → lettre",
      "strlen (calcul de longueur de chaîne)",
      "atoi (conversion chaîne vers entier)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) transitions séparateur → lettre. Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à protéger malloc ?",
    "choices": [
      "if(ptr) free (pattern/instruction C)",
      "if(!ptr) return NULL (pattern/instruction C)",
      "break (sortie anticipée de boucle)",
      "exit obligatoire (fonction/pattern standard en C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) if(!ptr) return NULL (pattern/instruction C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour remplir une string depuis la droite ?",
    "choices": [
      "index croissant (mécanisme de contrôle du flux ou des pointeurs)",
      "index décroissant (mécanisme de contrôle du flux ou des pointeurs)",
      "memcpy (copie mémoire brute)",
      "strcpy (copie de chaîne standard)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) index décroissant (mécanisme de contrôle du flux ou des pointeurs). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à éviter de sauter un élément après suppression ?",
    "choices": [
      "avancer toujours (règle de déplacement du pointeur de parcours)",
      "ne pas avancer après unlink (règle de déplacement du pointeur de parcours)",
      "free double (pattern/instruction C)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) ne pas avancer après unlink (règle de déplacement du pointeur de parcours). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à union et inter ?",
    "choices": [
      "bubble sort (algorithme de tri spécifique)",
      "seen[256] (pattern/instruction C)",
      "récursion (appel de fonction sur elle-même)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) seen[256] (pattern/instruction C). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à gérer argc ?",
    "choices": [
      "strcmp (mécanisme de contrôle du flux ou des pointeurs)",
      "if(argc != attendu) (pattern/instruction C)",
      "malloc (allocation dynamique mémoire)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) if(argc != attendu) (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour remplir un tableau avec une suite ?",
    "choices": [
      "while (pattern/instruction C)",
      "step + incrément (mécanisme de contrôle du flux ou des pointeurs)",
      "récursion (appel de fonction sur elle-même)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) step + incrément (mécanisme de contrôle du flux ou des pointeurs). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour parcourir argv ?",
    "choices": [
      "argv++ (instruction/pattern C explicite)",
      "while(argv[i]) (pattern/instruction C)",
      "strcpy (copie de chaîne standard)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(argv[i]) (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à toutes les fonctions avec sortie texte ?",
    "choices": [
      "printf (affichage formaté standard)",
      "write + '\\n' (pattern/instruction C)",
      "scanf (fonction d'entrée standard de la libc)",
      "fgets (fonction d'entrée standard de la libc)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) write + '\\n' (pattern/instruction C). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour stocker l’état des cartes ratées ?",
    "choices": [
      "tableau fixe (stratégie de suivi d'état)",
      "compteur par carte (stratégie de suivi d'état)",
      "free (libération explicite de la mémoire allouée)",
      "strcpy (copie de chaîne standard)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) compteur par carte (stratégie de suivi d'état). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à calculer une taille inclusive ?",
    "choices": [
      "end-start (piste alternative proposée dans ce type de QCM)",
      "abs(end-start) (pattern/instruction C)",
      "abs(end-start)+1 (pattern/instruction C)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) abs(end-start)+1 (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à parcourir jusqu’à NULL ?",
    "choices": [
      "while(ptr) (parcours jusqu'à NULL)",
      "for (boucle à compteur)",
      "if (pattern/instruction C)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) while(ptr) (parcours jusqu'à NULL). Le `NULL` final joue le rôle de sentinelle pour stopper les parcours sans ambiguïté. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour repérer un début de mot ?",
    "choices": [
      "lettre + lettre (pattern de transition entre caractères)",
      "séparateur + lettre (pattern de transition entre caractères)",
      "lettre + séparateur (pattern de transition entre caractères)",
      "EOF (fin de flux/entrée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) séparateur + lettre (pattern de transition entre caractères). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour remplir un tableau dynamique ?",
    "choices": [
      "malloc puis indexation (pattern/instruction C)",
      "realloc constant (fonction/pattern standard en C)",
      "récursion (appel de fonction sur elle-même)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) malloc puis indexation (pattern/instruction C). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à convertir un char chiffre en int ?",
    "choices": [
      "c * 10 (pattern/instruction C)",
      "c + '0' (conversion numérique vers caractère ASCII)",
      "c - '0' (conversion caractère ASCII vers valeur numérique)",
      "atoi (conversion chaîne vers entier)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) c - '0' (conversion caractère ASCII vers valeur numérique). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à convertir un int en char chiffre ?",
    "choices": [
      "n + '0' (conversion numérique vers caractère ASCII)",
      "n - '0' (conversion caractère ASCII vers valeur numérique)",
      "n * '0' (pattern/instruction C)",
      "atoi (conversion chaîne vers entier)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) n + '0' (conversion numérique vers caractère ASCII). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour nettoyer un pointeur après free ?",
    "choices": [
      "ptr++ (incrément de pointeur)",
      "ptr = NULL (réinitialisation après free)",
      "malloc (allocation dynamique mémoire)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) ptr = NULL (réinitialisation après free). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à tous les parcours ?",
    "choices": [
      "condition + avancement (boucle pilotée par test puis progression)",
      "malloc (allocation dynamique mémoire)",
      "free (libération explicite de la mémoire allouée)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) condition + avancement (boucle pilotée par test puis progression). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour stocker temporairement une valeur ?",
    "choices": [
      "static (durée de vie statique)",
      "tmp (variable temporaire)",
      "free (libération explicite de la mémoire allouée)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tmp (variable temporaire). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour parcourir une string ?",
    "choices": [
      "for sans condition (pattern/instruction C)",
      "while(str[i]) (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(str[i]) (pattern/instruction C). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à s’arrêter sur un séparateur ?",
    "choices": [
      "while(!sep) (pattern/instruction C)",
      "break (sortie anticipée de boucle)",
      "free (libération explicite de la mémoire allouée)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) while(!sep) (pattern/instruction C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à copier un mot ?",
    "choices": [
      "strcpy (copie de chaîne standard)",
      "boucle char par char (copie/passage caractère par caractère)",
      "memcpy uniquement (fonction/pattern standard en C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) boucle char par char (copie/passage caractère par caractère). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à toutes les allocations ?",
    "choices": [
      "malloc + free (pattern/instruction C)",
      "sizeof (calcul de taille en octets)",
      "if(!ptr) (pattern/instruction C)",
      "A + C (combinaison de propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) A + C (combinaison de propositions). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour tester la fin d’un tableau de strings ?",
    "choices": [
      "'\\0' (caractère de fin de chaîne)",
      "NULL (pointeur nul sentinelle)",
      "EOF (fin de flux/entrée)",
      "0xFF (constante hexadécimale)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) NULL (pointeur nul sentinelle). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert à gérer un cas spécial ?",
    "choices": [
      "if initial (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "malloc (allocation dynamique mémoire)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) if initial (pattern/instruction C). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour inverser une string ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "deux indices i/j (parcours symétrique avec deux index)",
      "récursion (appel de fonction sur elle-même)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) deux indices i/j (parcours symétrique avec deux index). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour faire un tri simple ?",
    "choices": [
      "quicksort (algorithme de tri spécifique)",
      "bubble sort (algorithme de tri spécifique)",
      "mergesort (algorithme de tri spécifique)",
      "heapsort (algorithme de tri spécifique)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) bubble sort (algorithme de tri spécifique). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé pour stocker une erreur ?",
    "choices": [
      "flag (indicateur d'état binaire)",
      "free (libération explicite de la mémoire allouée)",
      "sizeof (calcul de taille en octets)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) flag (indicateur d'état binaire). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun à tous les exos d’exam réussis ?",
    "choices": [
      "vitesse (priorité à la rapidité)",
      "écrire direct (piste alternative proposée dans ce type de QCM)",
      "checklist mentale (méthode de vérification systématique avant rendu)",
      "copier internet (contournement risqué des contraintes du sujet)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) checklist mentale (méthode de vérification systématique avant rendu). Le schéma retenu organise les étapes dans le bon ordre, ce qui évite les erreurs de structure. Repère pratique: pense toujours en séquence « compter -> allouer -> remplir -> terminer » quand c'est pertinent.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel oubli provoque le plus souvent un dépassement mémoire lors d’une copie de string ?",
    "choices": [
      "oublier sizeof (marqueur ou valeur sentinelle)",
      "oublier '\\0' (pattern/instruction C)",
      "oublier free (fuite mémoire potentielle)",
      "oublier argc (instruction/pattern C explicite)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) oublier '\\0' (pattern/instruction C). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exo d’exam, que faut-il afficher si argc est incorrect ?",
    "choices": [
      "message d’erreur (texte explicatif ajouté)",
      "rien (aucune action spécifique)",
      "juste '\\n' (retour ligne sans autre texte)",
      "exit(1) (sortie immédiate avec code erreur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) juste '\\n' (retour ligne sans autre texte). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel est le piège principal dans wdmatch ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "mauvais sens de parcours (règle de déplacement du pointeur de parcours)",
      "tri (ordonnancement des éléments)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) mauvais sens de parcours (règle de déplacement du pointeur de parcours). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel est le piège classique dans split ?",
    "choices": [
      "free trop tôt (pattern/instruction C)",
      "ne pas compter les mots (omission de l'étape de précomptage)",
      "malloc trop grand (pattern/instruction C)",
      "utiliser printf (sortie formatée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) ne pas compter les mots (omission de l'étape de précomptage). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi seen[256] doit être indexé avec unsigned char ?",
    "choices": [
      "optimisation (objectif performance)",
      "éviter indices négatifs (mécanisme de contrôle du flux ou des pointeurs)",
      "style (choix de forme et lisibilité)",
      "tri (ordonnancement des éléments)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter indices négatifs (mécanisme de contrôle du flux ou des pointeurs). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège survient si on avance cur après avoir supprimé cur->next ?",
    "choices": [
      "double free (libération multiple du même bloc)",
      "fuite (mémoire allouée non libérée)",
      "saut d’élément (élément ignoré après modification de liste)",
      "segfault immédiat (risque technique réel à l'exécution)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) saut d’élément (élément ignoré après modification de liste). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans itoa, que se passe-t-il si on ne traite pas INT_MIN ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "overflow (dépassement de capacité)",
      "boucle infinie (condition jamais atteinte)",
      "segmentation fault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) overflow (dépassement de capacité). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège arrive si on oublie de vérifier malloc ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "free manquant (pattern/instruction C)",
      "segfault (accès mémoire invalide)",
      "compilation impossible (échec immédiat à la compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) segfault (accès mémoire invalide). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi dst[i] = \"\\0\" est faux ?",
    "choices": [
      "trop long (erreur de taille/bornes mémoire)",
      "type incorrect (piste alternative proposée dans ce type de QCM)",
      "compile mais bug (conséquence sur compilation/tests)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) type incorrect (interprétation possible selon le contexte technique). En C, une chaîne correcte se termine par `\\0`; sans ce marqueur, la lecture peut dépasser la zone mémoire prévue. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel est le piège avec while(n) quand n vaut 0 ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "boucle infinie (condition jamais atteinte)",
      "boucle ignorée (piste alternative proposée dans ce type de QCM)",
      "double free (libération multiple du même bloc)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) boucle ignorée (interprétation possible selon le contexte technique). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel oubli cause une boucle infinie ?",
    "choices": [
      "break (sortie anticipée de boucle)",
      "incrément (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) incrément (interprétation possible selon le contexte technique). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec start > end dans ft_range ?",
    "choices": [
      "segfault (accès mémoire invalide)",
      "rien (aucune action spécifique)",
      "oublier step négatif (mécanisme de contrôle du flux ou des pointeurs)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) oublier step négatif (mécanisme de contrôle du flux ou des pointeurs). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Que se passe-t-il si on écrit malloc(len) au lieu de malloc(len + 1) ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "un caractère manquant (erreur de taille/bornes mémoire)",
      "écriture hors limites (erreur de taille/bornes mémoire)",
      "compile pas (échec de compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) écriture hors limites (erreur de taille/bornes mémoire). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi '\\n' final est obligatoire dans beaucoup d’exos ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "tests automatiques (conséquence sur compilation/tests)",
      "malloc (allocation dynamique mémoire)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tests automatiques (conséquence sur compilation/tests). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège survient si on ne remet pas à zéro seen[256] ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "doublons ratés (gestion incomplète des duplications)",
      "faux positifs (mécanisme de contrôle du flux ou des pointeurs)",
      "segmentation fault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) faux positifs (mécanisme de contrôle du flux ou des pointeurs). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi modifier directement nbr dans itoa est dangereux ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "on perd la valeur originale (perte d'information avant la fin du traitement)",
      "segmentation fault (accès mémoire invalide)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) on perd la valeur originale (perte d'information avant la fin du traitement). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel est le piège avec char signé utilisé comme index ?",
    "choices": [
      "lent (coût en performance)",
      "overflow (dépassement de capacité)",
      "index négatif (mécanisme de contrôle du flux ou des pointeurs)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) index négatif (mécanisme de contrôle du flux ou des pointeurs). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Que provoque un prototype différent de l’énoncé ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "runtime error (erreur à l'exécution)",
      "compilation KO (échec immédiat à la compilation)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) compilation KO (échec immédiat à la compilation). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec printf quand write est imposé ?",
    "choices": [
      "lent (coût en performance)",
      "mauvais output (sortie non conforme)",
      "interdit (non autorisé par l'énoncé)",
      "compile pas (échec de compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) interdit (non autorisé par l'énoncé). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi il faut traiter le cas string vide ?",
    "choices": [
      "sinon crash (risque technique réel à l'exécution)",
      "sinon sortie fausse (réponse de principe selon le contexte)",
      "sinon warning (conséquence sur compilation/tests)",
      "sinon tri (réponse de principe selon le contexte)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) sinon sortie fausse (réponse de principe selon le contexte). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège arrive si on free sans unlink ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)",
      "double free (libération multiple du même bloc)",
      "corruption (structure mémoire incohérente)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) corruption (structure mémoire incohérente). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège si on oublie de mettre NULL dans un tableau de strings ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "parcours infini (effet de parcours incorrect sur la structure)",
      "compile pas (échec de compilation)",
      "segmentation fault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) parcours infini (effet de parcours incorrect sur la structure). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi il faut travailler sur une copie pour compter ?",
    "choices": [
      "performance (impact temps/exécution)",
      "éviter modifier l’original (mécanisme de contrôle du flux ou des pointeurs)",
      "style (choix de forme et lisibilité)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter modifier l’original (mécanisme de contrôle du flux ou des pointeurs). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec while(ptr->next) ?",
    "choices": [
      "saute la tête (effet de parcours incorrect sur la structure)",
      "oublie dernier (dernier élément non traité)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) oublie dernier (dernier élément non traité). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec cmp mal utilisé ?",
    "choices": [
      "segfault (accès mémoire invalide)",
      "tri inversé (ordre de comparaison inversé)",
      "doublons (gestion incomplète des duplications)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tri inversé (ordre de comparaison inversé). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Que se passe-t-il si on swap les pointeurs au lieu des data dans sort_list sans précaution ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "casse la liste (rupture de la chaîne de pointeurs)",
      "lent (coût en performance)",
      "rien (aucune action spécifique)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) casse la liste (rupture de la chaîne de pointeurs). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi argc doit être strictement vérifié ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "tests (validation automatique)",
      "compilation (phase de build)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests (validation automatique). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec free(tmp) avant reconnecter ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)",
      "corruption (structure mémoire incohérente)",
      "rien (aucune action spécifique)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) corruption (structure mémoire incohérente). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi while(*begin_list) est nécessaire au début ?",
    "choices": [
      "performance (impact temps/exécution)",
      "style (choix de forme et lisibilité)",
      "supprimer plusieurs têtes (gestion répétée des suppressions en tête de liste)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) supprimer plusieurs têtes (gestion répétée des suppressions en tête de liste). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec index mal initialisé ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "valeur indéfinie (résultat non garanti par le langage C)",
      "lent (coût en performance)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) valeur indéfinie (résultat non garanti par le langage C). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège si on oublie d’initialiser len ?",
    "choices": [
      "segmentation fault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)",
      "taille aléatoire (fonction/pattern standard en C)",
      "compile pas (échec de compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) taille aléatoire (fonction/pattern standard en C). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi ne pas utiliser des guillemets typographiques ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "pas ASCII (caractère non ASCII pouvant casser la compilation)",
      "compile pas (échec de compilation)",
      "lent (coût en performance)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) compile pas (échec de compilation). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec for(i<=len) ?",
    "choices": [
      "saute un (effet de parcours incorrect sur la structure)",
      "dépasse (erreur de taille/bornes mémoire)",
      "boucle infinie (condition jamais atteinte)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) dépasse (erreur de taille/bornes mémoire). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi il faut caster en unsigned char dans union ?",
    "choices": [
      "performance (impact temps/exécution)",
      "norme (respect des règles/prototypes imposés)",
      "sécurité index (mécanisme de contrôle du flux ou des pointeurs)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) sécurité index (mécanisme de contrôle du flux ou des pointeurs). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège si on affiche trop de texte ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "compile pas (échec de compilation)",
      "tests KO (sortie non conforme)",
      "lent (coût en performance)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests KO (sortie non conforme). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi il ne faut pas avancer cur après suppression ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "sauter un (effet de parcours incorrect sur la structure)",
      "boucle infinie (condition jamais atteinte)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) sauter un (effet de parcours incorrect sur la structure). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec return prématuré ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "style (choix de forme et lisibilité)",
      "optimisation (objectif performance)",
      "compile pas (échec de compilation)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) fuite (mémoire allouée non libérée). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec malloc(sizeof(ptr) * n) ?",
    "choices": [
      "trop petit (taille mémoire insuffisante)",
      "trop grand (allocation excessive)",
      "lent (coût en performance)",
      "segmentation fault (accès mémoire invalide)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) trop petit (taille mémoire insuffisante). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec while(str[i] != '\\n') ?",
    "choices": [
      "ignore '\\0' (pattern/instruction C)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)",
      "compile pas (échec de compilation)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) ignore '\\0' (pattern/instruction C). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi ne pas oublier le free dans remove_if ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "performance (impact temps/exécution)",
      "fuite mémoire (risque technique réel à l'exécution)",
      "compile pas (échec de compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) fuite mémoire (risque technique réel à l'exécution). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec un tableau global non remis à zéro ?",
    "choices": [
      "lent (coût en performance)",
      "pollution d’état (état global réutilisé entre cas de test)",
      "segfault (accès mémoire invalide)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pollution d’état (état global réutilisé entre cas de test). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi un include interdit peut faire rater ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "runtime (phase d'exécution)",
      "règles exam (respect des contraintes imposées)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) règles exam (respect des contraintes imposées). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec strcmp au lieu de comparer chars ?",
    "choices": [
      "lent (coût en performance)",
      "hors sujet (approche non alignée avec la consigne)",
      "interdit (non autorisé par l'énoncé)",
      "segmentation fault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) interdit (non autorisé par l'énoncé). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi oublier le cast long peut casser ?",
    "choices": [
      "lent (coût en performance)",
      "overflow (dépassement de capacité)",
      "fuite (mémoire allouée non libérée)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) overflow (dépassement de capacité). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec while(cur) au lieu de while(cur->next) dans remove_if ?",
    "choices": [
      "saute tête (effet de parcours incorrect sur la structure)",
      "impossible supprimer dernier (effet de parcours incorrect sur la structure)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) impossible supprimer dernier (effet de parcours incorrect sur la structure). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec free deux fois ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "segmentation fault (accès mémoire invalide)",
      "OK (comportement acceptable)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) segmentation fault (accès mémoire invalide). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi oublier de gérer liste vide est dangereux ?",
    "choices": [
      "rien (aucune action spécifique)",
      "crash (arrêt brutal du programme)",
      "lent (coût en performance)",
      "compile pas (échec de compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) crash (arrêt brutal du programme). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec printf en exam ?",
    "choices": [
      "lent (coût en performance)",
      "interdit (non autorisé par l'énoncé)",
      "mauvais output (sortie non conforme)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel piège avec malloc(1000) “au hasard” ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "imprécis (choix non dimensionné précisément)",
      "tests limites ratés (conséquence sur compilation/tests)",
      "tout (combinaison totale des effets mentionnés)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) tout (combinaison totale des effets mentionnés). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel est le piège numéro un à l’exam ?",
    "choices": [
      "coder lentement (impact sur la performance)",
      "ne pas lire l’énoncé (respect des contraintes imposées)",
      "trop commenter (action de documentation plutôt que logique d'exécution)",
      "optimiser (recherche de performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) ne pas lire l’énoncé (respect des contraintes imposées). Cette réponse évite un piège de correction fréquent en exam C. Repère pratique: valide mentalement le cas vide, le cas limite et le format de sortie avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi écrit-on toujours malloc(len + 1) pour une string ?",
    "choices": [
      "performance (impact temps/exécution)",
      "'\\n' (retour ligne)",
      "'\\0' (caractère de fin de chaîne)",
      "sizeof (calcul de taille en octets)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) '\\0' (caractère de fin de chaîne). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi utiliser sizeof(type) * n ?",
    "choices": [
      "rapidité (impact sur la performance)",
      "lisibilité (amélioration de la lisibilité du code)",
      "octets corrects (taille mémoire exacte)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) octets corrects (taille mémoire exacte). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Quel est le premier réflexe après malloc ?",
    "choices": [
      "écrire dedans (action de gestion mémoire dans un moment précis)",
      "free (libération explicite de la mémoire allouée)",
      "vérifier NULL (pattern/instruction C)",
      "memset (action de gestion mémoire dans un moment précis)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) vérifier NULL (pattern/instruction C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Quand faut-il free un maillon supprimé ?",
    "choices": [
      "avant unlink (avant mise à jour des liens)",
      "après unlink (hypothèse d'implémentation plausible)",
      "jamais (cas interdit en pratique)",
      "à la fin du programme (action de gestion mémoire dans un moment précis)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) après unlink (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi allouer len + sign + 1 dans itoa ?",
    "choices": [
      "padding (espace supplémentaire de sécurité)",
      "'\\0' + '-' (pattern/instruction C)",
      "norme (respect des règles/prototypes imposés)",
      "vitesse (priorité à la rapidité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) '\\0' + '-' (pattern/instruction C). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que doit contenir la dernière case d’un tableau de strings ?",
    "choices": [
      "'\\0' (caractère de fin de chaîne)",
      "EOF (fin de flux/entrée)",
      "NULL (pointeur nul sentinelle)",
      "0xFF (constante hexadécimale)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL (pointeur nul sentinelle). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi travailler sur une copie lors d’un comptage ?",
    "choices": [
      "performance (impact temps/exécution)",
      "ne pas modifier l’original (mécanisme de contrôle du flux ou des pointeurs)",
      "malloc (allocation dynamique mémoire)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) ne pas modifier l’original (mécanisme de contrôle du flux ou des pointeurs). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que fait if (!ptr) return NULL ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "protection (mesure défensive de robustesse)",
      "free (libération explicite de la mémoire allouée)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) protection (mesure défensive de robustesse). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas free avant reconnecter une liste ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)",
      "corruption (structure mémoire incohérente)",
      "double free (libération multiple du même bloc)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) corruption (structure mémoire incohérente). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas oublier free après unlink ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "fuite mémoire (risque technique réel à l'exécution)",
      "compile (passe la compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) fuite mémoire (risque technique réel à l'exécution). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi caster en long dans itoa ?",
    "choices": [
      "vitesse (priorité à la rapidité)",
      "éviter overflow (risque technique réel à l'exécution)",
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter overflow (risque technique réel à l'exécution). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que risque malloc(sizeof(ptr) * n) ?",
    "choices": [
      "trop petit (taille mémoire insuffisante)",
      "trop grand (allocation excessive)",
      "correct (comportement attendu)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) trop petit (taille mémoire insuffisante). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi initialiser len à 0 ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "éviter valeur indéfinie (résultat non garanti par le langage C)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter valeur indéfinie (résultat non garanti par le langage C). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi remettre seen[256] à zéro ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "performance (impact temps/exécution)",
      "éviter pollution (mesure défensive de robustesse)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) éviter pollution (mesure défensive de robustesse). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que doit-on faire après free(ptr) ?",
    "choices": [
      "rien (aucune action spécifique)",
      "ptr++ (incrément de pointeur)",
      "ptr = NULL (réinitialisation après free)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ptr = NULL (réinitialisation après free). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi utiliser unsigned char pour indexer ?",
    "choices": [
      "vitesse (priorité à la rapidité)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) sécurité (mécanisme de contrôle du flux ou des pointeurs). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas écrire malloc(1000) “au hasard” ?",
    "choices": [
      "lent (coût en performance)",
      "imprécis (choix non dimensionné précisément)",
      "tests ratés (conséquence sur compilation/tests)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Quand doit-on free un tableau retourné par split ?",
    "choices": [
      "dans split (action de gestion mémoire dans un moment précis)",
      "jamais (cas interdit en pratique)",
      "appelant (fonction qui reçoit la valeur)",
      "OS (gestion système hors code utilisateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) appelant (fonction qui reçoit la valeur). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi vérifier argc ?",
    "choices": [
      "norme (respect des règles/prototypes imposés)",
      "sécurité mémoire (mécanisme de contrôle du flux ou des pointeurs)",
      "tests (validation automatique)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) sécurité mémoire (mécanisme de contrôle du flux ou des pointeurs). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que provoque une variable non initialisée ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "valeur indéfinie (résultat non garanti par le langage C)",
      "fuite (mémoire allouée non libérée)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) valeur indéfinie (résultat non garanti par le langage C). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi mettre '\\0' à la fin d’une string ?",
    "choices": [
      "affichage (sortie texte attendue)",
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "A et C (combinaison de propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) A et C (combinaison de propositions). En C, une chaîne correcte se termine par `\\0`; sans ce marqueur, la lecture peut dépasser la zone mémoire prévue. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi malloc retourne void * ?",
    "choices": [
      "casting auto (piste alternative proposée dans ce type de QCM)",
      "générique (comportement conçu pour plusieurs types/cas)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) générique (comportement conçu pour plusieurs types/cas). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi vérifier malloc même en exam ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "éviter crash (risque technique réel à l'exécution)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) éviter crash (risque technique réel à l'exécution). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi on ne free pas argv ?",
    "choices": [
      "static (durée de vie statique)",
      "OS (gestion système hors code utilisateur)",
      "interdit (non autorisé par l'énoncé)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) static (durée de vie statique). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi malloc(sizeof(char) * n) reste recommandé ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "portabilité (choix compatible entre plateformes/architectures)",
      "norme (respect des règles/prototypes imposés)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) portabilité (choix compatible entre plateformes/architectures). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi éviter les pointeurs sauvages ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) segfault (accès mémoire invalide). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Que se passe-t-il si on oublie de free en boucle ?",
    "choices": [
      "crash immédiat (risque technique réel à l'exécution)",
      "fuite mémoire (risque technique réel à l'exécution)",
      "style (choix de forme et lisibilité)",
      "compile (passe la compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) fuite mémoire (risque technique réel à l'exécution). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas écrire free(NULL) ?",
    "choices": [
      "interdit (non autorisé par l'énoncé)",
      "crash (arrêt brutal du programme)",
      "inutile mais sûr (action redondante mais sûre selon la norme)",
      "lent (coût en performance)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) inutile mais sûr (action redondante mais sûre selon la norme). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi séparer allocation et remplissage ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "lisibilité (amélioration de la lisibilité du code)",
      "débogage (facilite l'analyse et la correction)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi un double pointeur implique vigilance mémoire ?",
    "choices": [
      "lent (coût en performance)",
      "risque de fuite (risque technique réel à l'exécution)",
      "modification structure (mécanisme de contrôle du flux ou des pointeurs)",
      "C et B (combinaison des options C et B)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) C et B (combinaison des options C et B). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi malloc(sizeof(int)) est insuffisant pour n ints ?",
    "choices": [
      "lent (coût en performance)",
      "manque de place (question de dimensionnement mémoire)",
      "style (choix de forme et lisibilité)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) manque de place (question de dimensionnement mémoire). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi une string doit être terminée avant retour ?",
    "choices": [
      "affichage (sortie texte attendue)",
      "norme (respect des règles/prototypes imposés)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi vérifier la taille inclusive dans range ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "off-by-one (erreur de borne de boucle)",
      "free (libération explicite de la mémoire allouée)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) off-by-one (erreur de borne de boucle). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi allouer un tableau de pointeurs avant les mots ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "pattern (schéma de code récurrent)",
      "mémoire structurée (organisation mémoire claire en plusieurs niveaux)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi free après unlink et pas avant ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "corruption (structure mémoire incohérente)",
      "segfault (accès mémoire invalide)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas réutiliser un pointeur free ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) segfault (accès mémoire invalide). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi toujours compter avant malloc ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "taille exacte (question de dimensionnement mémoire)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi allouer len + 2 pour \"-5\" ?",
    "choices": [
      "padding (espace supplémentaire de sécurité)",
      "'-'+ '\\0' (pattern/instruction C)",
      "norme (respect des règles/prototypes imposés)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) '-'+ '\\0' (pattern/instruction C). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi un tableau dynamique doit être NULL-terminé ?",
    "choices": [
      "affichage (sortie texte attendue)",
      "parcours (logique de parcours d'une structure)",
      "norme (respect des règles/prototypes imposés)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi éviter de modifier l’argument original ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "lisibilité (amélioration de la lisibilité du code)",
      "bug potentiel (source probable d'erreur cachée)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi initialiser les pointeurs ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "crash (arrêt brutal du programme)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi sizeof(char) est souvent omis ?",
    "choices": [
      "toujours 1 (règle de comportement spécifique du cas particulier)",
      "norme (respect des règles/prototypes imposés)",
      "style (choix de forme et lisibilité)",
      "inutile (règle de comportement spécifique du cas particulier)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) toujours 1 (règle de comportement spécifique du cas particulier). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi tester fin de liste avec NULL ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi malloc(len) pour une string est faux ?",
    "choices": [
      "trop petit (taille mémoire insuffisante)",
      "lent (coût en performance)",
      "style (choix de forme et lisibilité)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) trop petit (taille mémoire insuffisante). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi gérer le cas 0 séparément ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "boucle saute (règle de comportement spécifique du cas particulier)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) boucle saute (règle de comportement spécifique du cas particulier). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi libérer dans remove_if est obligatoire ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "tests (validation automatique)",
      "fuite (mémoire allouée non libérée)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) fuite (mémoire allouée non libérée). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi ne pas allouer un buffer fixe ?",
    "choices": [
      "lent (coût en performance)",
      "imprécis (choix non dimensionné précisément)",
      "dangereux (risque de bug mémoire)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi utiliser long dans itoa ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "overflow (dépassement de capacité)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) overflow (dépassement de capacité). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi remettre à zéro des compteurs ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "éviter faux calcul (prévention d'erreur de comptage)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). C'est un réflexe à automatiser pour sécuriser rapidement ton code. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi vérifier pointeur avant deref ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "crash (arrêt brutal du programme)",
      "norme (respect des règles/prototypes imposés)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: initialise, vérifie, puis libère proprement; ce triplet évite la plupart des bugs mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que contient une variable de type `int *p` ?",
    "choices": [
      "un entier (valeur scalaire stockée directement)",
      "une adresse (référence mémoire)",
      "un tableau (structure contiguë d'éléments)",
      "une taille (information de dimension)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) une adresse (référence mémoire). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait `*p` si `p` est un pointeur ?",
    "choices": [
      "donne l’adresse (retourne une adresse mémoire)",
      "modifie p (mécanisme de contrôle du flux ou des pointeurs)",
      "accède à la valeur pointée (déréférence un pointeur pour lire/écrire la donnée)",
      "alloue (réserve de la mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) accède à la valeur pointée (déréférence un pointeur pour lire/écrire la donnée). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi utiliser `t_list **` ?",
    "choices": [
      "parcourir plus vite (motivation supposée selon l'objectif annoncé)",
      "modifier la tête (mécanisme de contrôle du flux ou des pointeurs)",
      "éviter malloc (pattern/instruction C)",
      "trier (ordonner les éléments)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) modifier la tête (mécanisme de contrôle du flux ou des pointeurs). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle ligne fait avancer dans une liste ?",
    "choices": [
      "`cur++` (pattern/instruction C)",
      "`*cur = cur->next` (pattern/instruction C)",
      "`cur = cur->next` (pattern/instruction C)",
      "`cur.next` (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) `cur = cur->next` (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Après `free(ptr)`, que faut-il faire idéalement ?",
    "choices": [
      "ptr++ (incrément de pointeur)",
      "rien (aucune action spécifique)",
      "ptr = NULL (réinitialisation après free)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ptr = NULL (réinitialisation après free). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle erreur provoque `*p = NULL` quand p est un pointeur non initialisé ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) segfault (accès mémoire invalide). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle est la différence entre `char *s` et `char s[10]` ?",
    "choices": [
      "aucune (absence d'option valide)",
      "l’un est dynamique (différence de modèle mémoire entre les deux formes)",
      "tableau vs pointeur (différence de modèle mémoire entre les deux formes)",
      "vitesse (priorité à la rapidité)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tableau vs pointeur (différence de modèle mémoire entre les deux formes). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quand faut-il utiliser un pointeur temporaire `tmp` ?",
    "choices": [
      "pour free après unlink (pattern/instruction C)",
      "pour printf (motivation supposée selon l'objectif annoncé)",
      "pour trier (objectif d'ordonnancement)",
      "pour compter (motivation supposée selon l'objectif annoncé)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) pour free après unlink (pattern/instruction C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel opérateur permet d’accéder à un champ struct via pointeur ?",
    "choices": [
      ". (opérateur d'accès direct à un champ de structure)",
      "* (pattern/instruction C)",
      "-> (pattern/instruction C)",
      "& (opérateur qui récupère l'adresse d'une variable)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) -> (pattern/instruction C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait `&x` ?",
    "choices": [
      "copie (duplication de valeur)",
      "valeur (piste alternative proposée dans ce type de QCM)",
      "adresse (retourne une adresse mémoire)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) adresse (retourne une adresse mémoire). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel est le danger d’un pointeur non initialisé ?",
    "choices": [
      "lent (coût en performance)",
      "fuite (mémoire allouée non libérée)",
      "comportement indéfini (résultat non garanti par le langage C)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) comportement indéfini (résultat non garanti par le langage C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi ne pas avancer cur après suppression ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "on saute un élément (effet de parcours incorrect sur la structure)",
      "segfault (accès mémoire invalide)",
      "compile (passe la compilation)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) on saute un élément (effet de parcours incorrect sur la structure). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que signifie dereferencer ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "copier (dupliquer des données)",
      "accéder à la valeur pointée (déréférence un pointeur pour lire/écrire la donnée)",
      "libérer (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) accéder à la valeur pointée (déréférence un pointeur pour lire/écrire la donnée). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle ligne modifie la tête d’une liste ?",
    "choices": [
      "`begin = begin->next` (pattern/instruction C)",
      "`*begin = (*begin)->next`",
      "`begin++` (pattern/instruction C)",
      "`cur->next` (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) `*begin = (*begin)->next`. En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel est le rôle de `NULL` dans un pointeur ?",
    "choices": [
      "valeur magique (piste alternative proposée dans ce type de QCM)",
      "fin (condition d'arrêt)",
      "adresse invalide (retourne une adresse mémoire)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi ne pas utiliser un pointeur après free ?",
    "choices": [
      "lent (coût en performance)",
      "fuite (mémoire allouée non libérée)",
      "dangling pointer (pointeur libéré puis réutilisé)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) dangling pointer (interprétation possible selon le contexte technique). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait `p = &x` ?",
    "choices": [
      "copie x (copie de valeur plutôt que partage d'adresse)",
      "pointe sur x (piste alternative proposée dans ce type de QCM)",
      "alloue (réserve de la mémoire)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pointe sur x (interprétation possible selon le contexte technique). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait `*p = 42` ?",
    "choices": [
      "change l’adresse (retourne une adresse mémoire)",
      "modifie la valeur pointée (mécanisme de contrôle du flux ou des pointeurs)",
      "malloc (allocation dynamique mémoire)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) modifie la valeur pointée (mécanisme de contrôle du flux ou des pointeurs). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle est l’erreur dans `cur = *cur->next` ?",
    "choices": [
      "priorité opérateurs (piste alternative proposée dans ce type de QCM)",
      "fuite (mémoire allouée non libérée)",
      "free (libération explicite de la mémoire allouée)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) priorité opérateurs (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi préférer swap des data plutôt que des liens ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "plus simple (implémentation plus simple à écrire et maintenir)",
      "rapide (objectif performance)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) plus simple (implémentation plus simple à écrire et maintenir). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait `void *` ?",
    "choices": [
      "interdit (non autorisé par l'énoncé)",
      "pointeur générique (comportement conçu pour plusieurs types/cas)",
      "fuite (mémoire allouée non libérée)",
      "tableau (différence de modèle mémoire entre les deux formes)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pointeur générique (comportement conçu pour plusieurs types/cas). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quand faut-il vérifier un pointeur avant deref ?",
    "choices": [
      "jamais (cas interdit en pratique)",
      "toujours (règle absolue appliquée sans exception)",
      "en debug (facilite l'analyse et la correction)",
      "après free (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) toujours (règle absolue appliquée sans exception). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi argv est un char ** ?",
    "choices": [
      "tableau dynamique (différence de modèle mémoire entre les deux formes)",
      "liste (interprétation orientée structure de données)",
      "tableau de strings (différence de modèle mémoire entre les deux formes)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tableau de strings (différence de modèle mémoire entre les deux formes). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quelle ligne est fausse ?",
    "choices": [
      "`p = &x;` (pattern/instruction C)",
      "`*p = 3;` (pattern/instruction C)",
      "`p = malloc(4);` (pattern/instruction C)",
      "`*p = malloc(4);` (pattern/instruction C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) `*p = malloc(4);` (pattern/instruction C). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel est le danger principal d’un double pointeur ?",
    "choices": [
      "lent (coût en performance)",
      "fuite (mémoire allouée non libérée)",
      "modifier mauvaise adresse (mécanisme de contrôle du flux ou des pointeurs)",
      "compile (passe la compilation)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) modifier mauvaise adresse (mécanisme de contrôle du flux ou des pointeurs). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que retourne malloc en cas d’échec ?",
    "choices": [
      "0 (valeur nulle)",
      "-1 (valeur de signal courante)",
      "NULL (pointeur nul sentinelle)",
      "errno (concept lié à la compilation ou au système)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL (pointeur nul sentinelle). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi écrire malloc(sizeof(int) * n) ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "octets corrects (taille mémoire exacte)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) octets corrects (taille mémoire exacte). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi ajouter +1 pour une string ?",
    "choices": [
      "'\\n' (retour ligne)",
      "'\\0' (caractère de fin de chaîne)",
      "padding (espace supplémentaire de sécurité)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) '\\0' (caractère de fin de chaîne). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Qui doit free la mémoire retournée ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "OS (gestion système hors code utilisateur)",
      "appelant (fonction qui reçoit la valeur)",
      "compilateur (concept lié à la compilation ou au système)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) appelant (fonction qui reçoit la valeur). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que provoque malloc(1000) “au hasard” ?",
    "choices": [
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "imprécision (choix non dimensionné précisément)",
      "tests ratés (conséquence sur compilation/tests)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi vérifier le retour de malloc ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "éviter crash (risque technique réel à l'exécution)",
      "norme (respect des règles/prototypes imposés)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter crash (risque technique réel à l'exécution). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait free(NULL) ?",
    "choices": [
      "segfault (accès mémoire invalide)",
      "interdit (non autorisé par l'énoncé)",
      "rien (aucune action spécifique)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) rien (aucune action spécifique). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi malloc(sizeof(ptr) * n) est souvent faux ?",
    "choices": [
      "trop petit (taille mémoire insuffisante)",
      "trop grand (allocation excessive)",
      "lent (coût en performance)",
      "OK (comportement acceptable)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) trop petit (taille mémoire insuffisante). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi ne pas free avant unlink ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "corruption (structure mémoire incohérente)",
      "segfault (accès mémoire invalide)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) corruption (structure mémoire incohérente). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi allouer tableau de pointeurs avant mots ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "pattern (schéma de code récurrent)",
      "structure (interprétation orientée structure de données)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quand libérer dans remove_if ?",
    "choices": [
      "avant (hypothèse d'implémentation plausible)",
      "après unlink (hypothèse d'implémentation plausible)",
      "jamais (cas interdit en pratique)",
      "à la fin (position dans la structure de données)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) après unlink (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi malloc(len) pour string est faux ?",
    "choices": [
      "trop petit (taille mémoire insuffisante)",
      "lent (coût en performance)",
      "style (choix de forme et lisibilité)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) trop petit (taille mémoire insuffisante). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait realloc ?",
    "choices": [
      "free (libération explicite de la mémoire allouée)",
      "agrandit/réduit (piste alternative proposée dans ce type de QCM)",
      "copie (duplication de valeur)",
      "malloc+free (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) agrandit/réduit (interprétation possible selon le contexte technique). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi éviter fuite mémoire ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "crash (arrêt brutal du programme)",
      "consommation (piste alternative proposée dans ce type de QCM)",
      "C et B (combinaison des options C et B)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) C et B (combinaison des options C et B). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait sizeof(char) ?",
    "choices": [
      "dépend (piste alternative proposée dans ce type de QCM)",
      "1 (valeur minimale positive)",
      "4 (valeur numérique littérale)",
      "8 (valeur numérique littérale)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) 1 (valeur minimale positive). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi ne pas allouer buffer fixe ?",
    "choices": [
      "lent (coût en performance)",
      "imprécis (choix non dimensionné précisément)",
      "dangereux (risque de bug mémoire)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi vérifier taille inclusive ?",
    "choices": [
      "norme (respect des règles/prototypes imposés)",
      "off-by-one (erreur de borne de boucle)",
      "style (choix de forme et lisibilité)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) off-by-one (erreur de borne de boucle). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que devient un pointeur après free ?",
    "choices": [
      "valide (hypothèse d'implémentation plausible)",
      "dangling (pointeur libéré puis réutilisé)",
      "NULL (pointeur nul sentinelle)",
      "0 (valeur nulle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) dangling (interprétation possible selon le contexte technique). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi mettre ptr = NULL après free ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "éviter reuse (piste alternative proposée dans ce type de QCM)",
      "norme (respect des règles/prototypes imposés)",
      "debug (aide au diagnostic)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter reuse (interprétation possible selon le contexte technique). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi malloc pour tableau 2D ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "dynamique (hypothèse d'implémentation plausible)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) dynamique (interprétation possible selon le contexte technique). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait calloc ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "initialise à zéro (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)",
      "realloc (fonction/pattern standard en C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) initialise à zéro (interprétation possible selon le contexte technique). Ici, la priorité est la sécurité mémoire et la clarté des pointeurs. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi séparer allocation et remplissage ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "lisibilité (amélioration de la lisibilité du code)",
      "debug (aide au diagnostic)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi libérer tout en cas d’erreur intermédiaire ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "fuite (mémoire allouée non libérée)",
      "norme (respect des règles/prototypes imposés)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) fuite (mémoire allouée non libérée). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi malloc retourne void * ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "générique (comportement conçu pour plusieurs types/cas)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) générique (comportement conçu pour plusieurs types/cas). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel est le réflexe absolu avec malloc ?",
    "choices": [
      "écrire (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)",
      "vérifier NULL (pattern/instruction C)",
      "cast (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) vérifier NULL (pattern/instruction C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: note qui possède la mémoire (ownership) et à quel moment elle doit être libérée.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "À quoi sert le champ `next` dans un maillon ?",
    "choices": [
      "stocker la donnée (piste alternative proposée dans ce type de QCM)",
      "stocker la taille (piste alternative proposée dans ce type de QCM)",
      "pointer vers le suivant (interprétation orientée structure de données)",
      "allouer (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) pointer vers le suivant (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que signifie `t_list *cur` ?",
    "choices": [
      "un maillon (interprétation orientée structure de données)",
      "une adresse de maillon (retourne une adresse mémoire)",
      "un tableau (structure contiguë d'éléments)",
      "une taille (information de dimension)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) une adresse de maillon (retourne une adresse mémoire). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quand utilise-t-on `t_list **begin` ?",
    "choices": [
      "pour parcourir (piste alternative proposée dans ce type de QCM)",
      "pour modifier la tête (mécanisme de contrôle du flux ou des pointeurs)",
      "pour afficher (interprétation orientée format de sortie)",
      "pour trier (objectif d'ordonnancement)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pour modifier la tête (mécanisme de contrôle du flux ou des pointeurs). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Comment parcourt-on une liste ?",
    "choices": [
      "for(i<n) (pattern/instruction C)",
      "while(cur) cur = cur->next",
      "recursion obligatoire (fonction/pattern standard en C)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(cur) cur = cur->next. En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quelle ligne supprime le maillon suivant ?",
    "choices": [
      "free(cur->next) (pattern/instruction C)",
      "cur->next = cur->next->next (instruction/pattern C explicite)",
      "cur = cur->next (pattern/instruction C)",
      "begin = NULL (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) cur->next = cur->next->next (instruction/pattern C explicite). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi stocker `tmp = cur->next` avant unlink ?",
    "choices": [
      "compter (mesurer avant d'allouer/remplir)",
      "afficher (produire une sortie texte)",
      "free ensuite (pattern/instruction C)",
      "trier (ordonner les éléments)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) free ensuite (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que devient la liste après suppression de B ? ``` A -> B -> C ```",
    "choices": [
      "A -> NULL (pattern/instruction C)",
      "B -> C (pattern/instruction C)",
      "A -> C (pattern/instruction C)",
      "A -> B (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) A -> C (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi nettoyer la tête avec une boucle while ?",
    "choices": [
      "performance (impact temps/exécution)",
      "style (choix de forme et lisibilité)",
      "supprimer plusieurs têtes (gestion répétée des suppressions en tête de liste)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) supprimer plusieurs têtes (gestion répétée des suppressions en tête de liste). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Après nettoyage de tête, quel pointeur sert au parcours ?",
    "choices": [
      "t_list ** (pattern/instruction C)",
      "t_list * (pattern/instruction C)",
      "int * (pattern/instruction C)",
      "char ** (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) t_list * (pattern/instruction C). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que se passe-t-il si on avance `cur` juste après suppression ?",
    "choices": [
      "rien (aucune action spécifique)",
      "fuite (mémoire allouée non libérée)",
      "on saute un maillon (effet de parcours incorrect sur la structure)",
      "crash (arrêt brutal du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) on saute un maillon (effet de parcours incorrect sur la structure). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Comment tester fin de liste ?",
    "choices": [
      "cur->next == 0 (pattern/instruction C)",
      "cur == NULL (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) cur == NULL (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans remove_if, sur quel élément applique-t-on cmp ?",
    "choices": [
      "cur (mécanisme de contrôle du flux ou des pointeurs)",
      "cur->next (pattern/instruction C)",
      "begin (mécanisme de contrôle du flux ou des pointeurs)",
      "tmp (variable temporaire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) cur->next (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quand faut-il free un maillon supprimé ?",
    "choices": [
      "avant unlink (avant mise à jour des liens)",
      "après unlink (hypothèse d'implémentation plausible)",
      "jamais (cas interdit en pratique)",
      "à la fin (position dans la structure de données)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) après unlink (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le piège si on free avant reconnecter ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)",
      "corruption (structure mémoire incohérente)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) corruption (structure mémoire incohérente). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que contient `*begin` ?",
    "choices": [
      "une adresse (référence mémoire)",
      "la tête (effet de parcours incorrect sur la structure)",
      "un tableau (structure contiguë d'éléments)",
      "une taille (information de dimension)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) la tête (effet de parcours incorrect sur la structure). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quelle ligne fait changer la tête ?",
    "choices": [
      "begin = begin->next (pattern/instruction C)",
      "*begin = (*begin)->next (pattern/instruction C)",
      "cur = cur->next (pattern/instruction C)",
      "free(begin) (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) *begin = (*begin)->next (pattern/instruction C). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi utiliser bubble sort sur liste ?",
    "choices": [
      "optimal (hypothèse d'implémentation plausible)",
      "simple à implémenter (hypothèse d'implémentation plausible)",
      "rapide (objectif performance)",
      "récursif (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) simple à implémenter (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que swap-on dans sort_list exam ?",
    "choices": [
      "pointeurs (interprétation orientée structure de données)",
      "data (interprétation orientée structure de données)",
      "malloc (allocation dynamique mémoire)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) data (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quand le tri est-il terminé ?",
    "choices": [
      "cur == NULL (pattern/instruction C)",
      "cmp toujours vrai (mécanisme de contrôle du flux ou des pointeurs)",
      "swapped == 0 (pattern/instruction C)",
      "fin premier tour (position dans la structure de données)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) swapped == 0 (pattern/instruction C). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que représente une liste vide ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "pointeur NULL (pattern/instruction C)",
      "tableau vide (aucun élément utile)",
      "erreur (état d'échec)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pointeur NULL (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi vérifier begin_list avant deref ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "crash (arrêt brutal du programme)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) crash (arrêt brutal du programme). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le bug de while(cur->next) ?",
    "choices": [
      "saute tête (effet de parcours incorrect sur la structure)",
      "oublie dernier (dernier élément non traité)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) oublie dernier (dernier élément non traité). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Comment compter les éléments ?",
    "choices": [
      "strlen (calcul de longueur de chaîne)",
      "while(lst) count++ (pattern/instruction C)",
      "malloc (allocation dynamique mémoire)",
      "cmp (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(lst) count++ (pattern/instruction C). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi tmp est indispensable ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "éviter perdre adresse (retourne une adresse mémoire)",
      "free double (pattern/instruction C)",
      "trier (ordonner les éléments)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) éviter perdre adresse (retourne une adresse mémoire). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que se passe-t-il si tous les éléments sont supprimés ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "begin reste (mécanisme de contrôle du flux ou des pointeurs)",
      "begin devient NULL (liste entièrement vidée)",
      "crash (arrêt brutal du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) begin devient NULL (liste entièrement vidée). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi passer un double pointeur ?",
    "choices": [
      "vitesse (priorité à la rapidité)",
      "modifier structure (mécanisme de contrôle du flux ou des pointeurs)",
      "free (libération explicite de la mémoire allouée)",
      "trier (ordonner les éléments)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) modifier structure (mécanisme de contrôle du flux ou des pointeurs). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que fait cur = cur->next ?",
    "choices": [
      "supprime (piste alternative proposée dans ce type de QCM)",
      "avance (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)",
      "copie (duplication de valeur)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) avance (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi ne pas swap les liens facilement ?",
    "choices": [
      "lent (coût en performance)",
      "complexe (hypothèse d'implémentation plausible)",
      "interdit (non autorisé par l'énoncé)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) complexe (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le rôle du dernier maillon ?",
    "choices": [
      "stocker (piste alternative proposée dans ce type de QCM)",
      "next = NULL (pattern/instruction C)",
      "data = NULL (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) next = NULL (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que signifie next == NULL ?",
    "choices": [
      "erreur (état d'échec)",
      "tête (effet de parcours incorrect sur la structure)",
      "fin (condition d'arrêt)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) fin (condition d'arrêt). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que se passe-t-il si begin vaut NULL ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "liste vide (interprétation orientée structure de données)",
      "warning (avertissement du compilateur)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) liste vide (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi ne pas faire cur++ ?",
    "choices": [
      "interdit (non autorisé par l'énoncé)",
      "liste pas contiguë (interprétation orientée structure de données)",
      "segfault (accès mémoire invalide)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) liste pas contiguë (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel piège avec cur->next->next sans test ?",
    "choices": [
      "lent (coût en performance)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) segfault (accès mémoire invalide). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi utiliser tmp ?",
    "choices": [
      "performance (impact temps/exécution)",
      "style (choix de forme et lisibilité)",
      "libérer après (hypothèse d'implémentation plausible)",
      "trier (ordonner les éléments)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) libérer après (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que contient un maillon ?",
    "choices": [
      "next uniquement (interprétation orientée structure de données)",
      "data uniquement (interprétation orientée structure de données)",
      "data + next (interprétation orientée structure de données)",
      "taille (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) data + next (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel test protège l’accès suivant ?",
    "choices": [
      "if(cur) (pattern/instruction C)",
      "if(cur->next) (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)",
      "break (sortie anticipée de boucle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) if(cur->next) (pattern/instruction C). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi une boucle infinie peut arriver ?",
    "choices": [
      "free (libération explicite de la mémoire allouée)",
      "next jamais modifié (mécanisme de contrôle du flux ou des pointeurs)",
      "malloc (allocation dynamique mémoire)",
      "cmp (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) next jamais modifié (mécanisme de contrôle du flux ou des pointeurs). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi ne pas modifier data_ref ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "comparaison (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) comparaison (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que se passe-t-il si cmp est inversé ?",
    "choices": [
      "tri faux (piste alternative proposée dans ce type de QCM)",
      "crash (arrêt brutal du programme)",
      "fuite (mémoire allouée non libérée)",
      "compile (passe la compilation)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) tri faux (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi vérifier cur->next avant cmp ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "sécurité (mécanisme de contrôle du flux ou des pointeurs)",
      "norme (respect des règles/prototypes imposés)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) sécurité (mécanisme de contrôle du flux ou des pointeurs). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Comment supprimer le premier maillon ?",
    "choices": [
      "free(begin) (pattern/instruction C)",
      "*begin = (*begin)->next (pattern/instruction C)",
      "cur->next = cur->next->next (instruction/pattern C explicite)",
      "begin++ (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) *begin = (*begin)->next (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi on ne free pas begin directement ?",
    "choices": [
      "fuite (mémoire allouée non libérée)",
      "perdre accès (piste alternative proposée dans ce type de QCM)",
      "lent (coût en performance)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) perdre accès (interprétation possible selon le contexte technique). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Que fait lstsize ?",
    "choices": [
      "free (libération explicite de la mémoire allouée)",
      "compter (mesurer avant d'allouer/remplir)",
      "trier (ordonner les éléments)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) compter (mesurer avant d'allouer/remplir). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi next doit être NULL au dernier ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "arrêt parcours (logique de parcours d'une structure)",
      "norme (respect des règles/prototypes imposés)",
      "toutes (combinaison de toutes les propositions)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) toutes (combinaison de toutes les propositions). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le danger principal des listes ?",
    "choices": [
      "lenteur (impact sur la performance)",
      "erreurs pointeurs (interprétation orientée structure de données)",
      "malloc (allocation dynamique mémoire)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) erreurs pointeurs (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi ne pas utiliser récursion en exam ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "pile (piste alternative proposée dans ce type de QCM)",
      "interdit (non autorisé par l'énoncé)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) pile (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quand arrêter remove_if ?",
    "choices": [
      "cur == NULL (pattern/instruction C)",
      "cur->next == NULL (pattern/instruction C)",
      "begin == NULL (pattern/instruction C)",
      "swapped (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) cur->next == NULL (pattern/instruction C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi nettoyer la tête d’abord ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "absence de précédent (piste alternative proposée dans ce type de QCM)",
      "performance (impact temps/exécution)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) absence de précédent (interprétation possible selon le contexte technique). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le pattern universel ?",
    "choices": [
      "for (boucle à compteur)",
      "while(ptr) (parcours jusqu'à NULL)",
      "récursion (appel de fonction sur elle-même)",
      "goto (saut explicite dans le flot)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) while(ptr) (parcours jusqu'à NULL). La logique de liens doit rester cohérente à chaque étape pour éviter la corruption de liste. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel est le piège le plus courant en listes ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "oublier free (fuite mémoire potentielle)",
      "avancer au mauvais moment (piste alternative proposée dans ce type de QCM)",
      "style (choix de forme et lisibilité)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) avancer au mauvais moment (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: garde toujours un pointeur temporaire avant de couper un lien.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans itoa, quel est le cas limite principal ?",
    "choices": [
      "1 (valeur minimale positive)",
      "-5 (valeur numérique littérale)",
      "INT_MIN (cas extrême sur les bornes d'entier)",
      "42 (valeur littérale d'exemple)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) INT_MIN (interprétation possible selon le contexte technique). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire split avec une string vide ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "retourner NULL (échec/absence de résultat)",
      "retourner tableau avec NULL (instruction/pattern C explicite)",
      "afficher (produire une sortie texte)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) retourner tableau avec NULL (instruction/pattern C explicite). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit renvoyer ft_range(0,0) ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "tableau vide (aucun élément utile)",
      "{0} (pattern/instruction C)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) {0} (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans wdmatch, que faire si argv[1] est vide ?",
    "choices": [
      "afficher argv[2] (pattern/instruction C)",
      "afficher argv[1] (pattern/instruction C)",
      "juste '\\n' (retour ligne sans autre texte)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) afficher argv[1] (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut begin_list si la liste est vide ?",
    "choices": [
      "malloc (allocation dynamique mémoire)",
      "-1 (valeur de signal courante)",
      "NULL (pointeur nul sentinelle)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL (pointeur nul sentinelle). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans remove_if, si tous les éléments correspondent ?",
    "choices": [
      "liste inchangée (interprétation orientée structure de données)",
      "begin pointe dernier (mécanisme de contrôle du flux ou des pointeurs)",
      "begin devient NULL (liste entièrement vidée)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) begin devient NULL (liste entièrement vidée). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire atoi(\"\") ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "0 (valeur nulle)",
      "-1 (valeur de signal courante)",
      "undefined (comportement non défini)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) 0 (valeur nulle). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire split si la string ne contient que des séparateurs ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "tableau vide (aucun élément utile)",
      "tableau avec NULL (pattern/instruction C)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tableau avec NULL (pattern/instruction C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Quel est le cas limite d’une liste à un seul élément dans sort_list ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "tri inutile (règle de comportement spécifique du cas particulier)",
      "swap obligatoire (fonction/pattern standard en C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tri inutile (règle de comportement spécifique du cas particulier). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire wdmatch si un caractère manque ?",
    "choices": [
      "afficher argv[1] (pattern/instruction C)",
      "afficher argv[2] (pattern/instruction C)",
      "afficher '\\n' (retour ligne uniquement)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) afficher '\\n' (retour ligne uniquement). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans ft_range(start,end), si start > end ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "tableau décroissant (différence de modèle mémoire entre les deux formes)",
      "segfault (accès mémoire invalide)",
      "malloc(0) (pattern/instruction C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tableau décroissant (différence de modèle mémoire entre les deux formes). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut len dans itoa(0) ?",
    "choices": [
      "0 (valeur nulle)",
      "1 (valeur minimale positive)",
      "2 (valeur numérique littérale)",
      "-1 (valeur de signal courante)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) 1 (valeur minimale positive). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que se passe-t-il si begin_list == NULL dans foreach ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "rien (aucune action spécifique)",
      "segfault (accès mémoire invalide)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) rien (aucune action spécifique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire remove_if si aucune data ne correspond ?",
    "choices": [
      "vider (piste alternative proposée dans ce type de QCM)",
      "crash (arrêt brutal du programme)",
      "ne rien changer (comportement de non-action ou cas impossible)",
      "free tout (libérer l'ensemble des allocations)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ne rien changer (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit contenir le tableau retourné par split ?",
    "choices": [
      "'\\0' (caractère de fin de chaîne)",
      "EOF (fin de flux/entrée)",
      "NULL final (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL final (pattern/instruction C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut atoi(\"-0\") ?",
    "choices": [
      "0 (valeur nulle)",
      "-0 (valeur numérique littérale)",
      "-1 (valeur de signal courante)",
      "erreur (état d'échec)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) 0 (valeur nulle). Ce cas limite est crucial: c'est souvent là que les implémentations échouent malgré des cas nominaux corrects. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans union, que faire avec string vide ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "afficher rien (interprétation orientée format de sortie)",
      "afficher '\\n' (retour ligne uniquement)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) afficher rien (interprétation possible selon le contexte technique). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans itoa, si n = 0 ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "\"0\" (valeur littérale de chaîne en C)",
      "\"\" (valeur littérale de chaîne en C)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) \"0\" (interprétation possible selon le contexte technique). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut *begin si la liste devient vide ?",
    "choices": [
      "dernier (effet de parcours incorrect sur la structure)",
      "malloc (allocation dynamique mémoire)",
      "NULL (pointeur nul sentinelle)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL (pointeur nul sentinelle). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire ft_range(-3,0) ?",
    "choices": [
      "{0,-1,-2,-3} (pattern/instruction C)",
      "{-3,-2,-1,0} (pattern/instruction C)",
      "NULL (pointeur nul sentinelle)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) {-3,-2,-1,0} (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit afficher un programme si argc est incorrect ?",
    "choices": [
      "erreur (état d'échec)",
      "rien (aucune action spécifique)",
      "'\\n' (retour ligne)",
      "exit (fin immédiate du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) '\\n' (retour ligne). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire split si un seul mot sans séparateurs ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "tableau avec ce mot + NULL (marqueur ou valeur sentinelle)",
      "segfault (accès mémoire invalide)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tableau avec ce mot + NULL (marqueur ou valeur sentinelle). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans remove_if, si seule la tête correspond ?",
    "choices": [
      "supprimer tête (effet de parcours incorrect sur la structure)",
      "crash (arrêt brutal du programme)",
      "rien (aucune action spécifique)",
      "free tout (libérer l'ensemble des allocations)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) supprimer tête (effet de parcours incorrect sur la structure). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que se passe-t-il si une liste n’a qu’un élément et qu’on le supprime ?",
    "choices": [
      "begin reste (mécanisme de contrôle du flux ou des pointeurs)",
      "begin devient NULL (liste entièrement vidée)",
      "segfault (accès mémoire invalide)",
      "fuite (mémoire allouée non libérée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) begin devient NULL (liste entièrement vidée). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans sort_list, une liste vide ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "retourner NULL (échec/absence de résultat)",
      "free (libération explicite de la mémoire allouée)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) retourner NULL (échec/absence de résultat). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire atoi avec espaces au début ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "0 (valeur nulle)",
      "ignorer (ne pas traiter cet élément)",
      "erreur (état d'échec)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ignorer (ne pas traiter cet élément). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire split avec \"\\n\\t \" ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "tableau NULL (pattern/instruction C)",
      "crash (arrêt brutal du programme)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tableau NULL (pattern/instruction C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que se passe-t-il si wdmatch reçoit 3 arguments ?",
    "choices": [
      "afficher erreur (interprétation orientée format de sortie)",
      "ignorer (ne pas traiter cet élément)",
      "'\\n' (retour ligne)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) '\\n' (retour ligne). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut ft_range(5,5) ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "{5} (pattern/instruction C)",
      "{} (collection vide)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) {5} (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire remove_if si begin_list est NULL ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "rien (aucune action spécifique)",
      "free (libération explicite de la mémoire allouée)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) rien (aucune action spécifique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire split si str == NULL ? (si non précisé)",
    "choices": [
      "crash (arrêt brutal du programme)",
      "retourner NULL (échec/absence de résultat)",
      "comportement indéfini (résultat non garanti par le langage C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) comportement indéfini (résultat non garanti par le langage C). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire atoi avec \"+\" ?",
    "choices": [
      "0 (valeur nulle)",
      "erreur (état d'échec)",
      "segfault (accès mémoire invalide)",
      "undefined (comportement non défini)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) undefined (comportement non défini). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que se passe-t-il si seen n’est pas réinitialisé ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "doublons supprimés à tort (gestion incomplète des duplications)",
      "fuite (mémoire allouée non libérée)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) doublons supprimés à tort (gestion incomplète des duplications). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut ft_range(-1,-1) ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "{-1} (pattern/instruction C)",
      "{} (collection vide)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) {-1} (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire sort_list avec 1 élément ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "free (libération explicite de la mémoire allouée)",
      "retourner tel quel (hypothèse d'implémentation plausible)",
      "swap (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) retourner tel quel (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans itoa, que vaut \"-1\" ?",
    "choices": [
      "impossible (comportement de non-action ou cas impossible)",
      "\"-1\" (valeur littérale de chaîne en C)",
      "\"1-\" (valeur littérale de chaîne en C)",
      "\"-01\" (valeur littérale de chaîne en C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) \"-1\" (interprétation possible selon le contexte technique). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire union si aucun caractère commun ?",
    "choices": [
      "NULL (pointeur nul sentinelle)",
      "afficher rien (interprétation orientée format de sortie)",
      "afficher '\\n' (retour ligne uniquement)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) afficher rien (interprétation possible selon le contexte technique). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans split, que faire si dernier mot sans séparateur ?",
    "choices": [
      "ignorer (ne pas traiter cet élément)",
      "perdre mot (piste alternative proposée dans ce type de QCM)",
      "ajouter mot (piste alternative proposée dans ce type de QCM)",
      "crash (arrêt brutal du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ajouter mot (interprétation possible selon le contexte technique). Le pattern attendu repose sur le repérage des transitions séparateur/lettre pour découper proprement chaque mot. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans remove_if, si seul dernier correspond ?",
    "choices": [
      "ne rien faire (comportement de non-action ou cas impossible)",
      "crash (arrêt brutal du programme)",
      "supprimer dernier (effet de parcours incorrect sur la structure)",
      "free tout (libérer l'ensemble des allocations)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) supprimer dernier (effet de parcours incorrect sur la structure). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire foreach sur liste vide ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "free (libération explicite de la mémoire allouée)",
      "rien (aucune action spécifique)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) rien (aucune action spécifique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut atoi(\"-2147483648\") ?",
    "choices": [
      "overflow (dépassement de capacité)",
      "crash (arrêt brutal du programme)",
      "dépend implémentation (piste alternative proposée dans ce type de QCM)",
      "undefined (comportement non défini)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) dépend implémentation (interprétation possible selon le contexte technique). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire wdmatch si argv[1] == \"\" ?",
    "choices": [
      "afficher rien (interprétation orientée format de sortie)",
      "afficher \"\\n\" (pattern/instruction C)",
      "afficher argv[2] (pattern/instruction C)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) afficher rien (interprétation possible selon le contexte technique). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut ft_range(0,-3) ?",
    "choices": [
      "{0,-1,-2,-3} (pattern/instruction C)",
      "{-3,-2,-1,0} (pattern/instruction C)",
      "NULL (pointeur nul sentinelle)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 0,
    "explanation": "Bonne réponse: A) {0,-1,-2,-3} (pattern/instruction C). La bonne réponse garantit des bornes cohérentes dans les deux sens, sans off-by-one. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans split, si malloc échoue à mi-chemin ?",
    "choices": [
      "continuer (poursuivre le flux)",
      "fuite (mémoire allouée non libérée)",
      "free ce qui a été alloué (fonction/pattern standard en C)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) free ce qui a été alloué (fonction/pattern standard en C). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire itoa avec n = 10 ?",
    "choices": [
      "\"01\" (valeur littérale de chaîne en C)",
      "\"10\" (valeur littérale de chaîne en C)",
      "\"010\" (valeur littérale de chaîne en C)",
      "\"-10\" (valeur littérale de chaîne en C)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) \"10\" (interprétation possible selon le contexte technique). Ce point protège les conversions d'entiers aux bornes extrêmes et évite les dépassements de capacité. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Dans remove_if, que faire si begin_list == NULL ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "free (libération explicite de la mémoire allouée)",
      "return (piste alternative proposée dans ce type de QCM)",
      "malloc (allocation dynamique mémoire)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) return (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire sort_list si tous les éléments sont égaux ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "trier (ordonner les éléments)",
      "laisser tel quel (hypothèse d'implémentation plausible)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que vaut atoi(\" 42\") ?",
    "choices": [
      "0 (valeur nulle)",
      "segfault (accès mémoire invalide)",
      "42 (valeur littérale d'exemple)",
      "erreur (état d'échec)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) 42 (valeur littérale d'exemple). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Que faire si string contient seulement '\\0' ?",
    "choices": [
      "crash (arrêt brutal du programme)",
      "un mot (piste alternative proposée dans ce type de QCM)",
      "zéro mot (piste alternative proposée dans ce type de QCM)",
      "segfault (accès mémoire invalide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) zéro mot (interprétation possible selon le contexte technique). En C, une chaîne correcte se termine par `\\0`; sans ce marqueur, la lecture peut dépasser la zone mémoire prévue. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pourquoi tester les conditions limites en premier ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "gagner du temps (piste alternative proposée dans ce type de QCM)",
      "éviter crash (risque technique réel à l'exécution)",
      "C et B (combinaison des options C et B)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) C et B (combinaison des options C et B). Le but est de couvrir explicitement les bords pour éviter les comportements incohérents. Repère pratique: teste d'abord les extrêmes (vide, 0, borne min/max).",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si argc est incorrect, que faut-il afficher dans beaucoup d’exos ?",
    "choices": [
      "message d’erreur (texte explicatif ajouté)",
      "rien (aucune action spécifique)",
      "juste `\\n` (pattern/instruction C)",
      "exit(1) (sortie immédiate avec code erreur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) juste `\\n` (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que se passe-t-il si le nom du fichier est faux ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "OK (comportement acceptable)",
      "compilation refusée (concept lié à la compilation ou au système)",
      "runtime error (erreur à l'exécution)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) compilation refusée (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si write est la seule fonction autorisée, utiliser printf est :",
    "choices": [
      "toléré (piste alternative proposée dans ce type de QCM)",
      "lent (coût en performance)",
      "interdit (non autorisé par l'énoncé)",
      "optionnel (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) interdit (non autorisé par l'énoncé). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi la sortie doit être *exactement* conforme ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "optimisation (objectif performance)",
      "tests stricts (comparaison exacte de sortie)",
      "lisibilité (amélioration de la lisibilité du code)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests stricts (comparaison exacte de sortie). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé dit “display a \\n”, cela signifie :",
    "choices": [
      "afficher espace (interprétation orientée format de sortie)",
      "afficher rien (interprétation orientée format de sortie)",
      "afficher un retour ligne (interprétation orientée format de sortie)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) afficher un retour ligne (interprétation possible selon le contexte technique). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que signifie “Expected files : wdmatch.c” ?",
    "choices": [
      "un fichier optionnel (piste alternative proposée dans ce type de QCM)",
      "plusieurs fichiers (piste alternative proposée dans ce type de QCM)",
      "un seul fichier nommé ainsi (piste alternative proposée dans ce type de QCM)",
      "n’importe quel nom (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) un seul fichier nommé ainsi (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que faire si un include n’est pas autorisé ?",
    "choices": [
      "l’utiliser quand même (contournement risqué des contraintes du sujet)",
      "commenter (action de documentation plutôt que logique d'exécution)",
      "ne pas l’utiliser (piste alternative proposée dans ce type de QCM)",
      "remplacer printf (interprétation orientée format de sortie)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) ne pas l’utiliser (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si le prototype ne correspond pas exactement ?",
    "choices": [
      "warning (avertissement du compilateur)",
      "runtime (phase d'exécution)",
      "compile pas (échec de compilation)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) compile pas (échec de compilation). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé dit “Do not turn in list.h”, cela veut dire :",
    "choices": [
      "ne pas l’inclure (piste alternative proposée dans ce type de QCM)",
      "l’écrire mais pas rendre (piste alternative proposée dans ce type de QCM)",
      "l’ignorer (piste alternative proposée dans ce type de QCM)",
      "l’éditer (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) l’écrire mais pas rendre (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si l’énoncé impose une structure, peut-on la modifier ?",
    "choices": [
      "oui (affirmatif dans ce contexte)",
      "oui si mieux (réponse de principe selon le contexte)",
      "non (négatif dans ce contexte)",
      "parfois (dépend du contexte)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) non (négatif dans ce contexte). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si rien n’est précisé sur malloc qui échoue, que faire ?",
    "choices": [
      "ignorer (ne pas traiter cet élément)",
      "crash (arrêt brutal du programme)",
      "protéger (piste alternative proposée dans ce type de QCM)",
      "printf (affichage formaté standard)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) protéger (interprétation possible selon le contexte technique). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que faut-il faire quand une fonction est interdite ?",
    "choices": [
      "la cacher (piste alternative proposée dans ce type de QCM)",
      "la remplacer (piste alternative proposée dans ce type de QCM)",
      "l’utiliser quand même (contournement risqué des contraintes du sujet)",
      "macro (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) la remplacer (interprétation possible selon le contexte technique). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé ne parle pas d’affichage d’erreur, on affiche :",
    "choices": [
      "un message (piste alternative proposée dans ce type de QCM)",
      "stderr (conséquence sur compilation/tests)",
      "rien ou juste \\n (pattern/instruction C)",
      "exit (fin immédiate du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) rien ou juste \\n (pattern/instruction C). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si “Inputs will always be consistent”, cela signifie :",
    "choices": [
      "pas de malloc (pattern/instruction C)",
      "pas besoin de vérifier pointeurs",
      "pas d’entrées invalides (hypothèse d'implémentation plausible)",
      "pas de NULL (pattern/instruction C)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) pas d’entrées invalides (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que signifie “Duplications must remain” ?",
    "choices": [
      "supprimer doublons (gestion incomplète des duplications)",
      "conserver doublons (gestion incomplète des duplications)",
      "trier unique (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) conserver doublons (gestion incomplète des duplications). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si une fonction autorisée n’est pas listée ?",
    "choices": [
      "OK (comportement acceptable)",
      "autorisée (piste alternative proposée dans ce type de QCM)",
      "interdite (piste alternative proposée dans ce type de QCM)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) interdite (interprétation possible selon le contexte technique). En liste chaînée, l'ordre des opérations sur les pointeurs est prioritaire: reconnecter avant de libérer évite les pertes de maillons. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que faire si argc est différent de ce qui est demandé ?",
    "choices": [
      "continuer (poursuivre le flux)",
      "segfault (accès mémoire invalide)",
      "afficher \\n (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) afficher \\n (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand un tableau de strings est attendu, il doit finir par :",
    "choices": [
      "'\\0' (caractère de fin de chaîne)",
      "EOF (fin de flux/entrée)",
      "NULL (pointeur nul sentinelle)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) NULL (pointeur nul sentinelle). Le point clé est la condition d'arrêt du tri et la stabilité du mécanisme d'échange. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi ne pas afficher d’espaces en trop ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "tests échouent (conséquence sur compilation/tests)",
      "lent (coût en performance)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tests échouent (conséquence sur compilation/tests). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé donne un exemple avec `| cat -e`, ça sert à :",
    "choices": [
      "debug (aide au diagnostic)",
      "montrer caractères invisibles (piste alternative proposée dans ce type de QCM)",
      "compiler (conséquence sur compilation/tests)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) montrer caractères invisibles (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si on imprime plus que demandé :",
    "choices": [
      "OK (comportement acceptable)",
      "warning (avertissement du compilateur)",
      "tests KO (sortie non conforme)",
      "bonus (piste alternative proposée dans ce type de QCM)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests KO (sortie non conforme). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand une fonction doit retourner un pointeur, on retourne :",
    "choices": [
      "copie (duplication de valeur)",
      "adresse valide (retourne une adresse mémoire)",
      "variable locale (piste alternative proposée dans ce type de QCM)",
      "NULL (pointeur nul sentinelle)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) adresse valide (retourne une adresse mémoire). Il faut distinguer clairement l'adresse mémoire et la valeur pointée avant toute modification. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que faire avec une variable locale renvoyée par adresse ?",
    "choices": [
      "OK (comportement acceptable)",
      "warning (avertissement du compilateur)",
      "interdit (non autorisé par l'énoncé)",
      "segfault futur (risque technique réel à l'exécution)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) segfault futur (risque technique réel à l'exécution). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé précise un type exact, on peut le changer ?",
    "choices": [
      "oui (affirmatif dans ce contexte)",
      "oui si logique (réponse de principe selon le contexte)",
      "non (négatif dans ce contexte)",
      "parfois (dépend du contexte)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) non (négatif dans ce contexte). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si l’énoncé n’autorise que malloc, utiliser calloc est :",
    "choices": [
      "OK (comportement acceptable)",
      "mieux (amélioration supposée)",
      "interdit (non autorisé par l'énoncé)",
      "warning (avertissement du compilateur)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) interdit (non autorisé par l'énoncé). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que signifie “You must include list.h but must not turn it in” ?",
    "choices": [
      "ignorer (ne pas traiter cet élément)",
      "copier (dupliquer des données)",
      "compiler avec, pas rendre (conséquence sur compilation/tests)",
      "modifier (mécanisme de contrôle du flux ou des pointeurs)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) compiler avec, pas rendre (conséquence sur compilation/tests). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi ne pas ajouter de debug prints ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "tests stricts (comparaison exacte de sortie)",
      "lent (coût en performance)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tests stricts (comparaison exacte de sortie). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé demande “returns pointer to first element” ?",
    "choices": [
      "dernier (effet de parcours incorrect sur la structure)",
      "milieu (piste alternative proposée dans ce type de QCM)",
      "tête (effet de parcours incorrect sur la structure)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tête (effet de parcours incorrect sur la structure). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand argc est bon mais argv vide ?",
    "choices": [
      "undefined (comportement non défini)",
      "traiter normalement (piste alternative proposée dans ce type de QCM)",
      "segfault (accès mémoire invalide)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) traiter normalement (interprétation possible selon le contexte technique). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que signifie “Allowed functions: write” ?",
    "choices": [
      "write + printf (interprétation orientée format de sortie)",
      "toutes (combinaison de toutes les propositions)",
      "uniquement write (interprétation orientée format de sortie)",
      "aucune (absence d'option valide)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) uniquement write (interprétation possible selon le contexte technique). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé ne mentionne pas free, doit-on libérer ?",
    "choices": [
      "jamais (cas interdit en pratique)",
      "parfois (dépend du contexte)",
      "oui si nécessaire (réponse de principe selon le contexte)",
      "interdit (non autorisé par l'énoncé)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) oui si nécessaire (réponse de principe selon le contexte). La séquence de libération doit être rigoureuse pour éviter les fuites, doubles free et pointeurs pendants. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi ne pas changer l’ordre d’affichage ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "lisibilité (amélioration de la lisibilité du code)",
      "tests (validation automatique)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests (validation automatique). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand une fonction doit afficher et retourner, on :",
    "choices": [
      "affiche seulement (piste alternative proposée dans ce type de QCM)",
      "retourne seulement (piste alternative proposée dans ce type de QCM)",
      "fait les deux (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) fait les deux (interprétation possible selon le contexte technique). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé parle d’arguments, cela inclut :",
    "choices": [
      "argv[0] (pattern/instruction C)",
      "programme (piste alternative proposée dans ce type de QCM)",
      "argv[1..] (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) argv[1..] (pattern/instruction C). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si rien n’est dit sur les erreurs internes ?",
    "choices": [
      "afficher (produire une sortie texte)",
      "ignorer (ne pas traiter cet élément)",
      "rester silencieux (piste alternative proposée dans ce type de QCM)",
      "exit (fin immédiate du programme)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) rester silencieux (interprétation possible selon le contexte technique). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi ne pas utiliser des macros interdites ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "norme (respect des règles/prototypes imposés)",
      "règles exam (respect des contraintes imposées)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) règles exam (respect des contraintes imposées). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand on dit “returns NULL-terminated array” :",
    "choices": [
      "'\\0' final (pattern/instruction C)",
      "EOF (fin de flux/entrée)",
      "pointeur NULL (pattern/instruction C)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) pointeur NULL (pattern/instruction C). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si le sujet dit “do not print anything else”, on :",
    "choices": [
      "ajoute debug (facilite l'analyse et la correction)",
      "affiche erreurs (piste alternative proposée dans ce type de QCM)",
      "respecte strictement (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) respecte strictement (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé dit “Inputs will always be consistent”, peut-on ignorer argc ?",
    "choices": [
      "oui (affirmatif dans ce contexte)",
      "parfois (dépend du contexte)",
      "non (négatif dans ce contexte)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) non (négatif dans ce contexte). Les sujets d'exam attendent une gestion stricte des arguments et une sortie exactement conforme. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi lire l’énoncé deux fois ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "comprendre pièges (piste alternative proposée dans ce type de QCM)",
      "lent (coût en performance)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) comprendre pièges (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si l’énoncé demande un retour ligne final, l’oublier provoque :",
    "choices": [
      "warning (avertissement du compilateur)",
      "OK (comportement acceptable)",
      "test KO (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) test KO (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand une fonction est interdite, peut-on l’implémenter soi-même ?",
    "choices": [
      "non (négatif dans ce contexte)",
      "oui (affirmatif dans ce contexte)",
      "parfois (dépend du contexte)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) oui (affirmatif dans ce contexte). L'indexation sur 256 valeurs couvre tous les octets et évite les indices négatifs liés au `char` signé. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé donne un exemple précis, il est :",
    "choices": [
      "indicatif (mécanisme de contrôle du flux ou des pointeurs)",
      "décoratif (mécanisme de contrôle du flux ou des pointeurs)",
      "contractuel (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) contractuel (interprétation possible selon le contexte technique). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Si on affiche dans stderr au lieu de stdout ?",
    "choices": [
      "OK (comportement acceptable)",
      "mieux (amélioration supposée)",
      "tests KO (sortie non conforme)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) tests KO (sortie non conforme). Les tests automatiques comparent la sortie au caractère près: format et sauts de ligne sont contractuels. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Que faire si une fonction autorisée est absente ?",
    "choices": [
      "inventer (comportement non spécifié)",
      "coder autrement (piste alternative proposée dans ce type de QCM)",
      "utiliser printf (sortie formatée)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) coder autrement (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand un comportement n’est pas précisé ?",
    "choices": [
      "inventer (comportement non spécifié)",
      "faire ce qu’on veut (piste alternative proposée dans ce type de QCM)",
      "rester minimal (piste alternative proposée dans ce type de QCM)",
      "free (libération explicite de la mémoire allouée)"
    ],
    "correct": 2,
    "explanation": "Bonne réponse: C) rester minimal (interprétation possible selon le contexte technique). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi ne pas ajouter de texte explicatif ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "tests stricts (comparaison exacte de sortie)",
      "lent (coût en performance)",
      "norme (respect des règles/prototypes imposés)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) tests stricts (comparaison exacte de sortie). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand l’énoncé dit “returns pointer”, renvoyer malloc est :",
    "choices": [
      "faux (piste alternative proposée dans ce type de QCM)",
      "correct (comportement attendu)",
      "interdit (non autorisé par l'énoncé)",
      "lent (coût en performance)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) correct (comportement attendu). Le bon raisonnement consiste à allouer la taille exacte puis à sécuriser le pointeur retourné avant de l'utiliser. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi respecter noms de fonctions ?",
    "choices": [
      "style (choix de forme et lisibilité)",
      "linker (concept lié à la compilation ou au système)",
      "compilation (phase de build)",
      "B et C (combinaison des options B et C)"
    ],
    "correct": 3,
    "explanation": "Bonne réponse: D) B et C (combinaison des options B et C). La réussite dépend du respect strict des fonctions autorisées et du format de sortie. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "La règle implicite numéro un à l’exam :",
    "choices": [
      "coder vite (piste alternative proposée dans ce type de QCM)",
      "relire l’énoncé (respect des contraintes imposées)",
      "optimiser (recherche de performance)",
      "commenter (action de documentation plutôt que logique d'exécution)"
    ],
    "correct": 1,
    "explanation": "Bonne réponse: B) relire l’énoncé (respect des contraintes imposées). La compétence évaluée est le respect exact du contrat de l'énoncé, pas une variante personnelle. Repère pratique: relis l'énoncé mot à mot pour vérifier les fonctions autorisées et la sortie exacte.",
    "tags": [
      "regles_implicites"
    ]
  }
]
