[
  {
    "id": "q0001",
    "theme": "patterns",
    "question": "ft_split : tu dois produire un tableau de mots. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Compter les mots, allouer `nb_mots + 1` pointeurs, copier chaque mot, puis poser le NULL final.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_split",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0002",
    "theme": "patterns",
    "question": "ft_split : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur ft_split, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_split",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0003",
    "theme": "patterns",
    "question": "ft_split : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer d’abord sur les séparateurs, puis sur les caractères du mot sans sauter d’index.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur ft_split, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_split",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0004",
    "theme": "patterns",
    "question": "ft_split : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_split",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0005",
    "theme": "patterns",
    "question": "ft_split : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Une entrée vide ou composée uniquement de séparateurs.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_split",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0006",
    "theme": "patterns",
    "question": "ft_range : tu dois produire un tableau d'int entre start et end. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Calculer la taille inclusive, allouer le tableau, remplir avec un step `+1` ou `-1`, puis retourner le pointeur.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur ft_range, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_range",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0007",
    "theme": "patterns",
    "question": "ft_range : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur ft_range, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_range",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0008",
    "theme": "patterns",
    "question": "ft_range : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Mettre à jour la valeur courante avec `value += step` à chaque itération.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur ft_range, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_range",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0009",
    "theme": "patterns",
    "question": "ft_range : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur ft_range, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_range",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0010",
    "theme": "patterns",
    "question": "ft_range : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Le cas `start == end`, qui doit retourner un tableau de taille 1.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur ft_range, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_range",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0011",
    "theme": "patterns",
    "question": "ft_list_remove_if : tu dois produire une liste nettoyée des maillons à supprimer. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Nettoyer les têtes correspondantes, parcourir avec `cur`, reconnecter, free, puis continuer le parcours.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur ft_list_remove_if, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0012",
    "theme": "patterns",
    "question": "ft_list_remove_if : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur ft_list_remove_if, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0013",
    "theme": "patterns",
    "question": "ft_list_remove_if : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Ne pas avancer `cur` juste après suppression de `cur->next`.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur ft_list_remove_if, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0014",
    "theme": "patterns",
    "question": "ft_list_remove_if : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur ft_list_remove_if, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0015",
    "theme": "patterns",
    "question": "ft_list_remove_if : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Plusieurs maillons en tête correspondent au critère de suppression.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur ft_list_remove_if, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "ft_list_remove_if",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0016",
    "theme": "patterns",
    "question": "sort_list : tu dois produire une liste triée en place. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Parcourir la liste, swap les data quand `cmp > 0`, marquer swapped, relancer tant qu’il y a eu échange.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur sort_list, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "sort_list",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0017",
    "theme": "patterns",
    "question": "sort_list : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur sort_list, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "sort_list",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0018",
    "theme": "patterns",
    "question": "sort_list : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer `cur = cur->next` pendant le passage, puis recommencer au début si swapped.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur sort_list, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "sort_list",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0019",
    "theme": "patterns",
    "question": "sort_list : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Arrêter quand un passage complet se fait sans swap.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur sort_list, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "sort_list",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0020",
    "theme": "patterns",
    "question": "sort_list : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Liste vide ou liste d'un seul élément.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur sort_list, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "sort_list",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0021",
    "theme": "patterns",
    "question": "itoa : tu dois produire la chaîne représentant l’entier. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Gérer signe et cas spéciaux, caster en long, compter les caractères, allouer, poser `\\0`, remplir à l’envers.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur itoa, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "itoa",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0022",
    "theme": "patterns",
    "question": "itoa : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur itoa, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "itoa",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0023",
    "theme": "patterns",
    "question": "itoa : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Décrémenter l’index de fin pendant le remplissage de la chaîne.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur itoa, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "itoa",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0024",
    "theme": "patterns",
    "question": "itoa : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur itoa, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "itoa",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0025",
    "theme": "patterns",
    "question": "itoa : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Les valeurs `0` et `INT_MIN`.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur itoa, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "itoa",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0026",
    "theme": "patterns",
    "question": "wdmatch : tu dois produire un affichage conditionnel de argv[1]. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Vérifier argc, parcourir argv[2], avancer index argv[1] sur match, valider quand argv[1] est entièrement consommé.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur wdmatch, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "wdmatch",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0027",
    "theme": "patterns",
    "question": "wdmatch : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur wdmatch, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "wdmatch",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0028",
    "theme": "patterns",
    "question": "wdmatch : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Avancer l’index de argv[1] uniquement quand un caractère match dans argv[2].",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur wdmatch, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "wdmatch",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0029",
    "theme": "patterns",
    "question": "wdmatch : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur wdmatch, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "wdmatch",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0030",
    "theme": "patterns",
    "question": "wdmatch : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Le cas où argv[1] est vide.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur wdmatch, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "wdmatch",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0031",
    "theme": "patterns",
    "question": "union : tu dois produire une sortie sans doublons provenant de deux chaînes. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Initialiser seen[256], parcourir la première chaîne puis la seconde, afficher un char inédit, marquer seen.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur union, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "union",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0032",
    "theme": "patterns",
    "question": "union : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur union, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "union",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0033",
    "theme": "patterns",
    "question": "union : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Parcourir chaque chaîne caractère par caractère jusqu’à `\\0`.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur union, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "union",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0034",
    "theme": "patterns",
    "question": "union : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Toujours terminer par un `\\n` unique.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur union, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "union",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0035",
    "theme": "patterns",
    "question": "union : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Les chaînes vides doivent être gérées sans accès hors borne.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur union, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "union",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0036",
    "theme": "patterns",
    "question": "atoi : tu dois produire la valeur entière convertie. Quelle séquence est la plus robuste sous pression d’exam ?",
    "choices": [
      "Allouer une taille fixe, coder vite, puis corriger après les tests.",
      "Ignorer espaces, lire le signe, accumuler les chiffres, arrêter au premier non-chiffre.",
      "Remplir la sortie avant de valider la taille nécessaire.",
      "Faire un free préventif avant toute vérification."
    ],
    "correct": 1,
    "explanation": "Sur atoi, les tests vérifient surtout l’ordre des étapes. Tu limites les oublis de garde, de taille et de terminaison.",
    "tags": [
      "patterns",
      "atoi",
      "sequence"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0037",
    "theme": "patterns",
    "question": "atoi : une étape intermédiaire échoue pendant l’implémentation. Quelle décision garde un état cohérent ?",
    "choices": [
      "Continuer la fonction avec les pointeurs déjà modifiés.",
      "Retourner une adresse locale pour garder une trace temporaire.",
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Relancer la même fonction récursivement sans condition d’arrêt."
    ],
    "correct": 2,
    "explanation": "Sur atoi, les tests vérifient surtout l’ordre des étapes. La stratégie d’échec doit être explicite et déterministe.",
    "tags": [
      "patterns",
      "atoi",
      "fail_path"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0038",
    "theme": "patterns",
    "question": "atoi : dans la boucle principale, quelle règle d’avancement évite les sauts de données et les boucles infinies ?",
    "choices": [
      "N’avancer l’index qu’une fois sur deux pour ralentir le parcours.",
      "Incrémenter un pointeur global sans lien avec la condition de boucle.",
      "Incrémenter l’index à chaque étape consommée.",
      "Réinitialiser le parcours à chaque itération."
    ],
    "correct": 2,
    "explanation": "Sur atoi, les tests vérifient surtout l’ordre des étapes. Le parcours devient prévisible et reproductible sur les tests cachés.",
    "tags": [
      "patterns",
      "atoi",
      "loop"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0039",
    "theme": "patterns",
    "question": "atoi : quelle action termine correctement la sortie avant le return ?",
    "choices": [
      "Retourner immédiatement sans marquer la fin de structure.",
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Ajouter un free global en fin de fonction même sur succès.",
      "Déléguer la terminaison à l’appelant sans contrat explicite."
    ],
    "correct": 1,
    "explanation": "Sur atoi, les tests vérifient surtout l’ordre des étapes. La terminaison correcte conditionne directement la validité de la sortie.",
    "tags": [
      "patterns",
      "atoi",
      "finalize"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0040",
    "theme": "patterns",
    "question": "atoi : quel cas doit être traité avant le flux nominal pour éviter un comportement faux dès l’exam ?",
    "choices": [
      "Ignorer les cas spéciaux et corriger après les premiers crashes.",
      "Chaîne vide, signe seul, ou `-0`.",
      "Désactiver les tests limites pendant le développement.",
      "Forcer une valeur arbitraire pour passer les cas simples."
    ],
    "correct": 1,
    "explanation": "Sur atoi, les tests vérifient surtout l’ordre des étapes. Le traitement anticipé du cas critique évite un échec systématique.",
    "tags": [
      "patterns",
      "atoi",
      "edge_case"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0041",
    "theme": "pieges",
    "question": "ft_split : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Ajouter la case de terminaison (`+1`) pour stocker le pointeur NULL final.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_split. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_split",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0042",
    "theme": "pieges",
    "question": "ft_split : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_split. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_split",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0043",
    "theme": "pieges",
    "question": "ft_split : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Conserver un index de mot stable pour ne pas perdre les allocations intermédiaires.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_split. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_split",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0044",
    "theme": "pieges",
    "question": "ft_split : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_split. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_split",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0045",
    "theme": "pieges",
    "question": "ft_split : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_split. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_split",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0046",
    "theme": "pieges",
    "question": "ft_range : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Calculer `abs(end - start) + 1` pour éviter le off-by-one.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_range. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_range",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0047",
    "theme": "pieges",
    "question": "ft_range : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_range. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_range",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0048",
    "theme": "pieges",
    "question": "ft_range : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Conserver un pointeur de base pour le return final.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_range. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_range",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0049",
    "theme": "pieges",
    "question": "ft_range : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_range. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_range",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0050",
    "theme": "pieges",
    "question": "ft_range : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_range. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_range",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0051",
    "theme": "pieges",
    "question": "ft_list_remove_if : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Faire `tmp = cur->next`, puis unlink, puis free(tmp), dans cet ordre strict.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_list_remove_if. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0052",
    "theme": "pieges",
    "question": "ft_list_remove_if : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_list_remove_if. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0053",
    "theme": "pieges",
    "question": "ft_list_remove_if : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser `t_list **begin_list` pour modifier la tête depuis la fonction.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_list_remove_if. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0054",
    "theme": "pieges",
    "question": "ft_list_remove_if : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_list_remove_if. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0055",
    "theme": "pieges",
    "question": "ft_list_remove_if : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur ft_list_remove_if. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "ft_list_remove_if",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0056",
    "theme": "pieges",
    "question": "sort_list : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Swapper les `data` plutôt que les liens si tu n’as pas une gestion complète des pointeurs.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur sort_list. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "sort_list",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0057",
    "theme": "pieges",
    "question": "sort_list : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Arrêter quand un passage complet se fait sans swap.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur sort_list. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "sort_list",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0058",
    "theme": "pieges",
    "question": "sort_list : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser une variable temporaire pour le swap de data.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur sort_list. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "sort_list",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0059",
    "theme": "pieges",
    "question": "sort_list : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur sort_list. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "sort_list",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0060",
    "theme": "pieges",
    "question": "sort_list : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur sort_list. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "sort_list",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0061",
    "theme": "pieges",
    "question": "itoa : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Caster en `long` avant de manipuler la valeur négative.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur itoa. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "itoa",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0062",
    "theme": "pieges",
    "question": "itoa : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur itoa. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "itoa",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0063",
    "theme": "pieges",
    "question": "itoa : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Remplir depuis la fin pour éviter un second renversement de chaîne.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur itoa. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "itoa",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0064",
    "theme": "pieges",
    "question": "itoa : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur itoa. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "itoa",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0065",
    "theme": "pieges",
    "question": "itoa : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur itoa. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "itoa",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0066",
    "theme": "pieges",
    "question": "wdmatch : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Conserver le sens de parcours: on scanne argv[2], pas l’inverse.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur wdmatch. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "wdmatch",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0067",
    "theme": "pieges",
    "question": "wdmatch : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur wdmatch. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "wdmatch",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0068",
    "theme": "pieges",
    "question": "wdmatch : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Utiliser deux index indépendants pour garder l’ordre des caractères.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur wdmatch. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "wdmatch",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0069",
    "theme": "pieges",
    "question": "wdmatch : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur wdmatch. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "wdmatch",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0070",
    "theme": "pieges",
    "question": "wdmatch : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur wdmatch. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "wdmatch",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0071",
    "theme": "pieges",
    "question": "union : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Indexer seen avec `(unsigned char)c` pour éviter les index négatifs.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur union. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "union",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0072",
    "theme": "pieges",
    "question": "union : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Toujours terminer par un `\\n` unique.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur union. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "union",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0073",
    "theme": "pieges",
    "question": "union : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Caster le caractère avant indexation dans seen.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur union. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "union",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0074",
    "theme": "pieges",
    "question": "union : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur union. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "union",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0075",
    "theme": "pieges",
    "question": "union : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur union. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "union",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0076",
    "theme": "pieges",
    "question": "atoi : le code compile, mais un test caché plante. Quel correctif cible le piège le plus probable ?",
    "choices": [
      "Ajouter des printf partout pour contourner le test.",
      "Vérifier l’incrément dans toutes les branches de boucle pour éviter la boucle infinie.",
      "Supprimer les vérifications pour accélérer l’exécution.",
      "Changer le prototype pour simplifier le code."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur atoi. Ce bug est fréquent à 42 car il n’apparaît pas sur les cas nominaux.",
    "tags": [
      "pieges",
      "atoi",
      "trap"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0077",
    "theme": "pieges",
    "question": "atoi : tu observes une sortie incohérente sur les cas limites. Quelle correction est prioritaire ?",
    "choices": [
      "Mettre un buffer fixe plus grand pour masquer le problème.",
      "Supprimer le test de retour d’erreur pour éviter les branches.",
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Remplacer toute la logique par une valeur constante."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur atoi. La sortie doit être terminée et structurée exactement comme attendu.",
    "tags": [
      "pieges",
      "atoi",
      "output_bug"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0078",
    "theme": "pieges",
    "question": "atoi : après une suppression ou une écriture mémoire, quel ordre d’opérations évite la corruption ?",
    "choices": [
      "Free en premier, puis tenter de reconnecter ensuite.",
      "Écrire la suite sans conserver de pointeur temporaire.",
      "Travailler avec un index de lecture stable pour ne pas perdre la position.",
      "Revenir au début de la fonction à chaque modification."
    ],
    "correct": 2,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur atoi. L’ordre des opérations est un piège récurrent en EX3/EX4.",
    "tags": [
      "pieges",
      "atoi",
      "order"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0079",
    "theme": "pieges",
    "question": "atoi : le test d’exam te renvoie “Wrong output”. Quelle décision est la plus sûre en priorité ?",
    "choices": [
      "Ajouter une phrase de debug pour expliquer ton intention.",
      "Conserver strictement la sortie contractuelle, sans texte en plus.",
      "Écrire sur stderr pour séparer les infos utiles.",
      "Garder un espace final pour la lisibilité."
    ],
    "correct": 1,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur atoi. Les correcteurs automatiques comparent la sortie au caractère près.",
    "tags": [
      "pieges",
      "atoi",
      "output_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0080",
    "theme": "pieges",
    "question": "atoi : tu hésites entre optimisation rapide et garde défensive. Quel choix évite le plus de faux positifs en correction ?",
    "choices": [
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Supprimer les conditions pour simplifier la lecture du code.",
      "Remplacer les cas limites par des valeurs codées en dur.",
      "Laisser le comportement indéfini et compter sur les tests visibles."
    ],
    "correct": 0,
    "explanation": "Ce choix évite un piège fréquent qui passe en local mais casse en correction automatique sur atoi. La garde défensive évite des crashs qui apparaissent seulement côté moulinette.",
    "tags": [
      "pieges",
      "atoi",
      "defensive"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0081",
    "theme": "reflexes_memoire",
    "question": "ft_split : ta fonction renvoie un tableau de mots. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant libère chaque mot puis le tableau retourné.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_split plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0082",
    "theme": "reflexes_memoire",
    "question": "ft_split : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend ft_split plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0083",
    "theme": "reflexes_memoire",
    "question": "ft_split : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_split plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0084",
    "theme": "reflexes_memoire",
    "question": "ft_split : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `(nb_mots + 1) * sizeof(char *)` pour le tableau de pointeurs.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_split plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0085",
    "theme": "reflexes_memoire",
    "question": "ft_split : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend ft_split plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_split",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0086",
    "theme": "reflexes_memoire",
    "question": "ft_range : ta fonction renvoie un tableau d'int entre start et end. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant libère le tableau d'int retourné.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_range plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0087",
    "theme": "reflexes_memoire",
    "question": "ft_range : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend ft_range plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0088",
    "theme": "reflexes_memoire",
    "question": "ft_range : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_range plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0089",
    "theme": "reflexes_memoire",
    "question": "ft_range : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `size * sizeof(int)` avec `size = abs(end - start) + 1`.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_range plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0090",
    "theme": "reflexes_memoire",
    "question": "ft_range : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend ft_range plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_range",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0091",
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : ta fonction renvoie une liste nettoyée des maillons à supprimer. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "La fonction free uniquement les maillons supprimés, pas les maillons conservés.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_list_remove_if plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0092",
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend ft_list_remove_if plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0093",
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_list_remove_if plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0094",
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation: la fonction modifie la liste en place.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend ft_list_remove_if plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0095",
    "theme": "reflexes_memoire",
    "question": "ft_list_remove_if : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend ft_list_remove_if plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "ft_list_remove_if",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0096",
    "theme": "reflexes_memoire",
    "question": "sort_list : ta fonction renvoie une liste triée en place. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucun free à faire dans le tri: on réordonne sans libérer.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend sort_list plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0097",
    "theme": "reflexes_memoire",
    "question": "sort_list : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend sort_list plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0098",
    "theme": "reflexes_memoire",
    "question": "sort_list : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend sort_list plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0099",
    "theme": "reflexes_memoire",
    "question": "sort_list : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation: tri in-place sur la liste existante.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend sort_list plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0100",
    "theme": "reflexes_memoire",
    "question": "sort_list : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend sort_list plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "sort_list",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0101",
    "theme": "reflexes_memoire",
    "question": "itoa : ta fonction renvoie la chaîne représentant l’entier. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "L’appelant est responsable du free de la chaîne retournée.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend itoa plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0102",
    "theme": "reflexes_memoire",
    "question": "itoa : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend itoa plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0103",
    "theme": "reflexes_memoire",
    "question": "itoa : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend itoa plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0104",
    "theme": "reflexes_memoire",
    "question": "itoa : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Allouer `(digits + sign + 1) * sizeof(char)`.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend itoa plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0105",
    "theme": "reflexes_memoire",
    "question": "itoa : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend itoa plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "itoa",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0106",
    "theme": "reflexes_memoire",
    "question": "wdmatch : ta fonction renvoie un affichage conditionnel de argv[1]. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans l’implémentation standard.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend wdmatch plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0107",
    "theme": "reflexes_memoire",
    "question": "wdmatch : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend wdmatch plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0108",
    "theme": "reflexes_memoire",
    "question": "wdmatch : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend wdmatch plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0109",
    "theme": "reflexes_memoire",
    "question": "wdmatch : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique n’est nécessaire pour la logique.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend wdmatch plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0110",
    "theme": "reflexes_memoire",
    "question": "wdmatch : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend wdmatch plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "wdmatch",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0111",
    "theme": "reflexes_memoire",
    "question": "union : ta fonction renvoie une sortie sans doublons provenant de deux chaînes. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans cette approche.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend union plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "union",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0112",
    "theme": "reflexes_memoire",
    "question": "union : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend union plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "union",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0113",
    "theme": "reflexes_memoire",
    "question": "union : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend union plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "union",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0114",
    "theme": "reflexes_memoire",
    "question": "union : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique: tableau seen local de 256 cases.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend union plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "union",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0115",
    "theme": "reflexes_memoire",
    "question": "union : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend union plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "union",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0116",
    "theme": "reflexes_memoire",
    "question": "atoi : ta fonction renvoie la valeur entière convertie. Qui doit libérer la mémoire dans le flux standard ?",
    "choices": [
      "Aucune mémoire dynamique à libérer pour atoi.",
      "Le compilateur libère automatiquement avant le retour.",
      "Le système libère immédiatement après chaque instruction.",
      "La fonction doit free avant de retourner le pointeur."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend atoi plus stable sans complexifier le code. Le contrat d’ownership doit être clair pour éviter fuite ou double free.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "ownership"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0117",
    "theme": "reflexes_memoire",
    "question": "atoi : juste après allocation ou préparation critique, quel réflexe mémoire doit être systématique ?",
    "choices": [
      "Écrire dans le buffer puis vérifier le pointeur ensuite.",
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Caster vers un type plus petit pour gagner du temps.",
      "Désactiver les vérifications en mode exam."
    ],
    "correct": 1,
    "explanation": "En exam, ce réflexe mémoire rend atoi plus stable sans complexifier le code. Ce réflexe empêche d’écrire dans une adresse invalide.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0118",
    "theme": "reflexes_memoire",
    "question": "atoi : une allocation intermédiaire échoue après plusieurs succès. Quelle sortie mémoire est correcte ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Retourner le premier pointeur alloué sans cleanup.",
      "Continuer avec un tableau partiellement initialisé.",
      "Free uniquement la dernière allocation ratée."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend atoi plus stable sans complexifier le code. Le cleanup complet évite les fuites invisibles pendant un run court.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "cleanup"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0119",
    "theme": "reflexes_memoire",
    "question": "atoi : tu dois dimensionner une allocation. Quelle formule est la plus fiable ?",
    "choices": [
      "Aucune allocation dynamique n’est requise.",
      "Allouer 1000 octets pour être tranquille.",
      "Allouer la taille du pointeur uniquement.",
      "Allouer puis corriger la taille après écriture."
    ],
    "correct": 0,
    "explanation": "En exam, ce réflexe mémoire rend atoi plus stable sans complexifier le code. La taille exacte est évaluée directement sur les cas limites.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0120",
    "theme": "reflexes_memoire",
    "question": "atoi : après free(ptr) dans une branche de correction, quelle décision évite la réutilisation accidentelle ?",
    "choices": [
      "Réutiliser `ptr` immédiatement pour gagner du temps.",
      "Laisser `ptr` inchangé et compter sur le contexte.",
      "Neutraliser le pointeur local avant de poursuivre le flux.",
      "Incrémenter `ptr` pour sortir de la zone libérée."
    ],
    "correct": 2,
    "explanation": "En exam, ce réflexe mémoire rend atoi plus stable sans complexifier le code. Neutraliser le pointeur réduit les erreurs de double accès en debug rapide.",
    "tags": [
      "reflexes_memoire",
      "atoi",
      "dangling"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0121",
    "theme": "pointeurs",
    "question": "ft_split : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Conserver un index de mot stable pour ne pas perdre les allocations intermédiaires.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_split. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_split",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0122",
    "theme": "pointeurs",
    "question": "ft_split : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_split. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_split",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0123",
    "theme": "pointeurs",
    "question": "ft_split : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_split. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_split",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0124",
    "theme": "pointeurs",
    "question": "ft_split : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer d’abord sur les séparateurs, puis sur les caractères du mot sans sauter d’index.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_split. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_split",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0125",
    "theme": "pointeurs",
    "question": "ft_split : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Écrire `tab[word_count] = NULL` après le dernier mot copié.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_split. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_split",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0126",
    "theme": "pointeurs",
    "question": "ft_range : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Conserver un pointeur de base pour le return final.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_range. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_range",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0127",
    "theme": "pointeurs",
    "question": "ft_range : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_range. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_range",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0128",
    "theme": "pointeurs",
    "question": "ft_range : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_range. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_range",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0129",
    "theme": "pointeurs",
    "question": "ft_range : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Mettre à jour la valeur courante avec `value += step` à chaque itération.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_range. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_range",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0130",
    "theme": "pointeurs",
    "question": "ft_range : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Retourner le pointeur du début du tableau, jamais un pointeur avancé.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_range. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_range",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0131",
    "theme": "pointeurs",
    "question": "ft_list_remove_if : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser `t_list **begin_list` pour modifier la tête depuis la fonction.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_list_remove_if. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0132",
    "theme": "pointeurs",
    "question": "ft_list_remove_if : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_list_remove_if. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0133",
    "theme": "pointeurs",
    "question": "ft_list_remove_if : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_list_remove_if. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0134",
    "theme": "pointeurs",
    "question": "ft_list_remove_if : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Ne pas avancer `cur` juste après suppression de `cur->next`.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_list_remove_if. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0135",
    "theme": "pointeurs",
    "question": "ft_list_remove_if : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête réelle.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de ft_list_remove_if. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "ft_list_remove_if",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0136",
    "theme": "pointeurs",
    "question": "sort_list : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser une variable temporaire pour le swap de data.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de sort_list. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "sort_list",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0137",
    "theme": "pointeurs",
    "question": "sort_list : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de sort_list. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "sort_list",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0138",
    "theme": "pointeurs",
    "question": "sort_list : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de sort_list. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "sort_list",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0139",
    "theme": "pointeurs",
    "question": "sort_list : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer `cur = cur->next` pendant le passage, puis recommencer au début si swapped.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de sort_list. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "sort_list",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0140",
    "theme": "pointeurs",
    "question": "sort_list : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Arrêter quand un passage complet se fait sans swap.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de sort_list. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "sort_list",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0141",
    "theme": "pointeurs",
    "question": "itoa : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Remplir depuis la fin pour éviter un second renversement de chaîne.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de itoa. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "itoa",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0142",
    "theme": "pointeurs",
    "question": "itoa : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de itoa. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "itoa",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0143",
    "theme": "pointeurs",
    "question": "itoa : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de itoa. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "itoa",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0144",
    "theme": "pointeurs",
    "question": "itoa : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Décrémenter l’index de fin pendant le remplissage de la chaîne.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de itoa. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "itoa",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0145",
    "theme": "pointeurs",
    "question": "itoa : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Placer `str[len] = \\0` avant de remplir les chiffres.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de itoa. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "itoa",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0146",
    "theme": "pointeurs",
    "question": "wdmatch : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Utiliser deux index indépendants pour garder l’ordre des caractères.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de wdmatch. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0147",
    "theme": "pointeurs",
    "question": "wdmatch : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de wdmatch. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0148",
    "theme": "pointeurs",
    "question": "wdmatch : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de wdmatch. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0149",
    "theme": "pointeurs",
    "question": "wdmatch : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Avancer l’index de argv[1] uniquement quand un caractère match dans argv[2].",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de wdmatch. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0150",
    "theme": "pointeurs",
    "question": "wdmatch : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Afficher argv[1] seulement si tous ses caractères ont été trouvés dans l’ordre.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de wdmatch. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "wdmatch",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0151",
    "theme": "pointeurs",
    "question": "union : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Caster le caractère avant indexation dans seen.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de union. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "union",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0152",
    "theme": "pointeurs",
    "question": "union : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de union. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "union",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0153",
    "theme": "pointeurs",
    "question": "union : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de union. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "union",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0154",
    "theme": "pointeurs",
    "question": "union : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Parcourir chaque chaîne caractère par caractère jusqu’à `\\0`.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de union. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "union",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0155",
    "theme": "pointeurs",
    "question": "union : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Toujours terminer par un `\\n` unique.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de union. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "union",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0156",
    "theme": "pointeurs",
    "question": "atoi : tu dois modifier une structure partagée (tête, buffer ou index global). Quelle forme de pointeur est correcte ?",
    "choices": [
      "Travailler avec un index de lecture stable pour ne pas perdre la position.",
      "Passer une copie locale et espérer qu’elle modifie l’original.",
      "Caster arbitrairement vers `void **` pour forcer la compilation.",
      "Utiliser un pointeur non initialisé puis corriger après."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de atoi. Le bon niveau d’indirection est déterminant pour modifier la bonne zone mémoire.",
    "tags": [
      "pointeurs",
      "atoi",
      "indirection"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0157",
    "theme": "pointeurs",
    "question": "atoi : avant de supprimer ou remplacer une cible mémoire, quel réflexe pointeur évite de perdre l’adresse utile ?",
    "choices": [
      "Écraser directement la cible puis chercher l’ancienne adresse.",
      "Stocker l’adresse dans un temporaire avant la modification.",
      "Faire `free` d’abord et lire `next` ensuite.",
      "Remonter au début de la fonction pour récupérer un pointeur propre."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de atoi. Le temporaire protège le chaînage et permet un free sûr.",
    "tags": [
      "pointeurs",
      "atoi",
      "tmp"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0158",
    "theme": "pointeurs",
    "question": "atoi : quelle décision doit précéder toute déréférence (`*ptr`/`->`) dans un chemin sensible ?",
    "choices": [
      "Supposer que le pointeur est valide parce que ça compile.",
      "Tester la validité du pointeur dans le contexte courant.",
      "Forcer la déréférence pour repérer rapidement le crash.",
      "Remplacer le pointeur par une constante arbitraire."
    ],
    "correct": 1,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de atoi. Ce contrôle évite un comportement indéfini sur les cas d’entrée vides.",
    "tags": [
      "pointeurs",
      "atoi",
      "deref_guard"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0159",
    "theme": "pointeurs",
    "question": "atoi : pendant une boucle de transformation, quelle règle d’avancement de pointeur est correcte ?",
    "choices": [
      "Incrémenter l’index à chaque étape consommée.",
      "Avancer deux fois à chaque itération pour finir plus vite.",
      "Ne jamais avancer et dépendre d’un break manuel.",
      "Réinitialiser le pointeur à chaque tour."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de atoi. La progression doit rester alignée avec la condition de boucle.",
    "tags": [
      "pointeurs",
      "atoi",
      "advance"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0160",
    "theme": "pointeurs",
    "question": "atoi : tu modifies une zone pointée puis tu dois retourner un résultat. Quel pointeur faut-il renvoyer ?",
    "choices": [
      "Arrêter la conversion dès qu’un caractère non numérique apparaît.",
      "Le pointeur temporaire le plus avancé dans la boucle.",
      "L’adresse d’une variable locale de la fonction.",
      "NULL même en succès pour forcer le contrôle côté appelant."
    ],
    "correct": 0,
    "explanation": "Ici, la gestion des pointeurs décide directement de la stabilité de atoi. Le return doit pointer vers une zone encore valide après la fin de la fonction.",
    "tags": [
      "pointeurs",
      "atoi",
      "return_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0161",
    "theme": "malloc",
    "question": "ft_split : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire un tableau de mots avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour ft_split, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0162",
    "theme": "malloc",
    "question": "ft_split : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `(nb_mots + 1) * sizeof(char *)` pour le tableau de pointeurs.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour ft_split, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0163",
    "theme": "malloc",
    "question": "ft_split : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour ft_split, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_split",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0164",
    "theme": "malloc",
    "question": "ft_split : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour ft_split, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_split",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0165",
    "theme": "malloc",
    "question": "ft_split : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant libère chaque mot puis le tableau retourné.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour ft_split, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_split",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0166",
    "theme": "malloc",
    "question": "ft_range : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire un tableau d'int entre start et end avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour ft_range, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0167",
    "theme": "malloc",
    "question": "ft_range : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `size * sizeof(int)` avec `size = abs(end - start) + 1`.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour ft_range, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0168",
    "theme": "malloc",
    "question": "ft_range : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour ft_range, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_range",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0169",
    "theme": "malloc",
    "question": "ft_range : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour ft_range, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_range",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0170",
    "theme": "malloc",
    "question": "ft_range : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant libère le tableau d'int retourné.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour ft_range, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_range",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0171",
    "theme": "malloc",
    "question": "ft_list_remove_if : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour ft_list_remove_if, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0172",
    "theme": "malloc",
    "question": "ft_list_remove_if : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation: la fonction modifie la liste en place.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour ft_list_remove_if, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0173",
    "theme": "malloc",
    "question": "ft_list_remove_if : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour ft_list_remove_if, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0174",
    "theme": "malloc",
    "question": "ft_list_remove_if : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour ft_list_remove_if, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0175",
    "theme": "malloc",
    "question": "ft_list_remove_if : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "La fonction free uniquement les maillons supprimés, pas les maillons conservés.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour ft_list_remove_if, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "ft_list_remove_if",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0176",
    "theme": "malloc",
    "question": "sort_list : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour sort_list, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0177",
    "theme": "malloc",
    "question": "sort_list : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation: tri in-place sur la liste existante.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour sort_list, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0178",
    "theme": "malloc",
    "question": "sort_list : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour sort_list, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "sort_list",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0179",
    "theme": "malloc",
    "question": "sort_list : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour sort_list, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "sort_list",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0180",
    "theme": "malloc",
    "question": "sort_list : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucun free à faire dans le tri: on réordonne sans libérer.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour sort_list, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "sort_list",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0181",
    "theme": "malloc",
    "question": "itoa : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Oui, pour produire la chaîne représentant l’entier avec une taille calculée.",
      "Non, un pointeur local suffit toujours.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour itoa, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0182",
    "theme": "malloc",
    "question": "itoa : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Allouer `(digits + sign + 1) * sizeof(char)`.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour itoa, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0183",
    "theme": "malloc",
    "question": "itoa : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour itoa, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "itoa",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0184",
    "theme": "malloc",
    "question": "itoa : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour itoa, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "itoa",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0185",
    "theme": "malloc",
    "question": "itoa : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "L’appelant est responsable du free de la chaîne retournée.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour itoa, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "itoa",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0186",
    "theme": "malloc",
    "question": "wdmatch : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour wdmatch, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0187",
    "theme": "malloc",
    "question": "wdmatch : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique n’est nécessaire pour la logique.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour wdmatch, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0188",
    "theme": "malloc",
    "question": "wdmatch : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour wdmatch, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "wdmatch",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0189",
    "theme": "malloc",
    "question": "wdmatch : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour wdmatch, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "wdmatch",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0190",
    "theme": "malloc",
    "question": "wdmatch : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans l’implémentation standard.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour wdmatch, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "wdmatch",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0191",
    "theme": "malloc",
    "question": "union : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour union, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "union",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0192",
    "theme": "malloc",
    "question": "union : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique: tableau seen local de 256 cases.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour union, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "union",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0193",
    "theme": "malloc",
    "question": "union : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour union, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "union",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0194",
    "theme": "malloc",
    "question": "union : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour union, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "union",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0195",
    "theme": "malloc",
    "question": "union : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer dans cette approche.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour union, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "union",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0196",
    "theme": "malloc",
    "question": "atoi : dois-tu utiliser malloc dans cette implémentation, et pour quoi exactement ?",
    "choices": [
      "Non, la solution standard n’a pas besoin d’allocation dynamique.",
      "Oui, il faut allouer un buffer fixe de 1024 octets.",
      "Oui, mais sans calcul de taille, juste pour éviter les warnings.",
      "Oui, puis free immédiatement avant de retourner."
    ],
    "correct": 0,
    "explanation": "Pour atoi, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le besoin réel d’allocation dépend du contrat de sortie de la fonction.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_need"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0197",
    "theme": "malloc",
    "question": "atoi : quand malloc est nécessaire, quelle stratégie de taille est correcte ?",
    "choices": [
      "Aucune allocation dynamique n’est requise.",
      "Allouer la taille du pointeur retourné et multiplier au hasard.",
      "Allouer un buffer constant pour tous les cas.",
      "Allouer la moitié puis agrandir sans vérifier les bornes."
    ],
    "correct": 0,
    "explanation": "Pour atoi, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La taille exacte est indispensable pour passer les cas cachés de la moulinette.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_size"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0198",
    "theme": "malloc",
    "question": "atoi : un malloc retourne NULL en plein run. Quelle décision garde le comportement maîtrisé ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Écrire quand même dans le pointeur puis corriger après.",
      "Boucler sur malloc sans condition de sortie.",
      "Retourner un pointeur local pour masquer l’erreur."
    ],
    "correct": 0,
    "explanation": "Pour atoi, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le chemin d’erreur doit être propre et immédiat.",
    "tags": [
      "malloc",
      "atoi",
      "malloc_fail"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0199",
    "theme": "malloc",
    "question": "atoi : pour éviter un malloc trop petit ou inutile, quelle règle est la plus fiable ?",
    "choices": [
      "Allouer une taille fixe supposée suffisante.",
      "Déduire la taille des données réelles avant d’allouer.",
      "Allouer puis ignorer les erreurs de dépassement.",
      "Éviter tout test de borne pour accélérer."
    ],
    "correct": 1,
    "explanation": "Pour atoi, cette décision d’allocation protège des crashs et des fuites sur les cas limites. Le dimensionnement piloté par les données est le réflexe attendu à l’exam.",
    "tags": [
      "malloc",
      "atoi",
      "sizing_reflex"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0200",
    "theme": "malloc",
    "question": "atoi : ta fonction retourne une zone allouée. Quelle règle de free est correcte côté appelant ?",
    "choices": [
      "Aucune mémoire dynamique à libérer pour atoi.",
      "Ne jamais free, le programme termine vite à l’exam.",
      "Free dans la fonction puis retourner le pointeur libéré.",
      "Free seulement un octet sur deux pour limiter le coût."
    ],
    "correct": 0,
    "explanation": "Pour atoi, cette décision d’allocation protège des crashs et des fuites sur les cas limites. La responsabilité de libération doit être explicite dans la convention d’usage.",
    "tags": [
      "malloc",
      "atoi",
      "free_contract"
    ],
    "difficulty": "medium"
  },
  {
    "id": "q0201",
    "theme": "conditions_limites",
    "question": "ft_split : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Une entrée vide ou composée uniquement de séparateurs.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0202",
    "theme": "conditions_limites",
    "question": "ft_split : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Le dernier mot n’est pas suivi d’un séparateur.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0203",
    "theme": "conditions_limites",
    "question": "ft_split : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester chaque retour de malloc immédiatement avec `if (!ptr)`.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0204",
    "theme": "conditions_limites",
    "question": "ft_split : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Libérer chaque mot déjà alloué, libérer le tableau, puis retourner NULL.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0205",
    "theme": "conditions_limites",
    "question": "ft_split : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Ajouter la case de terminaison (`+1`) pour stocker le pointeur NULL final.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_split",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0206",
    "theme": "conditions_limites",
    "question": "ft_range : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Le cas `start == end`, qui doit retourner un tableau de taille 1.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0207",
    "theme": "conditions_limites",
    "question": "ft_range : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Le cas `start > end`, qui impose un parcours décroissant.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0208",
    "theme": "conditions_limites",
    "question": "ft_range : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester le pointeur retourné par malloc avant tout remplissage.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0209",
    "theme": "conditions_limites",
    "question": "ft_range : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Retourner NULL immédiatement si l’allocation échoue.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0210",
    "theme": "conditions_limites",
    "question": "ft_range : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Calculer `abs(end - start) + 1` pour éviter le off-by-one.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_range",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0211",
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Plusieurs maillons en tête correspondent au critère de suppression.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0212",
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Suppression du dernier maillon sans perdre la chaîne.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0213",
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0214",
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si la liste est vide ou le pointeur de tête est invalide, sortir sans toucher la mémoire.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0215",
    "theme": "conditions_limites",
    "question": "ft_list_remove_if : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Faire `tmp = cur->next`, puis unlink, puis free(tmp), dans cet ordre strict.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "ft_list_remove_if",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0216",
    "theme": "conditions_limites",
    "question": "sort_list : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Liste vide ou liste d'un seul élément.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0217",
    "theme": "conditions_limites",
    "question": "sort_list : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Tous les éléments égaux, le tri doit rester stable sans boucle infinie.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0218",
    "theme": "conditions_limites",
    "question": "sort_list : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester `if (!lst || !lst->next)` avant le premier passage.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0219",
    "theme": "conditions_limites",
    "question": "sort_list : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si la liste est vide ou contient un seul maillon, retourner immédiatement.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0220",
    "theme": "conditions_limites",
    "question": "sort_list : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Swapper les `data` plutôt que les liens si tu n’as pas une gestion complète des pointeurs.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "sort_list",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0221",
    "theme": "conditions_limites",
    "question": "itoa : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Les valeurs `0` et `INT_MIN`.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur itoa, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "itoa",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0222",
    "theme": "conditions_limites",
    "question": "itoa : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "INT_MIN ne peut pas être négaté en int sans overflow.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur itoa, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "itoa",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0223",
    "theme": "conditions_limites",
    "question": "itoa : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester le résultat de malloc avant d’écrire un seul caractère.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur itoa, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "itoa",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0224",
    "theme": "conditions_limites",
    "question": "itoa : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Retourner NULL si malloc échoue, sans écrire dans un pointeur invalide.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur itoa, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "itoa",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0225",
    "theme": "conditions_limites",
    "question": "itoa : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Caster en `long` avant de manipuler la valeur négative.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur itoa, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "itoa",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0226",
    "theme": "conditions_limites",
    "question": "wdmatch : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Le cas où argv[1] est vide.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0227",
    "theme": "conditions_limites",
    "question": "wdmatch : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Un caractère manquant doit invalider immédiatement le match.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0228",
    "theme": "conditions_limites",
    "question": "wdmatch : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Valider argc avant tout accès à argv[1] et argv[2].",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0229",
    "theme": "conditions_limites",
    "question": "wdmatch : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si argc est invalide, écrire seulement `\\n` et retourner.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0230",
    "theme": "conditions_limites",
    "question": "wdmatch : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Conserver le sens de parcours: on scanne argv[2], pas l’inverse.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "wdmatch",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0231",
    "theme": "conditions_limites",
    "question": "union : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Les chaînes vides doivent être gérées sans accès hors borne.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur union, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "union",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0232",
    "theme": "conditions_limites",
    "question": "union : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Caractères hors ASCII standard avec char signé.",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur union, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "union",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0233",
    "theme": "conditions_limites",
    "question": "union : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Tester argc avant d’accéder aux arguments utilisateur.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur union, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "union",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0234",
    "theme": "conditions_limites",
    "question": "union : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si argc est invalide, écrire uniquement `\\n` et sortir.",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur union, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "union",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0235",
    "theme": "conditions_limites",
    "question": "union : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Indexer seen avec `(unsigned char)c` pour éviter les index négatifs.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur union, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "union",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0236",
    "theme": "conditions_limites",
    "question": "atoi : quel cas limite dois-tu valider avant les tests nominaux ?",
    "choices": [
      "Chaîne vide, signe seul, ou `-0`.",
      "Uniquement le cas moyen, les extrêmes sont hors sujet.",
      "Le cas le plus rapide à coder, sans lien avec le sujet.",
      "Aucun, car la moulinette ne teste pas les bords."
    ],
    "correct": 0,
    "explanation": "Sur atoi, ce cas limite est souvent testé en premier. Le cas limite est souvent la première entrée des tests cachés.",
    "tags": [
      "conditions_limites",
      "atoi",
      "edge_priority"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0237",
    "theme": "conditions_limites",
    "question": "atoi : sur un run de correction, quel scénario de bord est le plus critique ici ?",
    "choices": [
      "Entrée avec espaces puis signe, ex: \"   -42\".",
      "Un cas purement théorique sans exécution réelle.",
      "Un cas où on désactive volontairement les bornes.",
      "Un cas sans rapport avec la fonction traitée."
    ],
    "correct": 0,
    "explanation": "Sur atoi, ce cas limite est souvent testé en premier. Valider ce scénario réduit fortement les échecs tardifs en exam.",
    "tags": [
      "conditions_limites",
      "atoi",
      "limit_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0238",
    "theme": "conditions_limites",
    "question": "atoi : quel garde-fou doit être exécuté avant de toucher aux données d’entrée ?",
    "choices": [
      "Vérifier le pointeur d’entrée si le sujet le demande explicitement.",
      "Forcer la lecture pour voir si ça crash.",
      "Remplacer les entrées invalides par une constante.",
      "Ignorer les pointeurs et avancer quand même."
    ],
    "correct": 0,
    "explanation": "Sur atoi, ce cas limite est souvent testé en premier. La garde d’entrée empêche les déréférencements hors contrat.",
    "tags": [
      "conditions_limites",
      "atoi",
      "input_guard"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0239",
    "theme": "conditions_limites",
    "question": "atoi : sur un cas vide ou minimal, quel comportement est attendu par le sujet ?",
    "choices": [
      "Si l’entrée est invalide selon le sujet, retourner la valeur de repli prévue (souvent 0).",
      "Planter rapidement pour exposer l’erreur.",
      "Retourner une adresse locale temporaire.",
      "Écrire du texte explicatif non demandé."
    ],
    "correct": 0,
    "explanation": "Sur atoi, ce cas limite est souvent testé en premier. Le comportement minimal doit rester sûr et contractuel.",
    "tags": [
      "conditions_limites",
      "atoi",
      "minimal_case"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0240",
    "theme": "conditions_limites",
    "question": "atoi : quelle décision évite un off-by-one sur les entrées extrêmes ?",
    "choices": [
      "Vérifier l’incrément dans toutes les branches de boucle pour éviter la boucle infinie.",
      "Limiter la boucle à une borne arbitraire.",
      "Retirer les vérifications de fin pour accélérer.",
      "Décaler systématiquement l’index de +2."
    ],
    "correct": 0,
    "explanation": "Sur atoi, ce cas limite est souvent testé en premier. Le off-by-one est un motif d’échec fréquent en EX2-EX4.",
    "tags": [
      "conditions_limites",
      "atoi",
      "off_by_one"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0241",
    "theme": "regles_implicites",
    "question": "ft_split : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si ft_split fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0242",
    "theme": "regles_implicites",
    "question": "ft_split : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si ft_split fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0243",
    "theme": "regles_implicites",
    "question": "ft_split : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Si les arguments du main de test sont invalides, écrire uniquement un retour ligne.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si ft_split fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0244",
    "theme": "regles_implicites",
    "question": "ft_split : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si ft_split fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0245",
    "theme": "regles_implicites",
    "question": "ft_split : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si ft_split fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_split",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0246",
    "theme": "regles_implicites",
    "question": "ft_range : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si ft_range fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0247",
    "theme": "regles_implicites",
    "question": "ft_range : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si ft_range fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0248",
    "theme": "regles_implicites",
    "question": "ft_range : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter exactement le prototype demandé par l’énoncé pour la correction.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si ft_range fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0249",
    "theme": "regles_implicites",
    "question": "ft_range : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si ft_range fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0250",
    "theme": "regles_implicites",
    "question": "ft_range : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si ft_range fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_range",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0251",
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si ft_list_remove_if fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0252",
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si ft_list_remove_if fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0253",
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Garder exactement la signature imposée (`t_list **begin_list`, cmp, free_fct).",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si ft_list_remove_if fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0254",
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si ft_list_remove_if fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0255",
    "theme": "regles_implicites",
    "question": "ft_list_remove_if : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si ft_list_remove_if fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "ft_list_remove_if",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0256",
    "theme": "regles_implicites",
    "question": "sort_list : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si sort_list fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0257",
    "theme": "regles_implicites",
    "question": "sort_list : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si sort_list fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0258",
    "theme": "regles_implicites",
    "question": "sort_list : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter strictement la fonction de comparaison imposée par l’énoncé.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si sort_list fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0259",
    "theme": "regles_implicites",
    "question": "sort_list : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si sort_list fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0260",
    "theme": "regles_implicites",
    "question": "sort_list : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si sort_list fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "sort_list",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0261",
    "theme": "regles_implicites",
    "question": "itoa : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si itoa fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "itoa",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0262",
    "theme": "regles_implicites",
    "question": "itoa : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si itoa fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "itoa",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0263",
    "theme": "regles_implicites",
    "question": "itoa : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Ne rien afficher: itoa doit uniquement retourner une chaîne.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si itoa fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "itoa",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0264",
    "theme": "regles_implicites",
    "question": "itoa : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si itoa fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "itoa",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0265",
    "theme": "regles_implicites",
    "question": "itoa : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si itoa fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "itoa",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0266",
    "theme": "regles_implicites",
    "question": "wdmatch : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si wdmatch fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0267",
    "theme": "regles_implicites",
    "question": "wdmatch : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si wdmatch fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0268",
    "theme": "regles_implicites",
    "question": "wdmatch : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Sortie stricte: aucun texte annexe, juste le résultat attendu et `\\n`.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si wdmatch fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0269",
    "theme": "regles_implicites",
    "question": "wdmatch : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si wdmatch fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0270",
    "theme": "regles_implicites",
    "question": "wdmatch : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si wdmatch fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "wdmatch",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0271",
    "theme": "regles_implicites",
    "question": "union : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si union fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "union",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0272",
    "theme": "regles_implicites",
    "question": "union : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si union fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "union",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0273",
    "theme": "regles_implicites",
    "question": "union : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "Respecter la sortie exacte attendue, sans espace ni message supplémentaire.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si union fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "union",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0274",
    "theme": "regles_implicites",
    "question": "union : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si union fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "union",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0275",
    "theme": "regles_implicites",
    "question": "union : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si union fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "union",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0276",
    "theme": "regles_implicites",
    "question": "atoi : le sujet autorise seulement un petit set de fonctions. Quelle décision est correcte avant rendu ?",
    "choices": [
      "Conserver une fonction non autorisée si elle simplifie le code.",
      "Supprimer toute fonction hors liste autorisée, même si ça marche localement.",
      "Ajouter des wrappers pour masquer les appels interdits.",
      "Laisser des prints de debug si la logique est juste."
    ],
    "correct": 1,
    "explanation": "Même si atoi fonctionne, une non-conformité au sujet fait perdre des points. La conformité des fonctions autorisées est vérifiée de façon stricte.",
    "tags": [
      "regles_implicites",
      "atoi",
      "allowed_functions"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0277",
    "theme": "regles_implicites",
    "question": "atoi : le prototype demandé par l’énoncé est précis. Quelle action évite un rejet immédiat ?",
    "choices": [
      "Changer le type de retour pour faciliter ton implémentation.",
      "Conserver exactement le prototype et les noms attendus.",
      "Ajouter un argument optionnel non documenté.",
      "Dupliquer la fonction sous un autre nom."
    ],
    "correct": 1,
    "explanation": "Même si atoi fonctionne, une non-conformité au sujet fait perdre des points. Un prototype non conforme casse souvent la compilation ou le linkage.",
    "tags": [
      "regles_implicites",
      "atoi",
      "prototype"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0278",
    "theme": "regles_implicites",
    "question": "atoi : dans un main de test exam, argc est invalide. Quel comportement de sortie reste conforme ?",
    "choices": [
      "La fonction retourne une valeur; elle ne doit pas produire de sortie texte.",
      "Afficher un message d’aide détaillé sur plusieurs lignes.",
      "Écrire sur stderr pour informer le correcteur.",
      "Continuer l’exécution avec des argv non valides."
    ],
    "correct": 0,
    "explanation": "Même si atoi fonctionne, une non-conformité au sujet fait perdre des points. La sortie attendue est contractuelle, même sur erreur d’usage.",
    "tags": [
      "regles_implicites",
      "atoi",
      "argc_contract"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0279",
    "theme": "regles_implicites",
    "question": "atoi : le sujet compare la sortie au caractère près. Quelle décision est obligatoire ?",
    "choices": [
      "Ajouter des espaces pour une sortie plus lisible.",
      "Respecter strictement le format, y compris le retour ligne final.",
      "Écrire des logs pendant le run pour expliquer le résultat.",
      "Remplacer stdout par stderr pour séparer les messages."
    ],
    "correct": 1,
    "explanation": "Même si atoi fonctionne, une non-conformité au sujet fait perdre des points. Le moindre caractère en plus ou en moins provoque un échec de test.",
    "tags": [
      "regles_implicites",
      "atoi",
      "exact_output"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0280",
    "theme": "regles_implicites",
    "question": "atoi : avant de rendre, quelle vérification finale est la plus rentable à 42 ?",
    "choices": [
      "Relire uniquement l’algorithme sans regarder le sujet.",
      "Relire le sujet ligne par ligne et vérifier chaque contrainte technique.",
      "Optimiser le code sans retester les cas limites.",
      "Supprimer les gardes pour réduire la taille du fichier."
    ],
    "correct": 1,
    "explanation": "Même si atoi fonctionne, une non-conformité au sujet fait perdre des points. La conformité sujet + cas limites fait gagner plus de points que l’optimisation.",
    "tags": [
      "regles_implicites",
      "atoi",
      "final_check"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0281",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0282",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0283",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0284",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0285",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression en tête, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0286",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0287",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0288",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0289",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0290",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression au milieu de la chaîne, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0291",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0292",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0293",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0294",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0295",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en suppression de maillons consécutifs, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0296",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0297",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0298",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0299",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0300",
    "theme": "listes_chainees",
    "question": "ft_list_remove_if : en fin de parcours proche du dernier maillon, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans ft_list_remove_if. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "ft_list_remove_if",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0301",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0302",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0303",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0304",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0305",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression en tête, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0306",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0307",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0308",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0309",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0310",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression au milieu de la chaîne, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0311",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0312",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0313",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0314",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0315",
    "theme": "listes_chainees",
    "question": "sort_list : en suppression de maillons consécutifs, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0316",
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel ordre d’opérations est correct ?",
    "choices": [
      "Free le maillon cible, puis reconnecter ensuite.",
      "Reconnecter les liens, puis free le maillon supprimé.",
      "Avancer `cur` deux fois puis décider de supprimer.",
      "Réinitialiser la tête à NULL avant de comparer."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le chaînage doit rester valide avant toute libération.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "unlink_free"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0317",
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel pointeur temporaire faut-il conserver avant modification ?",
    "choices": [
      "Aucun temporaire, on peut relire l’adresse après free.",
      "Un pointeur vers le maillon ciblé (`tmp`) avant unlink.",
      "Un pointeur vers une variable locale de pile.",
      "Un pointeur global statique partagé entre appels."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Sans temporaire, la suppression perd rapidement la suite de la liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "tmp_pointer"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0318",
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quelle règle d’avancement de `cur` évite de sauter des maillons ?",
    "choices": [
      "Toujours avancer `cur` même après une suppression.",
      "N’avancer `cur` que quand aucun maillon n’a été retiré à ce tour.",
      "Remettre `cur` sur la tête à chaque suppression.",
      "Incrémenter `cur++` comme dans un tableau."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Ce réflexe évite les suppressions incomplètes sur des séries de matches.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "advance_rule"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0319",
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quel test de garde doit être fait avant d’accéder à `->next` ?",
    "choices": [
      "Aucun test, le compilateur protège ce cas.",
      "Vérifier que le pointeur courant et son suivant existent.",
      "Tester uniquement la valeur de comparaison cmp.",
      "Tester uniquement `errno`."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Cette garde évite les déréférencements invalides sur fin de liste.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "guard_next"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0320",
    "theme": "listes_chainees",
    "question": "sort_list : en fin de parcours proche du dernier maillon, quelle décision rend le comportement stable sur liste vide et liste à un élément ?",
    "choices": [
      "Entrer directement dans la boucle sans garde.",
      "Traiter ces cas en garde initiale puis retourner proprement.",
      "Forcer un maillon fictif pour simplifier la logique.",
      "Supprimer systématiquement le premier maillon."
    ],
    "correct": 1,
    "explanation": "En liste chaînée, l’ordre pointeur/reconnexion/free est critique dans sort_list. Le cas minimal est systématiquement testé en EX3/EX4.",
    "tags": [
      "listes_chainees",
      "sort_list",
      "minimal_list"
    ],
    "difficulty": "hard"
  },
  {
    "id": "q0321",
    "theme": "general",
    "question": "ft_split : contexte tu découpes une phrase avec des séparateurs simples. Quelle vérification fais-tu d’abord quand la chaîne peut être vide ou contenir uniquement des séparateurs ?",
    "choices": [
      "Compter les mots avant toute allocation, puis retourner un tableau terminé par NULL si aucun mot n’est trouvé.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "ft_split",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0322",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu découpes une phrase avec des séparateurs simples), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Copier les mots un par un avec un index stable, puis écrire `tab[index] = NULL` pour terminer la structure.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "ft_split",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0323",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu découpes une phrase avec des séparateurs simples), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Allouer `(nb_mots + 1) * sizeof(char *)` pour réserver la case de terminaison NULL.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "ft_split",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0324",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu découpes une phrase avec des séparateurs simples), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Traiter explicitement la fin de chaîne comme une fin de mot pour ne pas perdre le dernier segment.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "ft_split",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0325",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu découpes une phrase avec des séparateurs simples), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "L’appelant doit libérer chaque mot puis le tableau, sinon la mémoire reste allouée."
    ],
    "correct": 3,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "ft_split",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0326",
    "theme": "general",
    "question": "ft_range : contexte tu génères une suite d’entiers de start vers end. Quelle vérification fais-tu d’abord quand start peut être supérieur à end ?",
    "choices": [
      "Calculer un `step` à +1 ou -1 avant la boucle pour couvrir les parcours croissants et décroissants.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "ft_range",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0327",
    "theme": "general",
    "question": "ft_range : dans ce contexte (tu génères une suite d’entiers de start vers end), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Remplir le tableau avec une valeur courante qui avance de `step` à chaque itération.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur ft_range, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "ft_range",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0328",
    "theme": "general",
    "question": "ft_range : dans ce contexte (tu génères une suite d’entiers de start vers end), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Utiliser `abs(end - start) + 1` pour éviter le off-by-one sur les bornes inclusives.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur ft_range, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "ft_range",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0329",
    "theme": "general",
    "question": "ft_range : dans ce contexte (tu génères une suite d’entiers de start vers end), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Retourner un tableau de taille 1 contenant exactement cette valeur.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur ft_range, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "ft_range",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0330",
    "theme": "general",
    "question": "ft_range : dans ce contexte (tu génères une suite d’entiers de start vers end), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Retourner le pointeur de base du tableau, jamais un pointeur déjà avancé pendant le remplissage."
    ],
    "correct": 3,
    "explanation": "Sur ft_range, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "ft_range",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0331",
    "theme": "general",
    "question": "ft_list_remove_if : contexte tu supprimes des maillons d’une liste chaînée. Quelle vérification fais-tu d’abord quand la liste peut être vide au début ?",
    "choices": [
      "Vérifier `begin_list` et `*begin_list` avant toute déréférence pour éviter un crash immédiat.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "ft_list_remove_if",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0332",
    "theme": "general",
    "question": "ft_list_remove_if : dans ce contexte (tu supprimes des maillons d’une liste chaînée), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Sauvegarder le maillon cible dans `tmp`, reconnecter les liens, puis faire `free(tmp)`.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur ft_list_remove_if, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "ft_list_remove_if",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0333",
    "theme": "general",
    "question": "ft_list_remove_if : dans ce contexte (tu supprimes des maillons d’une liste chaînée), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Aucune allocation n’est nécessaire: la suppression se fait en place avec reconnection des pointeurs.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur ft_list_remove_if, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "ft_list_remove_if",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0334",
    "theme": "general",
    "question": "ft_list_remove_if : dans ce contexte (tu supprimes des maillons d’une liste chaînée), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Nettoyer la tête avec une boucle `while` avant de passer au parcours classique avec `cur`.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur ft_list_remove_if, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "ft_list_remove_if",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0335",
    "theme": "general",
    "question": "ft_list_remove_if : dans ce contexte (tu supprimes des maillons d’une liste chaînée), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Mettre à jour `*begin_list` pour conserver la nouvelle tête après les suppressions."
    ],
    "correct": 3,
    "explanation": "Sur ft_list_remove_if, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "ft_list_remove_if",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0336",
    "theme": "general",
    "question": "sort_list : contexte tu fais un tri simple sur une liste chaînée. Quelle vérification fais-tu d’abord quand la liste est vide ou contient un seul élément ?",
    "choices": [
      "Retourner immédiatement sans entrer dans le tri, car aucun échange n’est nécessaire.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "sort_list",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0337",
    "theme": "general",
    "question": "sort_list : dans ce contexte (tu fais un tri simple sur une liste chaînée), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Échanger les `data` via une variable temporaire, puis continuer le passage.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur sort_list, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "sort_list",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0338",
    "theme": "general",
    "question": "sort_list : dans ce contexte (tu fais un tri simple sur une liste chaînée), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Le tri exam se fait en place, sans malloc ni copie complète de la liste.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur sort_list, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "sort_list",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0339",
    "theme": "general",
    "question": "sort_list : dans ce contexte (tu fais un tri simple sur une liste chaînée), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Arrêter le tri quand `swapped` reste à 0, c’est le signal de fin attendu.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur sort_list, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "sort_list",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0340",
    "theme": "general",
    "question": "sort_list : dans ce contexte (tu fais un tri simple sur une liste chaînée), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Retourner la tête de liste reçue en entrée, après les échanges en place."
    ],
    "correct": 3,
    "explanation": "Sur sort_list, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "sort_list",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0341",
    "theme": "general",
    "question": "itoa : contexte tu convertis un entier signé en chaîne. Quelle vérification fais-tu d’abord quand la valeur peut être `0` ou négative ?",
    "choices": [
      "Gérer le signe et le cas `0` dès le début pour dimensionner la chaîne correctement.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "itoa",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0342",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu convertis un entier signé en chaîne), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Remplir la chaîne depuis la fin vers le début avec `% 10`, puis finir sur l’index 0.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "itoa",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0343",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu convertis un entier signé en chaîne), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Allouer `digits + sign + 1` caractères pour inclure les chiffres, le signe éventuel et `\\0`.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "itoa",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0344",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu convertis un entier signé en chaîne), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Caster en `long` avant négation pour éviter un overflow en `int`.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "itoa",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0345",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu convertis un entier signé en chaîne), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Tester le pointeur retourné et renvoyer NULL immédiatement si l’allocation échoue."
    ],
    "correct": 3,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "itoa",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0346",
    "theme": "general",
    "question": "wdmatch : contexte tu dois vérifier si argv[1] est inclus dans argv[2] dans le bon ordre. Quelle vérification fais-tu d’abord quand le programme peut être lancé avec un argc invalide ?",
    "choices": [
      "Tester `argc` en premier et écrire seulement `\\n` si le contrat d’arguments n’est pas respecté.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "wdmatch",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0347",
    "theme": "general",
    "question": "wdmatch : dans ce contexte (tu dois vérifier si argv[1] est inclus dans argv[2] dans le bon ordre), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Avancer l’index de argv[1] uniquement quand un caractère correspondant est trouvé.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur wdmatch, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "wdmatch",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0348",
    "theme": "general",
    "question": "wdmatch : dans ce contexte (tu dois vérifier si argv[1] est inclus dans argv[2] dans le bon ordre), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Aucune allocation n’est nécessaire: deux index suffisent pour faire la vérification.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur wdmatch, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "wdmatch",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0349",
    "theme": "general",
    "question": "wdmatch : dans ce contexte (tu dois vérifier si argv[1] est inclus dans argv[2] dans le bon ordre), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Considérer ce cas comme valide, donc afficher une ligne vide conforme au sujet.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur wdmatch, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "wdmatch",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0350",
    "theme": "general",
    "question": "wdmatch : dans ce contexte (tu dois vérifier si argv[1] est inclus dans argv[2] dans le bon ordre), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Afficher uniquement le résultat attendu suivi de `\\n`, sans message annexe."
    ],
    "correct": 3,
    "explanation": "Sur wdmatch, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "wdmatch",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0351",
    "theme": "general",
    "question": "union : contexte tu affiches les caractères uniques de deux chaînes. Quelle vérification fais-tu d’abord quand les arguments peuvent être absents ?",
    "choices": [
      "Vérifier `argc` avant accès aux chaînes, puis produire uniquement `\\n` si besoin.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur union, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "union",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0352",
    "theme": "general",
    "question": "union : dans ce contexte (tu affiches les caractères uniques de deux chaînes), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Utiliser `seen[256]` et marquer chaque caractère dès sa première apparition.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur union, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "union",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0353",
    "theme": "general",
    "question": "union : dans ce contexte (tu affiches les caractères uniques de deux chaînes), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Un tableau fixe de 256 cases suffit pour suivre tous les octets possibles.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur union, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "union",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0354",
    "theme": "general",
    "question": "union : dans ce contexte (tu affiches les caractères uniques de deux chaînes), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Indexer `seen` avec `(unsigned char)c` pour éviter les indices négatifs.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur union, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "union",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0355",
    "theme": "general",
    "question": "union : dans ce contexte (tu affiches les caractères uniques de deux chaînes), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Ajouter un unique `\\n` final, car la sortie est comparée caractère par caractère."
    ],
    "correct": 3,
    "explanation": "Sur union, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "union",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0356",
    "theme": "general",
    "question": "atoi : contexte tu convertis une chaîne utilisateur en entier. Quelle vérification fais-tu d’abord quand la chaîne peut commencer par des espaces ?",
    "choices": [
      "Ignorer les espaces initiaux avant de traiter le signe et les chiffres.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur atoi, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "atoi",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0357",
    "theme": "general",
    "question": "atoi : dans ce contexte (tu convertis une chaîne utilisateur en entier), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Accumuler `result = result * 10 + (c - '0')` tant que le caractère est un chiffre.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur atoi, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "atoi",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0358",
    "theme": "general",
    "question": "atoi : dans ce contexte (tu convertis une chaîne utilisateur en entier), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Aucune allocation n’est nécessaire: la conversion se fait avec des variables locales.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur atoi, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "atoi",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0359",
    "theme": "general",
    "question": "atoi : dans ce contexte (tu convertis une chaîne utilisateur en entier), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Arrêter la conversion au premier caractère invalide et retourner la valeur accumulée.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur atoi, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "atoi",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0360",
    "theme": "general",
    "question": "atoi : dans ce contexte (tu convertis une chaîne utilisateur en entier), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Retourner 0 dans ce cas standard pour rester cohérent avec le comportement attendu."
    ],
    "correct": 3,
    "explanation": "Sur atoi, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "atoi",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0361",
    "theme": "general",
    "question": "ft_split : contexte tu sécurises le chemin d’erreur en cas de malloc partiel. Quelle vérification fais-tu d’abord quand une allocation de mot échoue en milieu de traitement ?",
    "choices": [
      "Libérer tous les mots déjà alloués, libérer le tableau, puis retourner NULL proprement.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "ft_split",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0362",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu sécurises le chemin d’erreur en cas de malloc partiel), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Conserver un index de mot fiable pour savoir exactement quoi libérer en cas d’échec.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "ft_split",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0363",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu sécurises le chemin d’erreur en cas de malloc partiel), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Allouer `len_mot + 1` caractères pour inclure le `\\0` final sans débordement.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "ft_split",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0364",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu sécurises le chemin d’erreur en cas de malloc partiel), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Sauter tous les séparateurs avant de démarrer la copie du mot suivant.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "ft_split",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0365",
    "theme": "general",
    "question": "ft_split : dans ce contexte (tu sécurises le chemin d’erreur en cas de malloc partiel), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Retourner une structure complète et NULL-terminée, directement exploitable par l’appelant."
    ],
    "correct": 3,
    "explanation": "Sur ft_split, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "ft_split",
      "bases_output"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0366",
    "theme": "general",
    "question": "itoa : contexte tu veux une version claire et fiable pour les bases. Quelle vérification fais-tu d’abord quand tu initialises la conversion pour un nombre négatif ?",
    "choices": [
      "Stocker le signe, convertir la valeur absolue dans un type sûr, puis positionner `-` au bon index.",
      "Lancer directement la boucle principale, puis corriger après le premier crash observé.",
      "Ajouter des valeurs fixes pour forcer un comportement acceptable sur les tests visibles.",
      "Supprimer les conditions d’entrée pour réduire la taille du code et aller plus vite."
    ],
    "correct": 0,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Commencer par la garde d’entrée évite les erreurs les plus coûteuses sur les cas simples.",
    "tags": [
      "general",
      "itoa",
      "bases_guard"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0367",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu veux une version claire et fiable pour les bases), quelle action est la plus sûre juste après l’étape principale ?",
    "choices": [
      "Ignorer l’état intermédiaire et avancer vers le return sans vérifier la cohérence des données.",
      "Décrémenter l’index après chaque chiffre écrit pour éviter les trous ou les écrasements.",
      "Changer le prototype pour contourner les contraintes de l’énoncé.",
      "Forcer un parcours récursif même quand une boucle simple suffit."
    ],
    "correct": 1,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Cette action stabilise la fonction et réduit les erreurs de logique en conditions normales.",
    "tags": [
      "general",
      "itoa",
      "bases_action"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0368",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu veux une version claire et fiable pour les bases), quelle décision de taille ou de structure est la plus propre pour débuter ?",
    "choices": [
      "Allouer une taille arbitraire pour passer vite aux tests suivants.",
      "Dimensionner selon le nombre de cas moyens observés en local uniquement.",
      "Compter les divisions par 10 sur une copie de la valeur pour ne pas perdre l’original.",
      "Écrire d’abord les résultats, puis ajuster la taille après coup."
    ],
    "correct": 2,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Un dimensionnement clair évite les débordements et simplifie le débogage.",
    "tags": [
      "general",
      "itoa",
      "bases_size"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0369",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu veux une version claire et fiable pour les bases), quel test limite doit être géré explicitement pour éviter une erreur bête ?",
    "choices": [
      "Retourner la chaîne \"0\" avec son terminateur, sans passer par la boucle des divisions.",
      "Ignorer le cas limite tant que les cas nominaux semblent fonctionner en local.",
      "Remplacer le cas limite par une valeur codée en dur pour éviter une branche supplémentaire.",
      "Retourner une adresse locale temporaire pour contourner le traitement complet."
    ],
    "correct": 0,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Gérer ce bord dès le départ évite des échecs faciles à la moulinette.",
    "tags": [
      "general",
      "itoa",
      "bases_edge"
    ],
    "difficulty": "easy"
  },
  {
    "id": "q0370",
    "theme": "general",
    "question": "itoa : dans ce contexte (tu veux une version claire et fiable pour les bases), quelle sortie finale respecte le mieux le contrat de base ?",
    "choices": [
      "Ajouter des messages de debug dans la sortie pour documenter le raisonnement.",
      "Retourner une valeur partielle en espérant que l’appelant complète le traitement.",
      "Libérer systématiquement la mémoire juste avant le return, même quand elle doit être renvoyée.",
      "Poser le `\\0` de fin explicitement, puis retourner le pointeur alloué."
    ],
    "correct": 3,
    "explanation": "Sur itoa, l’objectif est de poser un réflexe clair et réutilisable. Une sortie contractuelle claire rend le comportement prévisible et facile à tester.",
    "tags": [
      "general",
      "itoa",
      "bases_output"
    ],
    "difficulty": "easy"
  }
]
