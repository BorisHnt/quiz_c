[
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé dans `ft_split` avant d’appeler malloc pour le tableau?",
    "choices": [
      "remplir → compter → terminer",
      "compter → malloc → remplir → terminer",
      "malloc → remplir → compter",
      "free → malloc → remplir"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: compter → malloc → remplir → terminer. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel est le pattern classique pour convertir un int en string (itoa)?",
    "choices": [
      "remplir → malloc → compter",
      "compter → remplir → malloc",
      "gérer signe → compter → malloc → remplir à l’envers",
      "malloc → signe → remplir"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: gérer signe → compter → malloc → remplir à l’envers. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), dans `union`, quel pattern évite les doublons?",
    "choices": [
      "tri préalable",
      "compteur global",
      "tableau seen[256]",
      "malloc dynamique"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tableau seen[256]. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à parcourir une liste chaînée?",
    "choices": [
      "for(i=0;i<n;i++)",
      "while(node) node = node->next",
      "do while",
      "récursion obligatoire"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(node) node = node->next. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), dans `ft_list_remove_if`, quel pattern gère la tête?",
    "choices": [
      "cur = begin",
      "boucle while sur *begin",
      "for",
      "swap data"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: boucle while sur *begin. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern permet d’éviter de perdre l’adresse d’un maillon supprimé?",
    "choices": [
      "tmp = cur",
      "tmp = cur->next",
      "free(cur)",
      "continue"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tmp = cur->next. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel est le pattern pour remplir une string terminée?",
    "choices": [
      "'\\n' au début",
      "'\\0' à la fin",
      "'\\t' au milieu",
      "free à la fin"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: '\\0' à la fin. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern permet de gérer INT_MIN dans itoa?",
    "choices": [
      "cast en float",
      "cast en long",
      "malloc double",
      "memcpy"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: cast en long. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à ignorer les séparateurs?",
    "choices": [
      "if unique",
      "while(is_sep) avancer",
      "break",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(is_sep) avancer. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), dans `sort_list`, quel pattern indique la fin du tri?",
    "choices": [
      "i == n",
      "cmp == 0",
      "swapped == 0",
      "cur == NULL"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: swapped == 0. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour compter des chiffres?",
    "choices": [
      "while(n) { n/=10; }",
      "for(i=0;i<n;i++)",
      "allouer dynamiquement avec malloc",
      "strcpy"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: while(n) { n/=10; }. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à strdup et split?",
    "choices": [
      "strcpy direct",
      "compter longueur → malloc → copier",
      "libérer la mémoire avec free",
      "tri"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: compter longueur → malloc → copier. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern garantit la fin d’un tableau de strings?",
    "choices": [
      "'\\0'",
      "NULL final",
      "libérer la mémoire avec free",
      "sizeof"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: NULL final. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern empêche une boucle infinie lors d’un comptage?",
    "choices": [
      "continue",
      "break",
      "modifier la variable testée",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: modifier la variable testée. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), dans wdmatch, quel pattern est utilisé?",
    "choices": [
      "deux boucles imbriquées inversées",
      "parcourir argv[1] seulement",
      "parcourir argv[2] en avançant dans argv[1]",
      "tri préalable"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: parcourir argv[2] en avançant dans argv[1]. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour supprimer plusieurs têtes successives?",
    "choices": [
      "if",
      "while",
      "for",
      "goto"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à atoi et itoa?",
    "choices": [
      "modulo",
      "strlen",
      "memcpy",
      "tri"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: modulo. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour swap deux data dans sort_list?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "tmp variable",
      "libérer la mémoire avec free",
      "break"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tmp variable. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern permet de gérer start > end dans ft_range?",
    "choices": [
      "for fixe",
      "step = +1 ou -1",
      "libérer la mémoire avec free",
      "goto"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: step = +1 ou -1. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern permet d’allouer un tableau d’int?",
    "choices": [
      "malloc(n)",
      "malloc(sizeof(int))",
      "malloc(sizeof(int) * n)",
      "calloc(1)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: malloc(sizeof(int) * n). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour détecter la fin d’une string?",
    "choices": [
      "'\\n'",
      "'\\t'",
      "'\\0'",
      "EOF"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: '\\0'. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour compter les mots?",
    "choices": [
      "while(str)",
      "transitions séparateur → lettre",
      "strlen",
      "atoi"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: transitions séparateur → lettre. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à protéger malloc?",
    "choices": [
      "if(ptr) free",
      "if(!ptr) return NULL",
      "break",
      "exit obligatoire"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: if(!ptr) return NULL. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour remplir une string depuis la droite?",
    "choices": [
      "index croissant",
      "index décroissant",
      "memcpy",
      "strcpy"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: index décroissant. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à éviter de sauter un élément après suppression?",
    "choices": [
      "avancer toujours",
      "ne pas avancer après unlink",
      "free double",
      "goto"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: ne pas avancer après unlink. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à union et inter?",
    "choices": [
      "bubble sort",
      "seen[256]",
      "recursion",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: seen[256]. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à gérer argc?",
    "choices": [
      "strcmp",
      "if(argc!= attendu)",
      "allouer dynamiquement avec malloc",
      "break"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: if(argc!= attendu). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour remplir un tableau avec une suite?",
    "choices": [
      "while",
      "step + incrément",
      "recursion",
      "goto"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: step + incrément. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour parcourir argv?",
    "choices": [
      "argv++",
      "while(argv[i])",
      "strcpy",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(argv[i]). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à toutes les fonctions avec sortie texte?",
    "choices": [
      "printf",
      "write + '\\n'",
      "scanf",
      "fgets"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: write + '\\n'. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour stocker l’état des cartes ratées?",
    "choices": [
      "tableau fixe",
      "compteur par carte",
      "libérer la mémoire avec free",
      "strcpy"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: compteur par carte. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à calculer une taille inclusive?",
    "choices": [
      "end-start",
      "abs(end-start)",
      "abs(end-start)+1",
      "sizeof"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: abs(end-start)+1. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à parcourir jusqu’à NULL?",
    "choices": [
      "while(ptr)",
      "for",
      "if",
      "break"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: while(ptr). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour repérer un début de mot?",
    "choices": [
      "lettre + lettre",
      "séparateur + lettre",
      "lettre + séparateur",
      "EOF"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: séparateur + lettre. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour remplir un tableau dynamique?",
    "choices": [
      "malloc puis indexation",
      "realloc constant",
      "recursion",
      "goto"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: malloc puis indexation. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à convertir un char chiffre en int?",
    "choices": [
      "c * 10",
      "c + '0'",
      "c - '0'",
      "atoi"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: c - '0'. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à convertir un int en char chiffre?",
    "choices": [
      "n + '0'",
      "n - '0'",
      "n * '0'",
      "atoi"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: n + '0'. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour nettoyer un pointeur après free?",
    "choices": [
      "ptr++",
      "ptr = NULL",
      "allouer dynamiquement avec malloc",
      "break"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: ptr = NULL. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à tous les parcours?",
    "choices": [
      "condition + avancement",
      "allouer dynamiquement avec malloc",
      "libérer la mémoire avec free",
      "sizeof"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: condition + avancement. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour stocker temporairement une valeur?",
    "choices": [
      "static",
      "tmp",
      "libérer la mémoire avec free",
      "sizeof"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tmp. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour parcourir une string?",
    "choices": [
      "for sans condition",
      "while(str[i])",
      "libérer la mémoire avec free",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(str[i]). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à s’arrêter sur un séparateur?",
    "choices": [
      "while(!sep)",
      "break",
      "libérer la mémoire avec free",
      "goto"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: while(!sep). Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à copier un mot?",
    "choices": [
      "strcpy",
      "boucle char par char",
      "memcpy uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: boucle char par char. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à toutes les allocations?",
    "choices": [
      "malloc + free",
      "sizeof",
      "if(!ptr)",
      "A + C"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: A + C. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour tester la fin d’un tableau de strings?",
    "choices": [
      "'\\0'",
      "NULL",
      "EOF",
      "0xFF"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: NULL. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern sert à gérer un cas spécial?",
    "choices": [
      "if initial",
      "libérer la mémoire avec free",
      "allouer dynamiquement avec malloc",
      "goto"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: if initial. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour inverser une string?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "deux indices i/j",
      "recursion",
      "sizeof"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: deux indices i/j. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour faire un tri simple?",
    "choices": [
      "quicksort",
      "bubble sort",
      "mergesort",
      "heapsort"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: bubble sort. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est utilisé pour stocker une erreur?",
    "choices": [
      "flag",
      "libérer la mémoire avec free",
      "sizeof",
      "goto"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: flag. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "patterns",
    "question": "Dans un exercice de C (exam 42), quel pattern est commun à tous les exos d’exam réussis?",
    "choices": [
      "vitesse",
      "écrire direct",
      "checklist mentale",
      "copier internet"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: checklist mentale. Cette option suit le pattern attendu par les tests: ordre des étapes, allocation, puis terminaison correcte. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "patterns"
    ]
  },
  {
    "theme": "pieges",
    "question": "Quel oubli provoque le plus souvent un dépassement mémoire lors d’une copie de string?",
    "choices": [
      "oublier sizeof",
      "oublier '\\0'",
      "oublier free",
      "oublier argc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: oublier '\\0'. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), dans un exo d’exam, que faut-il afficher si argc est incorrect?",
    "choices": [
      "message d’erreur",
      "aucun effet particulier",
      "juste '\\n'",
      "exit(1)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: juste '\\n'. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel est le piège principal dans wdmatch?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "mauvais sens de parcours",
      "tri",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: mauvais sens de parcours. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel est le piège classique dans split?",
    "choices": [
      "free trop tôt",
      "ne pas compter les mots",
      "malloc trop grand",
      "utiliser printf"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: ne pas compter les mots. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi seen[256] doit être indexé avec unsigned char?",
    "choices": [
      "optimisation",
      "éviter indices négatifs",
      "question de style uniquement",
      "tri"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter indices négatifs. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège survient si on avance cur après avoir supprimé cur->next?",
    "choices": [
      "double free",
      "fuite",
      "saut d’élément",
      "segmentation fault immédiat"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: saut d’élément. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), dans itoa, que se passe-t-il si on ne traite pas INT_MIN?",
    "choices": [
      "fuite",
      "overflow",
      "boucle infinie",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: overflow. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège arrive si on oublie de vérifier malloc?",
    "choices": [
      "avertissement du compilateur",
      "free manquant",
      "segmentation fault",
      "compilation impossible"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: segmentation fault. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi dst[i] = \"\\0\" est faux?",
    "choices": [
      "trop long",
      "type incorrect",
      "compile mais bug",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: type incorrect. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel est le piège avec while(n) quand n vaut 0?",
    "choices": [
      "crash",
      "boucle infinie",
      "boucle ignorée",
      "double free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: boucle ignorée. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel oubli cause une boucle infinie?",
    "choices": [
      "break",
      "incrément",
      "libérer la mémoire avec free",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: incrément. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec start > end dans ft_range?",
    "choices": [
      "segmentation fault",
      "aucun effet particulier",
      "oublier step négatif",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: oublier step négatif. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), que se passe-t-il si on écrit malloc(len) au lieu de malloc(len + 1)?",
    "choices": [
      "fuite",
      "un caractère manquant",
      "écriture hors limites",
      "échec de compilation"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: écriture hors limites. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi '\\n' final est obligatoire dans beaucoup d’exos?",
    "choices": [
      "question de style uniquement",
      "tests automatiques",
      "allouer dynamiquement avec malloc",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tests automatiques. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège survient si on ne remet pas à zéro seen[256]?",
    "choices": [
      "crash",
      "doublons ratés",
      "faux positifs",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: faux positifs. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi modifier directement nbr dans itoa est dangereux?",
    "choices": [
      "fuite",
      "on perd la valeur originale",
      "segmentation fault",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: on perd la valeur originale. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel est le piège avec char signé utilisé comme index?",
    "choices": [
      "impact de performance (plus lent)",
      "overflow",
      "index négatif",
      "fuite"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: index négatif. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), que provoque un prototype différent de l’énoncé?",
    "choices": [
      "avertissement du compilateur",
      "erreur à l'exécution",
      "compilation KO",
      "fuite"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: compilation KO. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec printf quand write est imposé?",
    "choices": [
      "impact de performance (plus lent)",
      "sortie non conforme",
      "interdit",
      "échec de compilation"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: interdit. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi il faut traiter le cas string vide?",
    "choices": [
      "sinon crash",
      "sinon sortie fausse",
      "sinon avertissement compilateur",
      "sinon tri"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: sinon sortie fausse. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège arrive si on free sans unlink?",
    "choices": [
      "fuite",
      "segmentation fault",
      "double free",
      "corruption"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: corruption. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège si on oublie de mettre NULL dans un tableau de strings?",
    "choices": [
      "fuite",
      "parcours infini",
      "échec de compilation",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: parcours infini. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi il faut travailler sur une copie pour compter?",
    "choices": [
      "performance",
      "éviter modifier l’original",
      "question de style uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter modifier l’original. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec while(ptr->next)?",
    "choices": [
      "saute la tête",
      "oublie dernier",
      "segmentation fault",
      "fuite"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: oublie dernier. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec cmp mal utilisé?",
    "choices": [
      "segmentation fault",
      "tri inversé",
      "doublons",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tri inversé. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Que se passe-t-il si on swap les pointeurs au lieu des data dans sort_list sans précaution?",
    "choices": [
      "fuite",
      "casse la liste",
      "impact de performance (plus lent)",
      "aucun effet particulier"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: casse la liste. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi argc doit être strictement vérifié?",
    "choices": [
      "question de style uniquement",
      "sécurité",
      "tests",
      "compilation"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec free(tmp) avant reconnecter?",
    "choices": [
      "fuite",
      "segmentation fault",
      "corruption",
      "aucun effet particulier"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: corruption. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi while(*begin_list) est nécessaire au début?",
    "choices": [
      "performance",
      "question de style uniquement",
      "supprimer plusieurs têtes",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: supprimer plusieurs têtes. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec index mal initialisé?",
    "choices": [
      "fuite",
      "valeur indéfinie",
      "impact de performance (plus lent)",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: valeur indéfinie. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège si on oublie d’initialiser len?",
    "choices": [
      "segmentation fault",
      "fuite",
      "taille aléatoire",
      "échec de compilation"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: taille aléatoire. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi ne pas utiliser des guillemets typographiques?",
    "choices": [
      "question de style uniquement",
      "pas ASCII",
      "échec de compilation",
      "impact de performance (plus lent)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: échec de compilation. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec for(i<=len)?",
    "choices": [
      "saute un",
      "dépasse",
      "boucle infinie",
      "fuite"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: dépasse. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi il faut caster en unsigned char dans union?",
    "choices": [
      "performance",
      "respect de la norme et des contraintes du sujet",
      "sécurité index",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: sécurité index. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège si on affiche trop de texte?",
    "choices": [
      "question de style uniquement",
      "échec de compilation",
      "tests KO",
      "impact de performance (plus lent)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests KO. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi il ne faut pas avancer cur après suppression?",
    "choices": [
      "fuite",
      "sauter un",
      "boucle infinie",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: sauter un. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec return prématuré?",
    "choices": [
      "fuite",
      "question de style uniquement",
      "optimisation",
      "échec de compilation"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: fuite. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec malloc(sizeof(ptr) * n)?",
    "choices": [
      "trop petit",
      "trop grand",
      "impact de performance (plus lent)",
      "segmentation fault"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: trop petit. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec while(str[i]!= '\\n')?",
    "choices": [
      "ignore '\\0'",
      "segmentation fault",
      "fuite",
      "échec de compilation"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: ignore '\\0'. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi ne pas oublier le free dans remove_if?",
    "choices": [
      "question de style uniquement",
      "performance",
      "fuite mémoire",
      "échec de compilation"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: fuite mémoire. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec un tableau global non remis à zéro?",
    "choices": [
      "impact de performance (plus lent)",
      "pollution d’état",
      "segmentation fault",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pollution d’état. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi un include interdit peut faire rater?",
    "choices": [
      "avertissement du compilateur",
      "runtime",
      "règles exam",
      "fuite"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: règles exam. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec strcmp au lieu de comparer chars?",
    "choices": [
      "impact de performance (plus lent)",
      "hors sujet",
      "interdit",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: interdit. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi oublier le cast long peut casser?",
    "choices": [
      "impact de performance (plus lent)",
      "overflow",
      "fuite",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: overflow. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec while(cur) au lieu de while(cur->next) dans remove_if?",
    "choices": [
      "saute tête",
      "impossible supprimer dernier",
      "segmentation fault",
      "fuite"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: impossible supprimer dernier. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec free deux fois?",
    "choices": [
      "fuite",
      "segmentation fault",
      "OK",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: segmentation fault. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), pourquoi oublier de gérer liste vide est dangereux?",
    "choices": [
      "aucun effet particulier",
      "crash",
      "impact de performance (plus lent)",
      "échec de compilation"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: crash. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec printf en exam?",
    "choices": [
      "impact de performance (plus lent)",
      "interdit",
      "sortie non conforme",
      "les deux propositions sont vraies: « interdit » et « sortie non conforme »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « interdit » et « sortie non conforme ». Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel piège avec malloc(1000) “au hasard”?",
    "choices": [
      "fuite",
      "imprécis",
      "tests limites ratés",
      "tout"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: tout. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "pieges",
    "question": "Dans un exercice de C (exam 42), quel est le piège numéro un à l’exam?",
    "choices": [
      "coder lentement",
      "ne pas lire l’énoncé",
      "trop commenter",
      "optimiser"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: ne pas lire l’énoncé. Cette option cible un piège classique d’exam C qui fait échouer les tests même quand le code compile. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pieges"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi écrit-on toujours malloc(len + 1) pour une string?",
    "choices": [
      "performance",
      "'\\n'",
      "'\\0'",
      "sizeof"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: '\\0'. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi utiliser sizeof(type) * n?",
    "choices": [
      "rapidité",
      "lisibilité",
      "octets corrects",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: octets corrects. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, quel est le premier réflexe après malloc?",
    "choices": [
      "écrire dedans",
      "libérer la mémoire avec free",
      "vérifier NULL",
      "memset"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: vérifier NULL. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, quand faut-il free un maillon supprimé?",
    "choices": [
      "avant unlink",
      "après unlink",
      "jamais",
      "à la fin du programme"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: après unlink. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi allouer len + sign + 1 dans itoa?",
    "choices": [
      "padding",
      "'\\0' + '-'",
      "respect de la norme et des contraintes du sujet",
      "vitesse"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: '\\0' + '-'. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que doit contenir la dernière case d’un tableau de strings?",
    "choices": [
      "'\\0'",
      "EOF",
      "NULL",
      "0xFF"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi travailler sur une copie lors d’un comptage?",
    "choices": [
      "performance",
      "ne pas modifier l’original",
      "allouer dynamiquement avec malloc",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: ne pas modifier l’original. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que fait if (!ptr) return NULL?",
    "choices": [
      "fuite",
      "protection",
      "libérer la mémoire avec free",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: protection. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas free avant reconnecter une liste?",
    "choices": [
      "fuite",
      "segmentation fault",
      "corruption",
      "double free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: corruption. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas oublier free après unlink?",
    "choices": [
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "fuite mémoire",
      "compile"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: fuite mémoire. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi caster en long dans itoa?",
    "choices": [
      "vitesse",
      "éviter overflow",
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter overflow. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que risque malloc(sizeof(ptr) * n)?",
    "choices": [
      "trop petit",
      "trop grand",
      "correct",
      "fuite"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: trop petit. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi initialiser len à 0?",
    "choices": [
      "question de style uniquement",
      "éviter valeur indéfinie",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter valeur indéfinie. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi remettre seen[256] à zéro?",
    "choices": [
      "question de style uniquement",
      "performance",
      "éviter pollution",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: éviter pollution. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que doit-on faire après free(ptr)?",
    "choices": [
      "aucun effet particulier",
      "ptr++",
      "ptr = NULL",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ptr = NULL. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi utiliser unsigned char pour indexer?",
    "choices": [
      "vitesse",
      "sécurité",
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: sécurité. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas écrire malloc(1000) “au hasard”?",
    "choices": [
      "impact de performance (plus lent)",
      "imprécis",
      "tests ratés",
      "les deux propositions sont vraies: « imprécis » et « tests ratés »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « imprécis » et « tests ratés ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, quand doit-on free un tableau retourné par split?",
    "choices": [
      "dans split",
      "jamais",
      "appelant",
      "OS"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: appelant. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi vérifier argc?",
    "choices": [
      "respect de la norme et des contraintes du sujet",
      "sécurité mémoire",
      "tests",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: sécurité mémoire. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que provoque une variable non initialisée?",
    "choices": [
      "avertissement du compilateur",
      "valeur indéfinie",
      "fuite",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: valeur indéfinie. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi mettre '\\0' à la fin d’une string?",
    "choices": [
      "affichage",
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "les deux propositions sont vraies: « affichage » et « respect de la norme et des contraintes du sujet »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « affichage » et « respect de la norme et des contraintes du sujet ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi malloc retourne void *?",
    "choices": [
      "casting auto",
      "générique",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: générique. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi vérifier malloc même en exam?",
    "choices": [
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "éviter crash",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: éviter crash. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi on ne free pas argv?",
    "choices": [
      "static",
      "OS",
      "interdit",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: static. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi malloc(sizeof(char) * n) reste recommandé?",
    "choices": [
      "question de style uniquement",
      "portabilité",
      "respect de la norme et des contraintes du sujet",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: portabilité. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi éviter les pointeurs sauvages?",
    "choices": [
      "question de style uniquement",
      "segmentation fault",
      "fuite",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: segmentation fault. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, que se passe-t-il si on oublie de free en boucle?",
    "choices": [
      "crash immédiat",
      "fuite mémoire",
      "question de style uniquement",
      "compile"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: fuite mémoire. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas écrire free(NULL)?",
    "choices": [
      "interdit",
      "crash",
      "inutile mais sûr",
      "impact de performance (plus lent)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: inutile mais sûr. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi séparer allocation et remplissage?",
    "choices": [
      "question de style uniquement",
      "lisibilité",
      "débogage",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi un double pointeur implique vigilance mémoire?",
    "choices": [
      "impact de performance (plus lent)",
      "risque de fuite",
      "modification structure",
      "les deux propositions sont vraies: « modification structure » et « risque de fuite »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « modification structure » et « risque de fuite ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi malloc(sizeof(int)) est insuffisant pour n ints?",
    "choices": [
      "impact de performance (plus lent)",
      "manque de place",
      "question de style uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: manque de place. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi une string doit être terminée avant retour?",
    "choices": [
      "affichage",
      "respect de la norme et des contraintes du sujet",
      "sécurité",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi vérifier la taille inclusive dans range?",
    "choices": [
      "question de style uniquement",
      "off-by-one",
      "libérer la mémoire avec free",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: off-by-one. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi allouer un tableau de pointeurs avant les mots?",
    "choices": [
      "question de style uniquement",
      "pattern",
      "mémoire structurée",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi free après unlink et pas avant?",
    "choices": [
      "fuite",
      "corruption",
      "segmentation fault",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas réutiliser un pointeur free?",
    "choices": [
      "question de style uniquement",
      "segmentation fault",
      "fuite",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: segmentation fault. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi toujours compter avant malloc?",
    "choices": [
      "question de style uniquement",
      "sécurité",
      "taille exacte",
      "les deux propositions sont vraies: « sécurité » et « taille exacte »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « sécurité » et « taille exacte ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi allouer len + 2 pour \"-5\"?",
    "choices": [
      "padding",
      "'-'+ '\\0'",
      "respect de la norme et des contraintes du sujet",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: '-'+ '\\0'. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi un tableau dynamique doit être NULL-terminé?",
    "choices": [
      "affichage",
      "parcours",
      "respect de la norme et des contraintes du sujet",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi éviter de modifier l’argument original?",
    "choices": [
      "question de style uniquement",
      "lisibilité",
      "bug potentiel",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi initialiser les pointeurs?",
    "choices": [
      "question de style uniquement",
      "crash",
      "sécurité",
      "les deux propositions sont vraies: « crash » et « sécurité »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « crash » et « sécurité ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi sizeof(char) est souvent omis?",
    "choices": [
      "toujours 1",
      "respect de la norme et des contraintes du sujet",
      "question de style uniquement",
      "inutile"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: toujours 1. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi tester fin de liste avec NULL?",
    "choices": [
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "sécurité",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi malloc(len) pour une string est faux?",
    "choices": [
      "trop petit",
      "impact de performance (plus lent)",
      "question de style uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: trop petit. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi gérer le cas 0 séparément?",
    "choices": [
      "question de style uniquement",
      "boucle saute",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: boucle saute. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi libérer dans remove_if est obligatoire?",
    "choices": [
      "question de style uniquement",
      "tests",
      "fuite",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: fuite. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi ne pas allouer un buffer fixe?",
    "choices": [
      "impact de performance (plus lent)",
      "imprécis",
      "dangereux",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi utiliser long dans itoa?",
    "choices": [
      "question de style uniquement",
      "overflow",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: overflow. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi remettre à zéro des compteurs?",
    "choices": [
      "question de style uniquement",
      "sécurité",
      "éviter faux calcul",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "reflexes_memoire",
    "question": "En révision mémoire pour l’exam 42, pourquoi vérifier pointeur avant deref?",
    "choices": [
      "question de style uniquement",
      "crash",
      "respect de la norme et des contraintes du sujet",
      "les deux propositions sont vraies: « crash » et « respect de la norme et des contraintes du sujet »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « crash » et « respect de la norme et des contraintes du sujet ». Cette option correspond au bon réflexe mémoire: taille juste, vérification immédiate, et gestion propre des pointeurs. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "reflexes_memoire"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que contient une variable de type `int *p`?",
    "choices": [
      "un entier",
      "une adresse",
      "un tableau",
      "une taille"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: une adresse. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait `*p` si `p` est un pointeur?",
    "choices": [
      "donne l’adresse",
      "modifie p",
      "accède à la valeur pointée",
      "alloue"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: accède à la valeur pointée. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi utiliser `t_list **`?",
    "choices": [
      "parcourir plus vite",
      "modifier la tête",
      "éviter malloc",
      "trier"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: modifier la tête. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle ligne fait avancer dans une liste?",
    "choices": [
      "`cur++`",
      "`*cur = cur->next`",
      "`cur = cur->next`",
      "`cur.next`"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: `cur = cur->next`. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), après `free(ptr)`, que faut-il faire idéalement?",
    "choices": [
      "ptr++",
      "aucun effet particulier",
      "ptr = NULL",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ptr = NULL. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle erreur provoque `*p = NULL` quand p est un pointeur non initialisé?",
    "choices": [
      "question de style uniquement",
      "fuite",
      "segmentation fault",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: segmentation fault. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle est la différence entre `char *s` et `char s[10]`?",
    "choices": [
      "aucune",
      "l’un est dynamique",
      "tableau vs pointeur",
      "vitesse"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tableau vs pointeur. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quand faut-il utiliser un pointeur temporaire `tmp`?",
    "choices": [
      "pour free après unlink",
      "pour printf",
      "pour trier",
      "pour compter"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: pour free après unlink. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quel opérateur permet d’accéder à un champ struct via pointeur?",
    "choices": [
      ".",
      "*",
      "->",
      "&"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ->. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait `&x`?",
    "choices": [
      "copie",
      "valeur",
      "adresse",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: adresse. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quel est le danger d’un pointeur non initialisé?",
    "choices": [
      "impact de performance (plus lent)",
      "fuite",
      "comportement indéfini",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: comportement indéfini. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi ne pas avancer cur après suppression?",
    "choices": [
      "fuite",
      "on saute un élément",
      "segmentation fault",
      "compile"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: on saute un élément. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que signifie dereferencer?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "copier",
      "accéder à la valeur pointée",
      "libérer"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: accéder à la valeur pointée. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle ligne modifie la tête d’une liste?",
    "choices": [
      "`begin = begin->next`",
      "`*begin = (*begin)->next`",
      "`begin++`",
      "`cur->next`"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: `*begin = (*begin)->next`. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quel est le rôle de `NULL` dans un pointeur?",
    "choices": [
      "valeur magique",
      "fin",
      "adresse invalide",
      "les deux propositions sont vraies: « fin » et « adresse invalide »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « fin » et « adresse invalide ». Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi ne pas utiliser un pointeur après free?",
    "choices": [
      "impact de performance (plus lent)",
      "fuite",
      "dangling pointer",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: dangling pointer. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait `p = &x`?",
    "choices": [
      "copie x",
      "pointe sur x",
      "alloue",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pointe sur x. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait `*p = 42`?",
    "choices": [
      "change l’adresse",
      "modifie la valeur pointée",
      "allouer dynamiquement avec malloc",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: modifie la valeur pointée. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle est l’erreur dans `cur = *cur->next`?",
    "choices": [
      "priorité opérateurs",
      "fuite",
      "libérer la mémoire avec free",
      "question de style uniquement"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: priorité opérateurs. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi préférer swap des data plutôt que des liens?",
    "choices": [
      "question de style uniquement",
      "plus simple",
      "rapide",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: plus simple. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait `void *`?",
    "choices": [
      "interdit",
      "pointeur générique",
      "fuite",
      "tableau"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pointeur générique. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quand faut-il vérifier un pointeur avant deref?",
    "choices": [
      "jamais",
      "toujours",
      "en débogage",
      "après free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: toujours. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi argv est un char **?",
    "choices": [
      "tableau dynamique",
      "liste",
      "tableau de strings",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tableau de strings. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quelle ligne est fausse?",
    "choices": [
      "`p = &x;`",
      "`*p = 3;`",
      "`p = malloc(4);`",
      "`*p = malloc(4);`"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: `*p = malloc(4);`. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quel est le danger principal d’un double pointeur?",
    "choices": [
      "impact de performance (plus lent)",
      "fuite",
      "modifier mauvaise adresse",
      "compile"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: modifier mauvaise adresse. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que retourne malloc en cas d’échec?",
    "choices": [
      "0",
      "-1",
      "NULL",
      "errno"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi écrire malloc(sizeof(int) * n)?",
    "choices": [
      "question de style uniquement",
      "octets corrects",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: octets corrects. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi ajouter +1 pour une string?",
    "choices": [
      "'\\n'",
      "'\\0'",
      "padding",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: '\\0'. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), qui doit free la mémoire retournée?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "OS",
      "appelant",
      "compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: appelant. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que provoque malloc(1000) “au hasard”?",
    "choices": [
      "sécurité",
      "imprécision",
      "tests ratés",
      "les deux propositions sont vraies: « imprécision » et « tests ratés »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « imprécision » et « tests ratés ». Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi vérifier le retour de malloc?",
    "choices": [
      "question de style uniquement",
      "éviter crash",
      "respect de la norme et des contraintes du sujet",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter crash. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait free(NULL)?",
    "choices": [
      "segmentation fault",
      "interdit",
      "aucun effet particulier",
      "fuite"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: aucun effet particulier. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi malloc(sizeof(ptr) * n) est souvent faux?",
    "choices": [
      "trop petit",
      "trop grand",
      "impact de performance (plus lent)",
      "OK"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: trop petit. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi ne pas free avant unlink?",
    "choices": [
      "fuite",
      "corruption",
      "segmentation fault",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: corruption. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi allouer tableau de pointeurs avant mots?",
    "choices": [
      "question de style uniquement",
      "pattern",
      "structure",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quand libérer dans remove_if?",
    "choices": [
      "avant",
      "après unlink",
      "jamais",
      "à la fin"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: après unlink. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi malloc(len) pour string est faux?",
    "choices": [
      "trop petit",
      "impact de performance (plus lent)",
      "question de style uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: trop petit. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait realloc?",
    "choices": [
      "libérer la mémoire avec free",
      "agrandit/réduit",
      "copie",
      "malloc+free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: agrandit/réduit. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi éviter fuite mémoire?",
    "choices": [
      "question de style uniquement",
      "crash",
      "consommation",
      "les deux propositions sont vraies: « consommation » et « crash »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « consommation » et « crash ». Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait sizeof(char)?",
    "choices": [
      "dépend",
      "1",
      "4",
      "8"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: 1. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi ne pas allouer buffer fixe?",
    "choices": [
      "impact de performance (plus lent)",
      "imprécis",
      "dangereux",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi vérifier taille inclusive?",
    "choices": [
      "respect de la norme et des contraintes du sujet",
      "off-by-one",
      "question de style uniquement",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: off-by-one. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que devient un pointeur après free?",
    "choices": [
      "valide",
      "dangling",
      "NULL",
      "0"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: dangling. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi mettre ptr = NULL après free?",
    "choices": [
      "question de style uniquement",
      "éviter reuse",
      "respect de la norme et des contraintes du sujet",
      "débogage"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter reuse. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi malloc pour tableau 2D?",
    "choices": [
      "question de style uniquement",
      "dynamique",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: dynamique. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), que fait calloc?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "initialise à zéro",
      "libérer la mémoire avec free",
      "realloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: initialise à zéro. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi séparer allocation et remplissage?",
    "choices": [
      "question de style uniquement",
      "lisibilité",
      "débogage",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi libérer tout en cas d’erreur intermédiaire?",
    "choices": [
      "question de style uniquement",
      "fuite",
      "respect de la norme et des contraintes du sujet",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: fuite. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), pourquoi malloc retourne void *?",
    "choices": [
      "question de style uniquement",
      "générique",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: générique. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Dans un exercice de pointeurs/mémoire en C (exam 42), quel est le réflexe absolu avec malloc?",
    "choices": [
      "écrire",
      "libérer la mémoire avec free",
      "vérifier NULL",
      "cast"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: vérifier NULL. Cette option est cohérente avec la logique pointeurs/malloc: niveau d’indirection, validité d’adresse et sécurité mémoire. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "pointeurs_malloc"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), à quoi sert le champ `next` dans un maillon?",
    "choices": [
      "stocker la donnée",
      "stocker la taille",
      "pointer vers le suivant",
      "allouer"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: pointer vers le suivant. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que signifie `t_list *cur`?",
    "choices": [
      "un maillon",
      "une adresse de maillon",
      "un tableau",
      "une taille"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: une adresse de maillon. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quand utilise-t-on `t_list **begin`?",
    "choices": [
      "pour parcourir",
      "pour modifier la tête",
      "pour afficher",
      "pour trier"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pour modifier la tête. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), comment parcourt-on une liste?",
    "choices": [
      "for(i<n)",
      "while(cur) cur = cur->next",
      "recursion obligatoire",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(cur) cur = cur->next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quelle ligne supprime le maillon suivant?",
    "choices": [
      "free(cur->next)",
      "cur->next = cur->next->next",
      "cur = cur->next",
      "begin = NULL"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: cur->next = cur->next->next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi stocker `tmp = cur->next` avant unlink?",
    "choices": [
      "compter",
      "afficher",
      "free ensuite",
      "trier"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: free ensuite. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que devient la liste après suppression de B? ``` A -> B -> C ```?",
    "choices": [
      "A -> NULL",
      "B -> C",
      "A -> C",
      "A -> B"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: A -> C. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi nettoyer la tête avec une boucle while?",
    "choices": [
      "performance",
      "question de style uniquement",
      "supprimer plusieurs têtes",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: supprimer plusieurs têtes. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), après nettoyage de tête, quel pointeur sert au parcours?",
    "choices": [
      "t_list **",
      "t_list *",
      "int *",
      "char **"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: t_list *. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que se passe-t-il si on avance `cur` juste après suppression?",
    "choices": [
      "aucun effet particulier",
      "fuite",
      "on saute un maillon",
      "crash"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: on saute un maillon. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), comment tester fin de liste?",
    "choices": [
      "cur->next == 0",
      "cur == NULL",
      "libérer la mémoire avec free",
      "break"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: cur == NULL. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), dans remove_if, sur quel élément applique-t-on cmp?",
    "choices": [
      "cur",
      "cur->next",
      "begin",
      "tmp"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: cur->next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quand faut-il free un maillon supprimé?",
    "choices": [
      "avant unlink",
      "après unlink",
      "jamais",
      "à la fin"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: après unlink. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le piège si on free avant reconnecter?",
    "choices": [
      "fuite",
      "segmentation fault",
      "corruption",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: corruption. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que contient `*begin`?",
    "choices": [
      "une adresse",
      "la tête",
      "un tableau",
      "une taille"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: la tête. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quelle ligne fait changer la tête?",
    "choices": [
      "begin = begin->next",
      "*begin = (*begin)->next",
      "cur = cur->next",
      "free(begin)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: *begin = (*begin)->next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi utiliser bubble sort sur liste?",
    "choices": [
      "optimal",
      "simple à implémenter",
      "rapide",
      "récursif"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: simple à implémenter. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que swap-on dans sort_list exam?",
    "choices": [
      "pointeurs",
      "data",
      "allouer dynamiquement avec malloc",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: data. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quand le tri est-il terminé?",
    "choices": [
      "cur == NULL",
      "cmp toujours vrai",
      "swapped == 0",
      "fin premier tour"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: swapped == 0. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que représente une liste vide?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "pointeur NULL",
      "tableau vide",
      "erreur"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pointeur NULL. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi vérifier begin_list avant deref?",
    "choices": [
      "question de style uniquement",
      "crash",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: crash. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le bug de while(cur->next)?",
    "choices": [
      "saute tête",
      "oublie dernier",
      "segmentation fault",
      "fuite"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: oublie dernier. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), comment compter les éléments?",
    "choices": [
      "strlen",
      "while(lst) count++",
      "allouer dynamiquement avec malloc",
      "cmp"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(lst) count++. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi tmp est indispensable?",
    "choices": [
      "question de style uniquement",
      "éviter perdre adresse",
      "free double",
      "trier"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: éviter perdre adresse. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que se passe-t-il si tous les éléments sont supprimés?",
    "choices": [
      "fuite",
      "begin reste",
      "begin devient NULL",
      "crash"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: begin devient NULL. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi passer un double pointeur?",
    "choices": [
      "vitesse",
      "modifier structure",
      "libérer la mémoire avec free",
      "trier"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: modifier structure. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que fait cur = cur->next?",
    "choices": [
      "supprime",
      "avance",
      "libérer la mémoire avec free",
      "copie"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: avance. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi ne pas swap les liens facilement?",
    "choices": [
      "impact de performance (plus lent)",
      "complexe",
      "interdit",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: complexe. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le rôle du dernier maillon?",
    "choices": [
      "stocker",
      "next = NULL",
      "data = NULL",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: next = NULL. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que signifie next == NULL?",
    "choices": [
      "erreur",
      "tête",
      "fin",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: fin. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que se passe-t-il si begin vaut NULL?",
    "choices": [
      "crash",
      "liste vide",
      "avertissement du compilateur",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: liste vide. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi ne pas faire cur++?",
    "choices": [
      "interdit",
      "liste pas contiguë",
      "segmentation fault",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: liste pas contiguë. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel piège avec cur->next->next sans test?",
    "choices": [
      "impact de performance (plus lent)",
      "segmentation fault",
      "fuite",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: segmentation fault. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi utiliser tmp?",
    "choices": [
      "performance",
      "question de style uniquement",
      "libérer après",
      "trier"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: libérer après. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que contient un maillon?",
    "choices": [
      "next uniquement",
      "data uniquement",
      "data + next",
      "taille"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: data + next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel test protège l’accès suivant?",
    "choices": [
      "if(cur)",
      "if(cur->next)",
      "libérer la mémoire avec free",
      "break"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: if(cur->next). Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi une boucle infinie peut arriver?",
    "choices": [
      "libérer la mémoire avec free",
      "next jamais modifié",
      "allouer dynamiquement avec malloc",
      "cmp"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: next jamais modifié. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi ne pas modifier data_ref?",
    "choices": [
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "comparaison",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: comparaison. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que se passe-t-il si cmp est inversé?",
    "choices": [
      "tri faux",
      "crash",
      "fuite",
      "compile"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: tri faux. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi vérifier cur->next avant cmp?",
    "choices": [
      "question de style uniquement",
      "sécurité",
      "respect de la norme et des contraintes du sujet",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: sécurité. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), comment supprimer le premier maillon?",
    "choices": [
      "free(begin)",
      "*begin = (*begin)->next",
      "cur->next = cur->next->next",
      "begin++"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: *begin = (*begin)->next. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi on ne free pas begin directement?",
    "choices": [
      "fuite",
      "perdre accès",
      "impact de performance (plus lent)",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: perdre accès. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), que fait lstsize?",
    "choices": [
      "libérer la mémoire avec free",
      "compter",
      "trier",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: compter. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi next doit être NULL au dernier?",
    "choices": [
      "question de style uniquement",
      "arrêt parcours",
      "respect de la norme et des contraintes du sujet",
      "toutes"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: toutes. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le danger principal des listes?",
    "choices": [
      "lenteur",
      "erreurs pointeurs",
      "allouer dynamiquement avec malloc",
      "question de style uniquement"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: erreurs pointeurs. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi ne pas utiliser récursion en exam?",
    "choices": [
      "question de style uniquement",
      "pile",
      "interdit",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: pile. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quand arrêter remove_if?",
    "choices": [
      "cur == NULL",
      "cur->next == NULL",
      "begin == NULL",
      "swapped"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: cur->next == NULL. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), pourquoi nettoyer la tête d’abord?",
    "choices": [
      "question de style uniquement",
      "absence de précédent",
      "performance",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: absence de précédent. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le pattern universel?",
    "choices": [
      "for",
      "while(ptr)",
      "recursion",
      "goto"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: while(ptr). Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans un exercice de listes chaînées en C (exam 42), quel est le piège le plus courant en listes?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "oublier free",
      "avancer au mauvais moment",
      "question de style uniquement"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: avancer au mauvais moment. Cette option respecte la logique des listes chaînées: ordre des pointeurs, cas tête, et suppression sans perdre de maillon. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "listes_chainees"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans itoa, quel est le cas limite principal?",
    "choices": [
      "1",
      "-5",
      "INT_MIN",
      "42"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: INT_MIN. Cette option couvre explicitement un cas limite attendu par la correction automatique. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire split avec une string vide?",
    "choices": [
      "crash",
      "retourner NULL",
      "retourner tableau avec NULL",
      "afficher"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: retourner tableau avec NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit renvoyer ft_range(0,0)?",
    "choices": [
      "NULL",
      "tableau vide",
      "{0}",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: {0}. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans wdmatch, que faire si argv[1] est vide?",
    "choices": [
      "afficher argv[2]",
      "afficher argv[1]",
      "juste '\\n'",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: afficher argv[1]. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut begin_list si la liste est vide?",
    "choices": [
      "allouer dynamiquement avec malloc",
      "-1",
      "NULL",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans remove_if, si tous les éléments correspondent?",
    "choices": [
      "liste inchangée",
      "begin pointe dernier",
      "begin devient NULL",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: begin devient NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire atoi(\"\")?",
    "choices": [
      "crash",
      "0",
      "-1",
      "comportement indéfini"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: 0. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire split si la string ne contient que des séparateurs?",
    "choices": [
      "NULL",
      "tableau vide",
      "tableau avec NULL",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tableau avec NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), quel est le cas limite d’une liste à un seul élément dans sort_list?",
    "choices": [
      "crash",
      "tri inutile",
      "swap obligatoire",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tri inutile. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire wdmatch si un caractère manque?",
    "choices": [
      "afficher argv[1]",
      "afficher argv[2]",
      "afficher '\\n'",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: afficher '\\n'. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans ft_range(start,end), si start > end?",
    "choices": [
      "NULL",
      "tableau décroissant",
      "segmentation fault",
      "malloc(0)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tableau décroissant. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut len dans itoa(0)?",
    "choices": [
      "0",
      "1",
      "2",
      "-1"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: 1. Cette option couvre explicitement un cas limite attendu par la correction automatique. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que se passe-t-il si begin_list == NULL dans foreach?",
    "choices": [
      "crash",
      "aucun effet particulier",
      "segmentation fault",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: aucun effet particulier. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire remove_if si aucune data ne correspond?",
    "choices": [
      "vider",
      "crash",
      "ne rien changer",
      "free tout"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ne rien changer. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit contenir le tableau retourné par split?",
    "choices": [
      "'\\0'",
      "EOF",
      "NULL final",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL final. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut atoi(\"-0\")?",
    "choices": [
      "0",
      "-0",
      "-1",
      "erreur"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: 0. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans union, que faire avec string vide?",
    "choices": [
      "crash",
      "afficher rien",
      "afficher '\\n'",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: afficher rien. Cette option couvre explicitement un cas limite attendu par la correction automatique. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans itoa, si n = 0?",
    "choices": [
      "NULL",
      "\"0\"",
      "\"\"",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: \"0\". Cette option couvre explicitement un cas limite attendu par la correction automatique. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut *begin si la liste devient vide?",
    "choices": [
      "dernier",
      "allouer dynamiquement avec malloc",
      "NULL",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire ft_range(-3,0)?",
    "choices": [
      "{0,-1,-2,-3}",
      "{-3,-2,-1,0}",
      "NULL",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: {-3,-2,-1,0}. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit afficher un programme si argc est incorrect?",
    "choices": [
      "erreur",
      "aucun effet particulier",
      "'\\n'",
      "exit"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: '\\n'. Cette option couvre explicitement un cas limite attendu par la correction automatique. En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire split si un seul mot sans séparateurs?",
    "choices": [
      "NULL",
      "tableau avec ce mot + NULL",
      "segmentation fault",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tableau avec ce mot + NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans remove_if, si seule la tête correspond?",
    "choices": [
      "supprimer tête",
      "crash",
      "aucun effet particulier",
      "free tout"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: supprimer tête. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que se passe-t-il si une liste n’a qu’un élément et qu’on le supprime?",
    "choices": [
      "begin reste",
      "begin devient NULL",
      "segmentation fault",
      "fuite"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: begin devient NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans sort_list, une liste vide?",
    "choices": [
      "crash",
      "retourner NULL",
      "libérer la mémoire avec free",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: retourner NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire atoi avec espaces au début?",
    "choices": [
      "crash",
      "0",
      "ignorer",
      "erreur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ignorer. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire split avec \"\\n\\t \"?",
    "choices": [
      "NULL",
      "tableau NULL",
      "crash",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tableau NULL. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que se passe-t-il si wdmatch reçoit 3 arguments?",
    "choices": [
      "afficher erreur",
      "ignorer",
      "'\\n'",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: '\\n'. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut ft_range(5,5)?",
    "choices": [
      "NULL",
      "{5}",
      "{}",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: {5}. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire remove_if si begin_list est NULL?",
    "choices": [
      "crash",
      "aucun effet particulier",
      "libérer la mémoire avec free",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: aucun effet particulier. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire split si str == NULL? (si non précisé)?",
    "choices": [
      "crash",
      "retourner NULL",
      "comportement indéfini",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: comportement indéfini. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire atoi avec \"+\"?",
    "choices": [
      "0",
      "erreur",
      "segmentation fault",
      "comportement indéfini"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: comportement indéfini. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que se passe-t-il si seen n’est pas réinitialisé?",
    "choices": [
      "crash",
      "doublons supprimés à tort",
      "fuite",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: doublons supprimés à tort. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut ft_range(-1,-1)?",
    "choices": [
      "NULL",
      "{-1}",
      "{}",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: {-1}. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire sort_list avec 1 élément?",
    "choices": [
      "crash",
      "libérer la mémoire avec free",
      "retourner tel quel",
      "swap"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: retourner tel quel. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans itoa, que vaut \"-1\"?",
    "choices": [
      "impossible",
      "\"-1\"",
      "\"1-\"",
      "\"-01\""
    ],
    "correct": 1,
    "explanation": "Réponse correcte: \"-1\". Cette option couvre explicitement un cas limite attendu par la correction automatique. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire union si aucun caractère commun?",
    "choices": [
      "NULL",
      "afficher rien",
      "afficher '\\n'",
      "segmentation fault"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: afficher rien. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans split, que faire si dernier mot sans séparateur?",
    "choices": [
      "ignorer",
      "perdre mot",
      "ajouter mot",
      "crash"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ajouter mot. Cette option couvre explicitement un cas limite attendu par la correction automatique. Le découpage robuste suit le triptyque: compter, allouer, copier, puis terminer proprement.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans remove_if, si seul dernier correspond?",
    "choices": [
      "ne rien faire",
      "crash",
      "supprimer dernier",
      "free tout"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: supprimer dernier. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire foreach sur liste vide?",
    "choices": [
      "crash",
      "libérer la mémoire avec free",
      "aucun effet particulier",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: aucun effet particulier. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut atoi(\"-2147483648\")?",
    "choices": [
      "overflow",
      "crash",
      "dépend implémentation",
      "comportement indéfini"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: dépend implémentation. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire wdmatch si argv[1] == \"\"?",
    "choices": [
      "afficher rien",
      "afficher \"\\n\"",
      "afficher argv[2]",
      "segmentation fault"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: afficher rien. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut ft_range(0,-3)?",
    "choices": [
      "{0,-1,-2,-3}",
      "{-3,-2,-1,0}",
      "NULL",
      "segmentation fault"
    ],
    "correct": 0,
    "explanation": "Réponse correcte: {0,-1,-2,-3}. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans split, si malloc échoue à mi-chemin?",
    "choices": [
      "continuer",
      "fuite",
      "free ce qui a été alloué",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: free ce qui a été alloué. Cette option couvre explicitement un cas limite attendu par la correction automatique. Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire itoa avec n = 10?",
    "choices": [
      "\"01\"",
      "\"10\"",
      "\"010\"",
      "\"-10\""
    ],
    "correct": 1,
    "explanation": "Réponse correcte: \"10\". Cette option couvre explicitement un cas limite attendu par la correction automatique. Teste les bords (`0`, négatif, `INT_MIN`) pour valider le comportement réel.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), dans remove_if, que faire si begin_list == NULL?",
    "choices": [
      "crash",
      "libérer la mémoire avec free",
      "return",
      "allouer dynamiquement avec malloc"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: return. Cette option couvre explicitement un cas limite attendu par la correction automatique. Sur liste chaînée, traite la tête séparément et fais l’enchaînement unlink puis free.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que doit faire sort_list si tous les éléments sont égaux?",
    "choices": [
      "crash",
      "trier",
      "laisser tel quel",
      "les deux propositions sont vraies: « trier » et « laisser tel quel »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « trier » et « laisser tel quel ». Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que vaut atoi(\" 42\")?",
    "choices": [
      "0",
      "segmentation fault",
      "42",
      "erreur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: 42. Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), que faire si string contient seulement '\\0'?",
    "choices": [
      "crash",
      "un mot",
      "zéro mot",
      "segmentation fault"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: zéro mot. Cette option couvre explicitement un cas limite attendu par la correction automatique. Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "conditions_limites",
    "question": "Pour un cas limite en C (exam 42), pourquoi tester les conditions limites en premier?",
    "choices": [
      "question de style uniquement",
      "gagner du temps",
      "éviter crash",
      "les deux propositions sont vraies: « éviter crash » et « gagner du temps »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « éviter crash » et « gagner du temps ». Cette option couvre explicitement un cas limite attendu par la correction automatique. Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "conditions_limites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si argc est incorrect, que faut-il afficher dans beaucoup d’exos?",
    "choices": [
      "message d’erreur",
      "aucun effet particulier",
      "juste `\\n`",
      "exit(1)"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: juste `\\n`. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que se passe-t-il si le nom du fichier est faux?",
    "choices": [
      "avertissement du compilateur",
      "OK",
      "compilation refusée",
      "erreur à l'exécution"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: compilation refusée. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si write est la seule fonction autorisée, utiliser printf est?",
    "choices": [
      "toléré",
      "impact de performance (plus lent)",
      "interdit",
      "optionnel"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: interdit. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi la sortie doit être *exactement* conforme?",
    "choices": [
      "question de style uniquement",
      "optimisation",
      "tests stricts",
      "lisibilité"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests stricts. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé dit “display a \\n”, cela signifie?",
    "choices": [
      "afficher espace",
      "afficher rien",
      "afficher un retour ligne",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: afficher un retour ligne. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que signifie “Expected files: wdmatch.c”?",
    "choices": [
      "un fichier optionnel",
      "plusieurs fichiers",
      "un seul fichier nommé ainsi",
      "n’importe quel nom"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: un seul fichier nommé ainsi. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que faire si un include n’est pas autorisé?",
    "choices": [
      "l’utiliser quand même",
      "commenter",
      "ne pas l’utiliser",
      "remplacer printf"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: ne pas l’utiliser. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si le prototype ne correspond pas exactement?",
    "choices": [
      "avertissement du compilateur",
      "runtime",
      "échec de compilation",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: échec de compilation. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé dit “Do not turn in list.h”, cela veut dire?",
    "choices": [
      "ne pas l’inclure",
      "l’écrire mais pas rendre",
      "l’ignorer",
      "l’éditer"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: l’écrire mais pas rendre. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si l’énoncé impose une structure, peut-on la modifier?",
    "choices": [
      "oui",
      "oui si mieux",
      "non",
      "parfois"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: non. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si rien n’est précisé sur malloc qui échoue, que faire?",
    "choices": [
      "ignorer",
      "crash",
      "protéger",
      "printf"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: protéger. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que faut-il faire quand une fonction est interdite?",
    "choices": [
      "la cacher",
      "la remplacer",
      "l’utiliser quand même",
      "macro"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: la remplacer. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé ne parle pas d’affichage d’erreur, on affiche?",
    "choices": [
      "un message",
      "stderr",
      "rien ou juste \\n",
      "exit"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: rien ou juste \\n. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si “Inputs will always be consistent”, cela signifie?",
    "choices": [
      "pas de malloc",
      "pas besoin de vérifier pointeurs",
      "pas d’entrées invalides",
      "pas de NULL"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: pas d’entrées invalides. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que signifie “Duplications must remain”?",
    "choices": [
      "supprimer doublons",
      "conserver doublons",
      "trier unique",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: conserver doublons. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si une fonction autorisée n’est pas listée?",
    "choices": [
      "OK",
      "autorisée",
      "interdite",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: interdite. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que faire si argc est différent de ce qui est demandé?",
    "choices": [
      "continuer",
      "segmentation fault",
      "afficher \\n",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: afficher \\n. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand un tableau de strings est attendu, il doit finir par?",
    "choices": [
      "'\\0'",
      "EOF",
      "NULL",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: NULL. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Une chaîne C valide se termine par `\\0`; c’est un point critique de fiabilité.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi ne pas afficher d’espaces en trop?",
    "choices": [
      "question de style uniquement",
      "tests échouent",
      "impact de performance (plus lent)",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tests échouent. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé donne un exemple avec `| cat -e`, ça sert à?",
    "choices": [
      "débogage",
      "montrer caractères invisibles",
      "compiler",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: montrer caractères invisibles. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si on imprime plus que demandé?",
    "choices": [
      "OK",
      "avertissement du compilateur",
      "tests KO",
      "bonus"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests KO. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand une fonction doit retourner un pointeur, on retourne?",
    "choices": [
      "copie",
      "adresse valide",
      "variable locale",
      "NULL"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: adresse valide. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que faire avec une variable locale renvoyée par adresse?",
    "choices": [
      "OK",
      "avertissement du compilateur",
      "interdit",
      "segmentation fault futur"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: segmentation fault futur. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé précise un type exact, on peut le changer?",
    "choices": [
      "oui",
      "oui si logique",
      "non",
      "parfois"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: non. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si l’énoncé n’autorise que malloc, utiliser calloc est?",
    "choices": [
      "OK",
      "mieux",
      "interdit",
      "avertissement du compilateur"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: interdit. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que signifie “You must include list.h but must not turn it in”?",
    "choices": [
      "ignorer",
      "copier",
      "compiler avec, pas rendre",
      "modifier"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: compiler avec, pas rendre. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi ne pas ajouter de debug prints?",
    "choices": [
      "question de style uniquement",
      "tests stricts",
      "impact de performance (plus lent)",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tests stricts. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé demande “returns pointer to first element”?",
    "choices": [
      "dernier",
      "milieu",
      "tête",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tête. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand argc est bon mais argv vide?",
    "choices": [
      "comportement indéfini",
      "traiter normalement",
      "segmentation fault",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: traiter normalement. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que signifie “Allowed functions: write”?",
    "choices": [
      "write + printf",
      "toutes",
      "uniquement write",
      "aucune"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: uniquement write. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé ne mentionne pas free, doit-on libérer?",
    "choices": [
      "jamais",
      "parfois",
      "oui si nécessaire",
      "interdit"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: oui si nécessaire. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi ne pas changer l’ordre d’affichage?",
    "choices": [
      "question de style uniquement",
      "lisibilité",
      "tests",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand une fonction doit afficher et retourner, on?",
    "choices": [
      "affiche seulement",
      "retourne seulement",
      "fait les deux",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: fait les deux. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé parle d’arguments, cela inclut?",
    "choices": [
      "argv[0]",
      "programme",
      "argv[1..]",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: argv[1..]. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si rien n’est dit sur les erreurs internes?",
    "choices": [
      "afficher",
      "ignorer",
      "rester silencieux",
      "exit"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: rester silencieux. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi ne pas utiliser des macros interdites?",
    "choices": [
      "question de style uniquement",
      "respect de la norme et des contraintes du sujet",
      "règles exam",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: règles exam. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand on dit “returns NULL-terminated array”?",
    "choices": [
      "'\\0' final",
      "EOF",
      "pointeur NULL",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: pointeur NULL. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si le sujet dit “do not print anything else”, on?",
    "choices": [
      "ajoute débogage",
      "affiche erreurs",
      "respecte strictement",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: respecte strictement. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé dit “Inputs will always be consistent”, peut-on ignorer argc?",
    "choices": [
      "oui",
      "parfois",
      "non",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: non. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi lire l’énoncé deux fois?",
    "choices": [
      "question de style uniquement",
      "comprendre pièges",
      "impact de performance (plus lent)",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: comprendre pièges. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si l’énoncé demande un retour ligne final, l’oublier provoque?",
    "choices": [
      "avertissement du compilateur",
      "OK",
      "test KO",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: test KO. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand une fonction est interdite, peut-on l’implémenter soi-même?",
    "choices": [
      "non",
      "oui",
      "parfois",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: oui. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé donne un exemple précis, il est?",
    "choices": [
      "indicatif",
      "décoratif",
      "contractuel",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: contractuel. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, si on affiche dans stderr au lieu de stdout?",
    "choices": [
      "OK",
      "mieux",
      "tests KO",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: tests KO. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). En exam 42, la sortie est contractuelle: pas de texte en trop, bon flux, et retour ligne exact.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, que faire si une fonction autorisée est absente?",
    "choices": [
      "inventer",
      "coder autrement",
      "utiliser printf",
      "libérer la mémoire avec free"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: coder autrement. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand un comportement n’est pas précisé?",
    "choices": [
      "inventer",
      "faire ce qu’on veut",
      "rester minimal",
      "libérer la mémoire avec free"
    ],
    "correct": 2,
    "explanation": "Réponse correcte: rester minimal. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi ne pas ajouter de texte explicatif?",
    "choices": [
      "question de style uniquement",
      "tests stricts",
      "impact de performance (plus lent)",
      "respect de la norme et des contraintes du sujet"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: tests stricts. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, quand l’énoncé dit “returns pointer”, renvoyer malloc est?",
    "choices": [
      "faux",
      "correct",
      "interdit",
      "impact de performance (plus lent)"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: correct. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Vérifie toujours la taille allouée, puis `if (!ptr)` avant d’écrire en mémoire.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, pourquoi respecter noms de fonctions?",
    "choices": [
      "question de style uniquement",
      "édition de liens",
      "compilation",
      "les deux propositions sont vraies: « édition de liens » et « compilation »"
    ],
    "correct": 3,
    "explanation": "Réponse correcte: les deux propositions sont vraies: « édition de liens » et « compilation ». Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  },
  {
    "theme": "regles_implicites",
    "question": "Dans les règles implicites de l’exam 42, la règle implicite numéro un à l’exam?",
    "choices": [
      "coder vite",
      "relire l’énoncé",
      "optimiser",
      "commenter"
    ],
    "correct": 1,
    "explanation": "Réponse correcte: relire l’énoncé. Cette option respecte le contrat implicite de l’énoncé (sortie, fonctions autorisées, conformité stricte). Pense à valider aussi le cas vide, le cas minimal, et le cas limite avant de rendre.",
    "tags": [
      "regles_implicites"
    ]
  }
]
