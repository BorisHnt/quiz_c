[
  {
    "theme": "patterns",
    "question": "Quel pattern est utilisé dans ft_split avant d'appeler malloc pour le tableau ?",
    "choices": [
      "remplir -> compter -> terminer",
      "compter -> malloc -> remplir -> terminer",
      "malloc -> remplir -> compter",
      "free -> malloc -> remplir"
    ],
    "correct": 1,
    "explanation": "On compte d'abord pour allouer la taille exacte, puis on remplit.",
    "tags": ["split", "allocation", "pattern"]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern classique est utilisé dans itoa ?",
    "choices": [
      "remplir puis malloc",
      "malloc puis compter",
      "gerer signe -> compter -> malloc -> remplir a l'envers",
      "copier puis trier"
    ],
    "correct": 2,
    "explanation": "Le remplissage se fait souvent de droite a gauche apres le comptage.",
    "tags": ["itoa", "conversion", "pattern"]
  },
  {
    "theme": "patterns",
    "question": "Dans union/inter, quel pattern evite les doublons ?",
    "choices": ["tri", "liste chainee", "tableau seen[256]", "calloc global"],
    "correct": 2,
    "explanation": "seen permet de marquer les caracteres deja affiches.",
    "tags": ["union", "inter", "ascii"]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern sert a ignorer les separateurs ?",
    "choices": ["while(is_sep) avancer", "break direct", "free puis retry", "strlen"],
    "correct": 0,
    "explanation": "On avance tant qu'on est sur un separateur.",
    "tags": ["split", "parsing"]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern indique la fin d'un tri bubble sort ?",
    "choices": ["i == n", "cmp == 0", "swapped == 0", "cur == NULL"],
    "correct": 2,
    "explanation": "Si aucun swap n'a eu lieu, le tri est termine.",
    "tags": ["sort", "list"]
  },
  {
    "theme": "patterns",
    "question": "Quel pattern est commun aux parcours robustes ?",
    "choices": ["condition + avancement", "malloc + free", "goto + break", "printf + return"],
    "correct": 0,
    "explanation": "Une boucle fiable teste la condition et avance systematiquement.",
    "tags": ["loop", "parcours"]
  },

  {
    "theme": "pieges",
    "question": "Quel oubli provoque souvent un depassement lors d'une copie de string ?",
    "choices": ["sizeof", "terminateur nul", "argc", "free"],
    "correct": 1,
    "explanation": "Sans terminateur nul, les fonctions string depassent la zone allouee.",
    "tags": ["string", "overflow"]
  },
  {
    "theme": "pieges",
    "question": "En exam, que faut-il afficher quand argc est incorrect ?",
    "choices": ["message detaille", "rien", "seulement newline", "exit(1)"],
    "correct": 2,
    "explanation": "Les tests attendent generalement uniquement un retour ligne.",
    "tags": ["exam", "output"]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi seen[256] doit etre indexe avec unsigned char ?",
    "choices": ["style", "eviter indices negatifs", "performance", "norme 42"],
    "correct": 1,
    "explanation": "Avec char signe, certaines valeurs peuvent devenir negatives.",
    "tags": ["ascii", "index"]
  },
  {
    "theme": "pieges",
    "question": "Que se passe-t-il si on ne traite pas INT_MIN dans itoa ?",
    "choices": ["warning", "overflow", "fuite", "rien"],
    "correct": 1,
    "explanation": "La negation de INT_MIN depasse la plage int.",
    "tags": ["itoa", "int_min"]
  },
  {
    "theme": "pieges",
    "question": "Pourquoi dst[i] = \"\\0\" est faux ?",
    "choices": ["chaine trop longue", "type incorrect", "malloc invalide", "free manquant"],
    "correct": 1,
    "explanation": "\"\\0\" est une chaine, pas un caractere. Il faut '\\0'.",
    "tags": ["string", "syntaxe"]
  },
  {
    "theme": "pieges",
    "question": "Quel piege avec for(i <= len) ?",
    "choices": ["boucle saute", "depassement", "tri inverse", "aucun"],
    "correct": 1,
    "explanation": "La borne <= len ecrit hors limites si len est la taille utile.",
    "tags": ["off_by_one", "loop"]
  },

  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi malloc(len + 1) pour une string ?",
    "choices": ["pour newline", "pour style", "pour terminateur nul", "pour alignement"],
    "correct": 2,
    "explanation": "Il faut la place pour les caracteres et le '\\0'.",
    "tags": ["malloc", "string"]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Quel est le premier reflexe apres malloc ?",
    "choices": ["ecrire", "free", "verifier NULL", "trier"],
    "correct": 2,
    "explanation": "Toujours verifier l'echec d'allocation avant usage.",
    "tags": ["malloc", "safety"]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Qui doit free une allocation retournee par une fonction ?",
    "choices": ["la fonction allocatrice", "le compilateur", "l'appelant", "le noyau"],
    "correct": 2,
    "explanation": "Le code qui recoit la ressource en devient responsable.",
    "tags": ["ownership", "free"]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi separer allocation et remplissage ?",
    "choices": ["aucune raison", "lisibilite et debug", "interdit de suite", "pour eviter while"],
    "correct": 1,
    "explanation": "La separation simplifie la verification et les erreurs intermediaires.",
    "tags": ["pattern", "robustesse"]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Quel reflexe apres free(ptr) ?",
    "choices": ["ptr++", "ptr = NULL", "malloc immediat", "rien"],
    "correct": 1,
    "explanation": "Remettre a NULL limite les reutilisations invalides.",
    "tags": ["free", "dangling"]
  },
  {
    "theme": "reflexes_memoire",
    "question": "Pourquoi compter avant malloc ?",
    "choices": ["style", "taille exacte", "pour eviter if", "pour eviter strlen"],
    "correct": 1,
    "explanation": "On evite les buffers arbitraires et les depassements.",
    "tags": ["allocation", "counting"]
  },

  {
    "theme": "pointeurs_malloc",
    "question": "Que contient une variable int *p ?",
    "choices": ["un int", "une adresse", "un tableau", "une taille"],
    "correct": 1,
    "explanation": "Un pointeur stocke une adresse memoire.",
    "tags": ["pointeur", "base"]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que fait *p ?",
    "choices": ["donne l'adresse", "modifie p", "accede a la valeur pointee", "alloue"],
    "correct": 2,
    "explanation": "La dereference lit/ecrit la valeur ciblee.",
    "tags": ["dereference"]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi utiliser t_list **begin ?",
    "choices": ["pour aller plus vite", "pour modifier la tete", "pour trier", "pour eviter malloc"],
    "correct": 1,
    "explanation": "Il faut un double pointeur pour changer la tete depuis la fonction.",
    "tags": ["list", "double_pointer"]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Que retourne malloc en cas d'echec ?",
    "choices": ["0", "-1", "NULL", "errno"],
    "correct": 2,
    "explanation": "Le standard C definit un retour NULL.",
    "tags": ["malloc", "error"]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Pourquoi malloc(sizeof(ptr) * n) est souvent faux ?",
    "choices": ["trop petit", "trop grand", "interdit", "toujours juste"],
    "correct": 0,
    "explanation": "sizeof(ptr) mesure le pointeur, pas le type pointe.",
    "tags": ["sizeof", "allocation"]
  },
  {
    "theme": "pointeurs_malloc",
    "question": "Quel est le reflexe absolu avec malloc ?",
    "choices": ["caster", "verifier NULL", "free immediat", "incrementer"],
    "correct": 1,
    "explanation": "Sans ce test, on risque un crash a la premiere dereference.",
    "tags": ["malloc", "safety"]
  },

  {
    "theme": "listes_chainees",
    "question": "A quoi sert le champ next d'un maillon ?",
    "choices": ["stocker data", "stocker taille", "pointer le suivant", "allouer"],
    "correct": 2,
    "explanation": "next chaine les maillons entre eux.",
    "tags": ["list", "next"]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel pattern de parcours est correct ?",
    "choices": ["for(i<n)", "while(cur) cur = cur->next", "cur++", "malloc"],
    "correct": 1,
    "explanation": "Les listes ne sont pas contigues en memoire.",
    "tags": ["list", "parcours"]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi stocker tmp = cur->next avant unlink ?",
    "choices": ["pour trier", "pour conserver l'adresse a free", "pour compter", "pour printf"],
    "correct": 1,
    "explanation": "Sinon l'adresse du maillon retire peut etre perdue.",
    "tags": ["remove_if", "free"]
  },
  {
    "theme": "listes_chainees",
    "question": "Dans remove_if, pourquoi traiter la tete avec une boucle while ?",
    "choices": ["style", "performance", "plusieurs tetes consecutives", "pour le tri"],
    "correct": 2,
    "explanation": "On peut avoir plusieurs premiers maillons a supprimer.",
    "tags": ["remove_if", "head"]
  },
  {
    "theme": "listes_chainees",
    "question": "Quel etat represente une liste vide ?",
    "choices": ["node->next == 0", "begin == NULL", "size == -1", "malloc(0)"],
    "correct": 1,
    "explanation": "La tete vaut NULL quand il n'y a aucun maillon.",
    "tags": ["list", "null"]
  },
  {
    "theme": "listes_chainees",
    "question": "Pourquoi bubble sort est souvent choisi en exam sur liste ?",
    "choices": ["optimal", "plus simple a coder", "obligatoire", "sans boucle"],
    "correct": 1,
    "explanation": "Il est facile a implementer rapidement sous pression.",
    "tags": ["sort", "exam"]
  },

  {
    "theme": "conditions_limites",
    "question": "Quel cas limite principal doit etre gere dans itoa ?",
    "choices": ["n=1", "n=-5", "INT_MIN", "n=42"],
    "correct": 2,
    "explanation": "INT_MIN ne peut pas etre negue en int sans overflow.",
    "tags": ["itoa", "int_min"]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit retourner split sur string vide ?",
    "choices": ["NULL", "tableau avec NULL final", "segfault", "un mot vide"],
    "correct": 1,
    "explanation": "Le conteneur existe mais ne contient aucun mot.",
    "tags": ["split", "edge_case"]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit renvoyer ft_range(0, 0) ?",
    "choices": ["NULL", "tableau vide", "{0}", "segfault"],
    "correct": 2,
    "explanation": "La plage inclusive contient un seul element.",
    "tags": ["range", "edge_case"]
  },
  {
    "theme": "conditions_limites",
    "question": "Que doit faire wdmatch si un caractere manque ?",
    "choices": ["afficher argv[1]", "afficher argv[2]", "afficher seulement newline", "segfault"],
    "correct": 2,
    "explanation": "Aucune correspondance complete, donc sortie vide + newline.",
    "tags": ["wdmatch", "output"]
  },
  {
    "theme": "conditions_limites",
    "question": "Que devient begin_list si tous les elements sont supprimes ?",
    "choices": ["reste identique", "pointe le dernier", "devient NULL", "segfault"],
    "correct": 2,
    "explanation": "La liste est vide apres suppression totale.",
    "tags": ["list", "remove_if"]
  },
  {
    "theme": "conditions_limites",
    "question": "Pourquoi traiter le cas 0 a part dans certains comptages ?",
    "choices": ["pour aller plus vite", "sinon la boucle while(n) est sautee", "pour trier", "pour eviter malloc"],
    "correct": 1,
    "explanation": "while(n) ne passe pas quand n == 0.",
    "tags": ["itoa", "counting"]
  },

  {
    "theme": "regles_implicites",
    "question": "Si argc est incorrect en exam, quelle sortie est souvent attendue ?",
    "choices": ["message explicatif", "rien", "juste newline", "exit(1)"],
    "correct": 2,
    "explanation": "Les sujets attendent une sortie minimale strictement precisee.",
    "tags": ["exam", "output"]
  },
  {
    "theme": "regles_implicites",
    "question": "Si write est seule autorisee, printf est :",
    "choices": ["tolere", "plus lent", "interdit", "equivalent"],
    "correct": 2,
    "explanation": "Une fonction hors liste fait echouer la correction.",
    "tags": ["allowed_functions", "exam"]
  },
  {
    "theme": "regles_implicites",
    "question": "Pourquoi la sortie doit etre exactement conforme ?",
    "choices": ["style", "tests stricts", "performance", "debug"],
    "correct": 1,
    "explanation": "Les tests comparent caractere par caractere.",
    "tags": ["tests", "output"]
  },
  {
    "theme": "regles_implicites",
    "question": "Si le prototype ne correspond pas exactement a l'enonce :",
    "choices": ["warning seulement", "runtime only", "compilation/liaison KO", "aucun impact"],
    "correct": 2,
    "explanation": "Le correcteur compile avec le prototype attendu.",
    "tags": ["prototype", "compilation"]
  },
  {
    "theme": "regles_implicites",
    "question": "Quand une fonction est interdite, la bonne strategie est :",
    "choices": ["l'utiliser quand meme", "la remplacer par une version perso", "la cacher", "ignorer l'exo"],
    "correct": 1,
    "explanation": "Tu dois reimplementer le besoin avec les fonctions autorisees.",
    "tags": ["constraints", "exam"]
  },
  {
    "theme": "regles_implicites",
    "question": "La regle implicite numero un en exam est :",
    "choices": ["coder vite", "relire l'enonce", "optimiser", "commenter beaucoup"],
    "correct": 1,
    "explanation": "La plupart des erreurs viennent d'une lecture partielle du sujet.",
    "tags": ["exam", "method"]
  }
]
