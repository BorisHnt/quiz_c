CARD 001 — Patterns

Face :
ft_split : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : ignorer les séparateurs avant de marquer un mot
• Ordre de travail : compter les mots avant toute allocation
• Plan de sortie mémoire : allouer (words + 1) pointeurs puis chaque mot en len + 1
• Validation finale : poser tab[word_count] = NULL avant return

---
CARD 002 — Patterns

Face :
ft_split : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : compter les mots avant toute allocation
• Chemin d’échec prêt : free les mots déjà alloués, free le tableau, return NULL
• Parcours maîtrisé : avancer index caractère sans sauter le dernier mot
• Retour conforme : poser tab[word_count] = NULL avant return

---
CARD 003 — Patterns

Face :
ft_range : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : définir step à +1 ou -1 selon start/end
• Ordre de travail : calculer size = abs(end - start) + 1
• Plan de sortie mémoire : malloc(size * sizeof(int))
• Validation finale : retourner le pointeur de base, jamais un pointeur avancé

---
CARD 004 — Patterns

Face :
ft_range : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : calculer size = abs(end - start) + 1
• Chemin d’échec prêt : if (!arr) return NULL immédiatement
• Parcours maîtrisé : écrire arr[i], puis value += step
• Retour conforme : retourner le pointeur de base, jamais un pointeur avancé

---
CARD 005 — Patterns

Face :
ft_list_remove_if : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : tester begin_list et *begin_list avant déréférence
• Ordre de travail : nettoyer la tête avec while(*begin_list && cmp(...) == 0)
• Plan de sortie mémoire : aucun malloc, suppression en place
• Validation finale : laisser *begin_list cohérent après toutes suppressions

---
CARD 006 — Patterns

Face :
ft_list_remove_if : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : nettoyer la tête avec while(*begin_list && cmp(...) == 0)
• Chemin d’échec prêt : si liste vide, return sans toucher aux pointeurs
• Parcours maîtrisé : tmp = cur->next, unlink, free(tmp), puis décider si cur avance
• Retour conforme : laisser *begin_list cohérent après toutes suppressions

---
CARD 007 — Patterns

Face :
sort_list : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : si la liste est vide ou à un maillon, return lst
• Ordre de travail : boucler tant que swapped == 1
• Plan de sortie mémoire : aucun malloc, tri en place
• Validation finale : arrêter après un passage complet sans swap

---
CARD 008 — Patterns

Face :
sort_list : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : boucler tant que swapped == 1
• Chemin d’échec prêt : si cmp est instable, ne pas casser les liens
• Parcours maîtrisé : swap data avec tmp, pas les liens des maillons
• Retour conforme : arrêter après un passage complet sans swap

---
CARD 009 — Patterns

Face :
itoa : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : gérer explicitement le cas n == 0
• Ordre de travail : caster n en long avant traitement du signe
• Plan de sortie mémoire : malloc(digits + sign + 1)
• Validation finale : poser str[len] = '\0' avant return

---
CARD 010 — Patterns

Face :
itoa : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : caster n en long avant traitement du signe
• Chemin d’échec prêt : if (!str) return NULL
• Parcours maîtrisé : remplir depuis la fin puis placer le signe
• Retour conforme : poser str[len] = '\0' avant return

---
CARD 011 — Patterns

Face :
wdmatch : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : if (argc != 3) écrire uniquement un retour ligne
• Ordre de travail : parcourir argv[2] et avancer argv[1] uniquement en cas de match
• Plan de sortie mémoire : aucun malloc dans la solution standard
• Validation finale : afficher argv[1] seulement si tout est consommé dans l’ordre

---
CARD 012 — Patterns

Face :
wdmatch : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : parcourir argv[2] et avancer argv[1] uniquement en cas de match
• Chemin d’échec prêt : si un caractère manque, ne pas afficher argv[1]
• Parcours maîtrisé : i2 avance toujours, i1 avance seulement sur match
• Retour conforme : afficher argv[1] seulement si tout est consommé dans l’ordre

---
CARD 013 — Patterns

Face :
union : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : caster chaque char en unsigned char avant indexation
• Ordre de travail : utiliser seen[256] initialisé à 0
• Plan de sortie mémoire : aucun malloc, tableau local seen
• Validation finale : écrire un caractère inédit une seule fois

---
CARD 014 — Patterns

Face :
union : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : utiliser seen[256] initialisé à 0
• Chemin d’échec prêt : argc invalide, écrire un retour ligne et sortir
• Parcours maîtrisé : parcourir la première string puis la seconde
• Retour conforme : écrire un caractère inédit une seule fois

---
CARD 015 — Patterns

Face :
atoi : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : arrêter au premier caractère non numérique
• Ordre de travail : ignorer espaces, lire signe, accumuler chiffre par chiffre
• Plan de sortie mémoire : aucun malloc nécessaire
• Validation finale : return sign * result sans affichage

---
CARD 016 — Patterns

Face :
atoi : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : ignorer espaces, lire signe, accumuler chiffre par chiffre
• Chemin d’échec prêt : entrée vide ou signe seul, retourner la valeur prévue par le sujet
• Parcours maîtrisé : incrémenter l’index dans toutes les branches de lecture
• Retour conforme : return sign * result sans affichage

---
CARD 017 — Patterns

Face :
last_word : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : if (argc != 2), écrire seulement un retour ligne
• Ordre de travail : aller en fin de string puis reculer sur séparateurs
• Plan de sortie mémoire : aucun malloc, affichage direct
• Validation finale : écrire exactement le dernier mot puis un retour ligne

---
CARD 018 — Patterns

Face :
last_word : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : aller en fin de string puis reculer sur séparateurs
• Chemin d’échec prêt : si aucun mot trouvé, écrire seulement un retour ligne
• Parcours maîtrisé : reculer jusqu’au début du mot puis afficher le segment
• Retour conforme : écrire exactement le dernier mot puis un retour ligne

---
CARD 019 — Patterns

Face :
inter : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?

Dos :
• Commencer par la garde d’entrée : if (argc != 3), sortie minimale avec retour ligne
• Ordre de travail : vérifier l’appartenance dans argv[2] avant d’afficher
• Plan de sortie mémoire : aucun malloc, logique en parcours
• Validation finale : n’afficher chaque caractère commun qu’une seule fois

---
CARD 020 — Patterns

Face :
inter : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?

Dos :
• Action clé : vérifier l’appartenance dans argv[2] avant d’afficher
• Chemin d’échec prêt : pas de caractère commun, afficher seulement un retour ligne
• Parcours maîtrisé : parcourir argv[1], scanner argv[2], marquer les déjà affichés
• Retour conforme : n’afficher chaque caractère commun qu’une seule fois

---
CARD 021 — Pièges

Face :
ft_split : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier poser tab[word_count] = null avant return
• Vérification prioritaire : ignorer les séparateurs avant de marquer un mot
• Ordre sûr : avancer index caractère sans sauter le dernier mot
• Si erreur : free les mots déjà alloués, free le tableau, return NULL

---
CARD 022 — Pièges

Face :
ft_split : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : string vide ou composée uniquement de séparateurs
• Confirmer la garde : ignorer les séparateurs avant de marquer un mot
• Contrôler la sortie exacte : poser tab[word_count] = NULL avant return
• Écarter les effets de bord : avancer index caractère sans sauter le dernier mot

---
CARD 023 — Pièges

Face :
ft_range : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier retourner le pointeur de base, jamais un pointeur avancé
• Vérification prioritaire : définir step à +1 ou -1 selon start/end
• Ordre sûr : écrire arr[i], puis value += step
• Si erreur : if (!arr) return NULL immédiatement

---
CARD 024 — Pièges

Face :
ft_range : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : start == end doit retourner un tableau de taille 1
• Confirmer la garde : définir step à +1 ou -1 selon start/end
• Contrôler la sortie exacte : retourner le pointeur de base, jamais un pointeur avancé
• Écarter les effets de bord : écrire arr[i], puis value += step

---
CARD 025 — Pièges

Face :
ft_list_remove_if : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier laisser *begin_list cohérent après toutes suppressions
• Vérification prioritaire : tester begin_list et *begin_list avant déréférence
• Ordre sûr : tmp = cur->next, unlink, free(tmp), puis décider si cur avance
• Si erreur : si liste vide, return sans toucher aux pointeurs

---
CARD 026 — Pièges

Face :
ft_list_remove_if : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : plusieurs suppressions consécutives
• Confirmer la garde : tester begin_list et *begin_list avant déréférence
• Contrôler la sortie exacte : laisser *begin_list cohérent après toutes suppressions
• Écarter les effets de bord : tmp = cur->next, unlink, free(tmp), puis décider si cur avance

---
CARD 027 — Pièges

Face :
sort_list : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier arrêter après un passage complet sans swap
• Vérification prioritaire : si la liste est vide ou à un maillon, return lst
• Ordre sûr : swap data avec tmp, pas les liens des maillons
• Si erreur : si cmp est instable, ne pas casser les liens

---
CARD 028 — Pièges

Face :
sort_list : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : liste vide, liste à un maillon, éléments égaux
• Confirmer la garde : si la liste est vide ou à un maillon, return lst
• Contrôler la sortie exacte : arrêter après un passage complet sans swap
• Écarter les effets de bord : swap data avec tmp, pas les liens des maillons

---
CARD 029 — Pièges

Face :
itoa : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier poser str[len] = '\0' avant return
• Vérification prioritaire : gérer explicitement le cas n == 0
• Ordre sûr : remplir depuis la fin puis placer le signe
• Si erreur : if (!str) return NULL

---
CARD 030 — Pièges

Face :
itoa : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : INT_MIN doit rester correct sans overflow
• Confirmer la garde : gérer explicitement le cas n == 0
• Contrôler la sortie exacte : poser str[len] = '\0' avant return
• Écarter les effets de bord : remplir depuis la fin puis placer le signe

---
CARD 031 — Pièges

Face :
wdmatch : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier afficher argv[1] seulement si tout est consommé dans l’ordre
• Vérification prioritaire : if (argc != 3) écrire uniquement un retour ligne
• Ordre sûr : i2 avance toujours, i1 avance seulement sur match
• Si erreur : si un caractère manque, ne pas afficher argv[1]

---
CARD 032 — Pièges

Face :
wdmatch : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : argv[1] vide doit être géré proprement
• Confirmer la garde : if (argc != 3) écrire uniquement un retour ligne
• Contrôler la sortie exacte : afficher argv[1] seulement si tout est consommé dans l’ordre
• Écarter les effets de bord : i2 avance toujours, i1 avance seulement sur match

---
CARD 033 — Pièges

Face :
union : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier écrire un caractère inédit une seule fois
• Vérification prioritaire : caster chaque char en unsigned char avant indexation
• Ordre sûr : parcourir la première string puis la seconde
• Si erreur : argc invalide, écrire un retour ligne et sortir

---
CARD 034 — Pièges

Face :
union : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : char signé négatif sur caractères étendus
• Confirmer la garde : caster chaque char en unsigned char avant indexation
• Contrôler la sortie exacte : écrire un caractère inédit une seule fois
• Écarter les effets de bord : parcourir la première string puis la seconde

---
CARD 035 — Pièges

Face :
atoi : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier return sign * result sans affichage
• Vérification prioritaire : arrêter au premier caractère non numérique
• Ordre sûr : incrémenter l’index dans toutes les branches de lecture
• Si erreur : entrée vide ou signe seul, retourner la valeur prévue par le sujet

---
CARD 036 — Pièges

Face :
atoi : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : gérer correctement -0 et les espaces initiaux
• Confirmer la garde : arrêter au premier caractère non numérique
• Contrôler la sortie exacte : return sign * result sans affichage
• Écarter les effets de bord : incrémenter l’index dans toutes les branches de lecture

---
CARD 037 — Pièges

Face :
last_word : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier écrire exactement le dernier mot puis un retour ligne
• Vérification prioritaire : if (argc != 2), écrire seulement un retour ligne
• Ordre sûr : reculer jusqu’au début du mot puis afficher le segment
• Si erreur : si aucun mot trouvé, écrire seulement un retour ligne

---
CARD 038 — Pièges

Face :
last_word : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : espaces et tabulations en fin de chaîne
• Confirmer la garde : if (argc != 2), écrire seulement un retour ligne
• Contrôler la sortie exacte : écrire exactement le dernier mot puis un retour ligne
• Écarter les effets de bord : reculer jusqu’au début du mot puis afficher le segment

---
CARD 039 — Pièges

Face :
inter : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?

Dos :
• Piège fréquent : oublier n’afficher chaque caractère commun qu’une seule fois
• Vérification prioritaire : if (argc != 3), sortie minimale avec retour ligne
• Ordre sûr : parcourir argv[1], scanner argv[2], marquer les déjà affichés
• Si erreur : pas de caractère commun, afficher seulement un retour ligne

---
CARD 040 — Pièges

Face :
inter : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?

Dos :
• Rejouer le cas limite : doublons multiples dans argv[1]
• Confirmer la garde : if (argc != 3), sortie minimale avec retour ligne
• Contrôler la sortie exacte : n’afficher chaque caractère commun qu’une seule fois
• Écarter les effets de bord : parcourir argv[1], scanner argv[2], marquer les déjà affichés

---
CARD 041 — Réflexes mémoire

Face :
ft_split : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : allouer (words + 1) pointeurs puis chaque mot en len + 1
• Test immédiat : free les mots déjà alloués, free le tableau, return NULL
• Contrat de libération : appelant responsable du free
• Sortie sûre : poser tab[word_count] = NULL avant return

---
CARD 042 — Réflexes mémoire

Face :
ft_split : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : free les mots déjà alloués, free le tableau, return NULL
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 043 — Réflexes mémoire

Face :
ft_range : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : malloc(size * sizeof(int))
• Test immédiat : if (!arr) return NULL immédiatement
• Contrat de libération : appelant responsable du free
• Sortie sûre : retourner le pointeur de base, jamais un pointeur avancé

---
CARD 044 — Réflexes mémoire

Face :
ft_range : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : if (!arr) return NULL immédiatement
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 045 — Réflexes mémoire

Face :
ft_list_remove_if : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc, suppression en place
• Test immédiat : si liste vide, return sans toucher aux pointeurs
• Contrat de libération : appelant responsable du free
• Sortie sûre : laisser *begin_list cohérent après toutes suppressions

---
CARD 046 — Réflexes mémoire

Face :
ft_list_remove_if : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : si liste vide, return sans toucher aux pointeurs
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 047 — Réflexes mémoire

Face :
sort_list : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc, tri en place
• Test immédiat : si cmp est instable, ne pas casser les liens
• Contrat de libération : appelant responsable du free
• Sortie sûre : arrêter après un passage complet sans swap

---
CARD 048 — Réflexes mémoire

Face :
sort_list : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : si cmp est instable, ne pas casser les liens
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 049 — Réflexes mémoire

Face :
itoa : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : malloc(digits + sign + 1)
• Test immédiat : if (!str) return NULL
• Contrat de libération : appelant responsable du free
• Sortie sûre : poser str[len] = '\0' avant return

---
CARD 050 — Réflexes mémoire

Face :
itoa : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : if (!str) return NULL
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 051 — Réflexes mémoire

Face :
wdmatch : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc dans la solution standard
• Test immédiat : si un caractère manque, ne pas afficher argv[1]
• Contrat de libération : appelant responsable du free
• Sortie sûre : afficher argv[1] seulement si tout est consommé dans l’ordre

---
CARD 052 — Réflexes mémoire

Face :
wdmatch : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : si un caractère manque, ne pas afficher argv[1]
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 053 — Réflexes mémoire

Face :
union : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc, tableau local seen
• Test immédiat : argc invalide, écrire un retour ligne et sortir
• Contrat de libération : appelant responsable du free
• Sortie sûre : écrire un caractère inédit une seule fois

---
CARD 054 — Réflexes mémoire

Face :
union : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : argc invalide, écrire un retour ligne et sortir
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 055 — Réflexes mémoire

Face :
atoi : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc nécessaire
• Test immédiat : entrée vide ou signe seul, retourner la valeur prévue par le sujet
• Contrat de libération : appelant responsable du free
• Sortie sûre : return sign * result sans affichage

---
CARD 056 — Réflexes mémoire

Face :
atoi : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : entrée vide ou signe seul, retourner la valeur prévue par le sujet
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 057 — Réflexes mémoire

Face :
last_word : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc, affichage direct
• Test immédiat : si aucun mot trouvé, écrire seulement un retour ligne
• Contrat de libération : appelant responsable du free
• Sortie sûre : écrire exactement le dernier mot puis un retour ligne

---
CARD 058 — Réflexes mémoire

Face :
last_word : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : si aucun mot trouvé, écrire seulement un retour ligne
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 059 — Réflexes mémoire

Face :
inter : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?

Dos :
• Allocation exacte : aucun malloc, logique en parcours
• Test immédiat : pas de caractère commun, afficher seulement un retour ligne
• Contrat de libération : appelant responsable du free
• Sortie sûre : n’afficher chaque caractère commun qu’une seule fois

---
CARD 060 — Réflexes mémoire

Face :
inter : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?

Dos :
• Ne jamais continuer après échec : pas de caractère commun, afficher seulement un retour ligne
• Libérer ce qui est déjà possédé
• Ne pas free une zone jamais allouée
• Retourner NULL de façon explicite

---
CARD 061 — Pointeurs

Face :
ft_split : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : ignorer les séparateurs avant de marquer un mot
• Avancer selon la règle : avancer index caractère sans sauter le dernier mot
• Éviter toute adresse locale au return

---
CARD 062 — Pointeurs

Face :
ft_split : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : poser tab[word_count] = NULL avant return

---
CARD 063 — Pointeurs

Face :
ft_range : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : définir step à +1 ou -1 selon start/end
• Avancer selon la règle : écrire arr[i], puis value += step
• Éviter toute adresse locale au return

---
CARD 064 — Pointeurs

Face :
ft_range : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : retourner le pointeur de base, jamais un pointeur avancé

---
CARD 065 — Pointeurs

Face :
ft_list_remove_if : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : tester begin_list et *begin_list avant déréférence
• Avancer selon la règle : tmp = cur->next, unlink, free(tmp), puis décider si cur avance
• Éviter toute adresse locale au return

---
CARD 066 — Pointeurs

Face :
ft_list_remove_if : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : laisser *begin_list cohérent après toutes suppressions

---
CARD 067 — Pointeurs

Face :
sort_list : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : si la liste est vide ou à un maillon, return lst
• Avancer selon la règle : swap data avec tmp, pas les liens des maillons
• Éviter toute adresse locale au return

---
CARD 068 — Pointeurs

Face :
sort_list : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : arrêter après un passage complet sans swap

---
CARD 069 — Pointeurs

Face :
itoa : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : gérer explicitement le cas n == 0
• Avancer selon la règle : remplir depuis la fin puis placer le signe
• Éviter toute adresse locale au return

---
CARD 070 — Pointeurs

Face :
itoa : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : poser str[len] = '\0' avant return

---
CARD 071 — Pointeurs

Face :
wdmatch : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : if (argc != 3) écrire uniquement un retour ligne
• Avancer selon la règle : i2 avance toujours, i1 avance seulement sur match
• Éviter toute adresse locale au return

---
CARD 072 — Pointeurs

Face :
wdmatch : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : afficher argv[1] seulement si tout est consommé dans l’ordre

---
CARD 073 — Pointeurs

Face :
union : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : caster chaque char en unsigned char avant indexation
• Avancer selon la règle : parcourir la première string puis la seconde
• Éviter toute adresse locale au return

---
CARD 074 — Pointeurs

Face :
union : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : écrire un caractère inédit une seule fois

---
CARD 075 — Pointeurs

Face :
atoi : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : arrêter au premier caractère non numérique
• Avancer selon la règle : incrémenter l’index dans toutes les branches de lecture
• Éviter toute adresse locale au return

---
CARD 076 — Pointeurs

Face :
atoi : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : return sign * result sans affichage

---
CARD 077 — Pointeurs

Face :
last_word : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : if (argc != 2), écrire seulement un retour ligne
• Avancer selon la règle : reculer jusqu’au début du mot puis afficher le segment
• Éviter toute adresse locale au return

---
CARD 078 — Pointeurs

Face :
last_word : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : écrire exactement le dernier mot puis un retour ligne

---
CARD 079 — Pointeurs

Face :
inter : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?

Dos :
• Conserver l’adresse utile dans un temporaire
• Déréférencer seulement après garde : if (argc != 3), sortie minimale avec retour ligne
• Avancer selon la règle : parcourir argv[1], scanner argv[2], marquer les déjà affichés
• Éviter toute adresse locale au return

---
CARD 080 — Pointeurs

Face :
inter : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?

Dos :
• Conserver le pointeur de base pour le return
• Ne jamais retourner l’adresse d’une variable locale
• Vérifier la validité avant chaque -> ou *
• Finaliser avec une sortie cohérente : n’afficher chaque caractère commun qu’une seule fois

---
CARD 081 — Malloc

Face :
ft_split : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : allouer (words + 1) pointeurs puis chaque mot en len + 1
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : free les mots déjà alloués, free le tableau, return NULL

---
CARD 082 — Malloc

Face :
ft_split : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : free les mots déjà alloués, free le tableau, return NULL
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 083 — Malloc

Face :
ft_range : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : malloc(size * sizeof(int))
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : if (!arr) return NULL immédiatement

---
CARD 084 — Malloc

Face :
ft_range : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : if (!arr) return NULL immédiatement
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 085 — Malloc

Face :
ft_list_remove_if : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc, suppression en place
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : si liste vide, return sans toucher aux pointeurs

---
CARD 086 — Malloc

Face :
ft_list_remove_if : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : si liste vide, return sans toucher aux pointeurs
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 087 — Malloc

Face :
sort_list : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc, tri en place
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : si cmp est instable, ne pas casser les liens

---
CARD 088 — Malloc

Face :
sort_list : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : si cmp est instable, ne pas casser les liens
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 089 — Malloc

Face :
itoa : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : malloc(digits + sign + 1)
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : if (!str) return NULL

---
CARD 090 — Malloc

Face :
itoa : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : if (!str) return NULL
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 091 — Malloc

Face :
wdmatch : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc dans la solution standard
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : si un caractère manque, ne pas afficher argv[1]

---
CARD 092 — Malloc

Face :
wdmatch : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : si un caractère manque, ne pas afficher argv[1]
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 093 — Malloc

Face :
union : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc, tableau local seen
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : argc invalide, écrire un retour ligne et sortir

---
CARD 094 — Malloc

Face :
union : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : argc invalide, écrire un retour ligne et sortir
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 095 — Malloc

Face :
atoi : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc nécessaire
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : entrée vide ou signe seul, retourner la valeur prévue par le sujet

---
CARD 096 — Malloc

Face :
atoi : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : entrée vide ou signe seul, retourner la valeur prévue par le sujet
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 097 — Malloc

Face :
last_word : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc, affichage direct
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : si aucun mot trouvé, écrire seulement un retour ligne

---
CARD 098 — Malloc

Face :
last_word : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : si aucun mot trouvé, écrire seulement un retour ligne
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 099 — Malloc

Face :
inter : quelle taille malloc dois-tu poser pour passer les tests limites ?

Dos :
• Formule exacte : aucun malloc, logique en parcours
• Inclure toujours la terminaison nécessaire
• Éviter les tailles arbitraires
• Tester l’échec avant toute écriture : pas de caractère commun, afficher seulement un retour ligne

---
CARD 100 — Malloc

Face :
inter : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?

Dos :
• Sortir proprement : pas de caractère commun, afficher seulement un retour ligne
• Nettoyer les allocations déjà faites
• Ne jamais écrire dans un pointeur NULL
• Retourner un état d’échec explicite

---
CARD 101 — Listes chaînées

Face :
ft_list_remove_if : tu supprimes en tête. Quel enchaînement évite de perdre la liste ?

Dos :
• Stocker la tête cible dans tmp
• Repointer *begin_list vers le suivant
• Free(tmp) après reconnexion
• Reboucler tant que la tête match

---
CARD 102 — Listes chaînées

Face :
ft_list_remove_if : deux maillons consécutifs doivent disparaître. Quel réflexe d’avancement ?

Dos :
• Ne pas avancer cur après suppression
• Rester sur le même cur pour retester cur->next
• Utiliser tmp pour unlink puis free
• Avancer cur seulement si aucun unlink

---
CARD 103 — Listes chaînées

Face :
ft_list_remove_if : avant d’accéder à cur->next->next, quel test est obligatoire ?

Dos :
• Vérifier cur et cur->next
• Ne jamais déréférencer sans garde
• Sortir proprement si la chaîne est courte
• Reprendre la boucle avec un état sûr

---
CARD 104 — Listes chaînées

Face :
ft_list_remove_if : suppression du dernier maillon. Que fais-tu dans l’ordre ?

Dos :
• Trouver le maillon précédent
• Mettre previous->next à NULL
• Free le dernier maillon
• Conserver la tête inchangée

---
CARD 105 — Listes chaînées

Face :
ft_list_remove_if : liste vide en entrée. Quel comportement attendu à l’exam ?

Dos :
• Retour immédiat sans déréférence
• Aucun free hors contexte
• Aucun accès à ->next
• Fonction stable et silencieuse

---
CARD 106 — Listes chaînées

Face :
ft_list_remove_if : dans sort_list, quand arrêtes-tu les passes de tri ?

Dos :
• Initialiser swapped à 0 en début de passe
• Mettre swapped à 1 sur chaque échange
• Arrêter quand une passe finit sans swap
• Ne pas casser les liens pendant le tri

---
CARD 107 — Listes chaînées

Face :
ft_list_remove_if : swap des maillons ou swap des data ? Quelle décision rapide prend-tu ?

Dos :
• Privilégier le swap de data en exam
• Utiliser tmp pour échanger proprement
• Éviter de relier les next sans plan complet
• Valider cmp avant chaque échange

---
CARD 108 — Listes chaînées

Face :
ft_list_remove_if : après unlink d’un maillon, quel ordre garde l’intégrité mémoire ?

Dos :
• Reconnexion des liens en premier
• Free du maillon supprimé ensuite
• Aucun accès au maillon après free
• Poursuite du parcours avec pointeur valide

---
CARD 109 — Listes chaînées

Face :
ft_list_remove_if : tous les éléments sont égaux. Quel résultat est correct ?

Dos :
• Aucun swap inutile
• swapped reste à 0 sur la passe
• La liste reste stable
• La fonction se termine sans boucle infinie

---
CARD 110 — Listes chaînées

Face :
ft_list_remove_if : tu nettoies plusieurs têtes d’affilée. Quel test pilote la boucle ?

Dos :
• while (*begin_list && cmp(...) == 0)
• tmp = *begin_list avant unlink
• *begin_list = tmp->next puis free(tmp)
• Répéter jusqu’à première tête conservée

---
CARD 111 — Listes chaînées

Face :
sort_list : tu supprimes en tête. Quel enchaînement évite de perdre la liste ?

Dos :
• Stocker la tête cible dans tmp
• Repointer *begin_list vers le suivant
• Free(tmp) après reconnexion
• Reboucler tant que la tête match

---
CARD 112 — Listes chaînées

Face :
sort_list : deux maillons consécutifs doivent disparaître. Quel réflexe d’avancement ?

Dos :
• Ne pas avancer cur après suppression
• Rester sur le même cur pour retester cur->next
• Utiliser tmp pour unlink puis free
• Avancer cur seulement si aucun unlink

---
CARD 113 — Listes chaînées

Face :
sort_list : avant d’accéder à cur->next->next, quel test est obligatoire ?

Dos :
• Vérifier cur et cur->next
• Ne jamais déréférencer sans garde
• Sortir proprement si la chaîne est courte
• Reprendre la boucle avec un état sûr

---
CARD 114 — Listes chaînées

Face :
sort_list : suppression du dernier maillon. Que fais-tu dans l’ordre ?

Dos :
• Trouver le maillon précédent
• Mettre previous->next à NULL
• Free le dernier maillon
• Conserver la tête inchangée

---
CARD 115 — Listes chaînées

Face :
sort_list : liste vide en entrée. Quel comportement attendu à l’exam ?

Dos :
• Retour immédiat sans déréférence
• Aucun free hors contexte
• Aucun accès à ->next
• Fonction stable et silencieuse

---
CARD 116 — Listes chaînées

Face :
sort_list : dans sort_list, quand arrêtes-tu les passes de tri ?

Dos :
• Initialiser swapped à 0 en début de passe
• Mettre swapped à 1 sur chaque échange
• Arrêter quand une passe finit sans swap
• Ne pas casser les liens pendant le tri

---
CARD 117 — Listes chaînées

Face :
sort_list : swap des maillons ou swap des data ? Quelle décision rapide prend-tu ?

Dos :
• Privilégier le swap de data en exam
• Utiliser tmp pour échanger proprement
• Éviter de relier les next sans plan complet
• Valider cmp avant chaque échange

---
CARD 118 — Listes chaînées

Face :
sort_list : après unlink d’un maillon, quel ordre garde l’intégrité mémoire ?

Dos :
• Reconnexion des liens en premier
• Free du maillon supprimé ensuite
• Aucun accès au maillon après free
• Poursuite du parcours avec pointeur valide

---
CARD 119 — Listes chaînées

Face :
sort_list : tous les éléments sont égaux. Quel résultat est correct ?

Dos :
• Aucun swap inutile
• swapped reste à 0 sur la passe
• La liste reste stable
• La fonction se termine sans boucle infinie

---
CARD 120 — Listes chaînées

Face :
sort_list : tu nettoies plusieurs têtes d’affilée. Quel test pilote la boucle ?

Dos :
• while (*begin_list && cmp(...) == 0)
• tmp = *begin_list avant unlink
• *begin_list = tmp->next puis free(tmp)
• Répéter jusqu’à première tête conservée

---
CARD 121 — Conditions limites

Face :
ft_split : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : string vide ou composée uniquement de séparateurs
• Confirmer la garde : ignorer les séparateurs avant de marquer un mot
• Contrôler la sortie : poser tab[word_count] = NULL avant return
• Vérifier le comportement en erreur : free les mots déjà alloués, free le tableau, return NULL

---
CARD 122 — Conditions limites

Face :
ft_split : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 123 — Conditions limites

Face :
ft_range : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : start == end doit retourner un tableau de taille 1
• Confirmer la garde : définir step à +1 ou -1 selon start/end
• Contrôler la sortie : retourner le pointeur de base, jamais un pointeur avancé
• Vérifier le comportement en erreur : if (!arr) return NULL immédiatement

---
CARD 124 — Conditions limites

Face :
ft_range : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 125 — Conditions limites

Face :
ft_list_remove_if : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : plusieurs suppressions consécutives
• Confirmer la garde : tester begin_list et *begin_list avant déréférence
• Contrôler la sortie : laisser *begin_list cohérent après toutes suppressions
• Vérifier le comportement en erreur : si liste vide, return sans toucher aux pointeurs

---
CARD 126 — Conditions limites

Face :
ft_list_remove_if : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 127 — Conditions limites

Face :
sort_list : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : liste vide, liste à un maillon, éléments égaux
• Confirmer la garde : si la liste est vide ou à un maillon, return lst
• Contrôler la sortie : arrêter après un passage complet sans swap
• Vérifier le comportement en erreur : si cmp est instable, ne pas casser les liens

---
CARD 128 — Conditions limites

Face :
sort_list : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 129 — Conditions limites

Face :
itoa : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : INT_MIN doit rester correct sans overflow
• Confirmer la garde : gérer explicitement le cas n == 0
• Contrôler la sortie : poser str[len] = '\0' avant return
• Vérifier le comportement en erreur : if (!str) return NULL

---
CARD 130 — Conditions limites

Face :
itoa : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 131 — Conditions limites

Face :
wdmatch : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : argv[1] vide doit être géré proprement
• Confirmer la garde : if (argc != 3) écrire uniquement un retour ligne
• Contrôler la sortie : afficher argv[1] seulement si tout est consommé dans l’ordre
• Vérifier le comportement en erreur : si un caractère manque, ne pas afficher argv[1]

---
CARD 132 — Conditions limites

Face :
wdmatch : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 133 — Conditions limites

Face :
union : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : char signé négatif sur caractères étendus
• Confirmer la garde : caster chaque char en unsigned char avant indexation
• Contrôler la sortie : écrire un caractère inédit une seule fois
• Vérifier le comportement en erreur : argc invalide, écrire un retour ligne et sortir

---
CARD 134 — Conditions limites

Face :
union : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 135 — Conditions limites

Face :
atoi : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : gérer correctement -0 et les espaces initiaux
• Confirmer la garde : arrêter au premier caractère non numérique
• Contrôler la sortie : return sign * result sans affichage
• Vérifier le comportement en erreur : entrée vide ou signe seul, retourner la valeur prévue par le sujet

---
CARD 136 — Conditions limites

Face :
atoi : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 137 — Conditions limites

Face :
last_word : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : espaces et tabulations en fin de chaîne
• Confirmer la garde : if (argc != 2), écrire seulement un retour ligne
• Contrôler la sortie : écrire exactement le dernier mot puis un retour ligne
• Vérifier le comportement en erreur : si aucun mot trouvé, écrire seulement un retour ligne

---
CARD 138 — Conditions limites

Face :
last_word : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 139 — Conditions limites

Face :
inter : quel cas limite testes-tu en premier avant de valider la fonction ?

Dos :
• Cas critique : doublons multiples dans argv[1]
• Confirmer la garde : if (argc != 3), sortie minimale avec retour ligne
• Contrôler la sortie : n’afficher chaque caractère commun qu’une seule fois
• Vérifier le comportement en erreur : pas de caractère commun, afficher seulement un retour ligne

---
CARD 140 — Conditions limites

Face :
inter : en entrée minimale, quel comportement doit rester stable ?

Dos :
• Aucune déréférence sans garde
• Aucune allocation inutile
• Retour déterministe et conforme
• Sortie attendue strictement respectée

---
CARD 141 — Règles implicites des énoncés

Face :
ft_split : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 142 — Règles implicites des énoncés

Face :
ft_split : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : si argc invalide dans un main test, écrire seulement un retour ligne
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 143 — Règles implicites des énoncés

Face :
ft_range : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 144 — Règles implicites des énoncés

Face :
ft_range : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : respecter exactement le prototype demandé
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 145 — Règles implicites des énoncés

Face :
ft_list_remove_if : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 146 — Règles implicites des énoncés

Face :
ft_list_remove_if : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : garder la signature imposée avec free_fct
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 147 — Règles implicites des énoncés

Face :
sort_list : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 148 — Règles implicites des énoncés

Face :
sort_list : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : respecter la convention cmp(a, b) > 0 pour swap
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 149 — Règles implicites des énoncés

Face :
itoa : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 150 — Règles implicites des énoncés

Face :
itoa : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : la fonction retourne une string, elle ne doit rien afficher
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 151 — Règles implicites des énoncés

Face :
wdmatch : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 152 — Règles implicites des énoncés

Face :
wdmatch : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : sortie stricte sans texte additionnel
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 153 — Règles implicites des énoncés

Face :
union : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 154 — Règles implicites des énoncés

Face :
union : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : respecter le format exact de sortie demandé
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 155 — Règles implicites des énoncés

Face :
atoi : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 156 — Règles implicites des énoncés

Face :
atoi : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : pas de sortie texte dans la fonction
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 157 — Règles implicites des énoncés

Face :
last_word : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 158 — Règles implicites des énoncés

Face :
last_word : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : aucun espace en trop dans la sortie
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
CARD 159 — Règles implicites des énoncés

Face :
inter : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?

Dos :
• Signature identique au sujet
• Fonctions autorisées uniquement
• Aucun print de debug
• Sortie formatée exactement comme demandé

---
CARD 160 — Règles implicites des énoncés

Face :
inter : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?

Dos :
• Règle d’énoncé : sortie stricte sans message de debug
• Ne pas ajouter de message personnel
• Conserver stdout conforme
• Quitter proprement sans effet de bord

---
