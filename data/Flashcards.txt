Voici **20 flashcards â€œPatternsâ€**, prÃªtes Ã  Ãªtre utilisÃ©es dans ton futur site.
Elles sont formulÃ©es pour dÃ©clencher **le raisonnement exam**, pas rÃ©citer du code.

Chaque carte contient : situation â†’ rÃ©flexe â†’ Ã©tapes.

---

## ğŸŸ¦ CARD 1 â€” itoa

**Face :**
Tu dois convertir un int en string. Quel pattern appliquer ?

**Dos :**
â€¢ gÃ©rer le signe
â€¢ caster en long
â€¢ compter chiffres
â€¢ malloc taille +1 (+1 si nÃ©gatif)
â€¢ '\0' final
â€¢ remplir Ã  lâ€™envers
â€¢ poser '-' si besoin

---

## ğŸŸ¦ CARD 2 â€” split

**Face :**
Avant de coder split, quel pattern prÃ©parer ?

**Dos :**
â€¢ dÃ©finir sÃ©parateurs
â€¢ ignorer sÃ©parateurs
â€¢ compter mots
â€¢ malloc tableau (mots + NULL)
â€¢ pour chaque mot : compter lettres
â€¢ malloc mot +1
â€¢ copier
â€¢ NULL final

---

## ğŸŸ¦ CARD 3 â€” ft_range

**Face :**
Quel est le pattern pour remplir un tableau de start Ã  end ?

**Dos :**
â€¢ calculer taille = abs(end-start)+1
â€¢ step = +1 ou -1
â€¢ malloc
â€¢ boucle de remplissage
â€¢ return ptr

---

## ğŸŸ¦ CARD 4 â€” union/inter

**Face :**
Comment Ã©viter les doublons de caractÃ¨res ?

**Dos :**
â€¢ tableau seen[256]
â€¢ indexer avec unsigned char
â€¢ afficher si seen == 0
â€¢ marquer seen = 1

---

## ğŸŸ¦ CARD 5 â€” wdmatch

**Face :**
Quel est le pattern de wdmatch ?

**Dos :**
â€¢ parcourir string 2
â€¢ avancer index string 1 quand match
â€¢ fin si index1 == fin
â€¢ afficher string 1 si rÃ©ussi

---

## ğŸŸ¦ CARD 6 â€” strdup

**Face :**
Quel est le pattern de strdup ?

**Dos :**
â€¢ compter longueur
â€¢ malloc len +1
â€¢ copier
â€¢ '\0'

---

## ğŸŸ¦ CARD 7 â€” list_foreach

**Face :**
Comment parcourir une liste ?

**Dos :**
â€¢ cur = begin
â€¢ while(cur)
â€¢ appliquer f(cur->data)
â€¢ cur = cur->next

---

## ğŸŸ¦ CARD 8 â€” list_remove_if

**Face :**
Quel est le pattern gÃ©nÃ©ral ?

**Dos :**
â€¢ nettoyer tÃªte avec while
â€¢ utiliser double pointeur
â€¢ parcourir avec cur
â€¢ tmp = cur->next
â€¢ unlink
â€¢ free(tmp)

---

## ğŸŸ¦ CARD 9 â€” sort_list

**Face :**
Quel pattern simple pour trier une liste ?

**Dos :**
â€¢ bubble sort
â€¢ flag swapped
â€¢ parcourir
â€¢ swap data
â€¢ recommencer si swapped

---

## ğŸŸ¦ CARD 10 â€” atoi

**Face :**
Pattern classique pour atoi ?

**Dos :**
â€¢ ignorer espaces
â€¢ gÃ©rer signe
â€¢ accumuler n = n*10 + digit
â€¢ return rÃ©sultat

---

## ğŸŸ¦ CARD 11 â€” last_word

**Face :**
Pattern pour trouver le dernier mot ?

**Dos :**
â€¢ aller en fin
â€¢ reculer sur sÃ©parateurs
â€¢ marquer fin
â€¢ reculer lettres
â€¢ afficher segment

---

## ğŸŸ¦ CARD 12 â€” strrev

**Face :**
Comment inverser une string ?

**Dos :**
â€¢ deux indices i/j
â€¢ swap
â€¢ i++ / j--
â€¢ stop quand i >= j

---

## ğŸŸ¦ CARD 13 â€” search and replace

**Face :**
Pattern de remplacement simple ?

**Dos :**
â€¢ parcourir string
â€¢ if char == cible â†’ remplacer
â€¢ write char

---

## ğŸŸ¦ CARD 14 â€” lstsize

**Face :**
Comment compter les maillons ?

**Dos :**
â€¢ count = 0
â€¢ while(lst)
â€¢ count++
â€¢ lst = lst->next

---

## ğŸŸ¦ CARD 15 â€” putstr

**Face :**
Pattern pour afficher une string ?

**Dos :**
â€¢ parcourir
â€¢ write(1,&c,1)
â€¢ '\n' si demandÃ©

---

## ğŸŸ¦ CARD 16 â€” rot13 / rotone

**Face :**
Pattern de rotation de lettres ?

**Dos :**
â€¢ tester plage a-z / A-Z
â€¢ dÃ©caler
â€¢ wrap si dÃ©passe
â€¢ Ã©crire char

---

## ğŸŸ¦ CARD 17 â€” foreach argv

**Face :**
Pattern pour parcourir argv ?

**Dos :**
â€¢ i = 1
â€¢ while(argv[i])
â€¢ traiter
â€¢ i++

---

## ğŸŸ¦ CARD 18 â€” ft_list_remove_if tÃªte

**Face :**
Comment supprimer plusieurs tÃªtes ?

**Dos :**
â€¢ while(*begin && cmp(...)==0)
â€¢ tmp = *begin
â€¢ *begin = tmp->next
â€¢ free(tmp)

---

## ğŸŸ¦ CARD 19 â€” split : dÃ©tecter mot

**Face :**
Comment repÃ©rer un dÃ©but de mot ?

**Dos :**
â€¢ caractÃ¨re non sÃ©parateur
â€¢ prÃ©cÃ©dÃ© par sÃ©parateur ou dÃ©but
â€¢ start index

---

## ğŸŸ¦ CARD 20 â€” affichage exam

**Face :**
Pattern dâ€™affichage Ã  lâ€™exam ?

**Dos :**
â€¢ respecter strictement
â€¢ write only
â€¢ newline final
â€¢ rien en trop

---

Voici **20 flashcards â€œPiÃ¨gesâ€**, Ã©crites pour provoquer le rÃ©flexe exam immÃ©diat : *â€œattention, danger iciâ€*.

---

## ğŸŸ¥ CARD 1 â€” string sans '\0'

**Face :**
Tu copies une string sans ajouter '\0'. Que risque-tu ?

**Dos :**
â€¢ lecture hors limites
â€¢ affichage alÃ©atoire
â€¢ crash possible
â€¢ tests KO

---

## ğŸŸ¥ CARD 2 â€” malloc trop petit

**Face :**
Tu fais malloc(len) pour une string. ProblÃ¨me ?

**Dos :**
â€¢ pas de place pour '\0'
â€¢ Ã©criture hors tableau
â€¢ comportement indÃ©fini

---

## ğŸŸ¥ CARD 3 â€” argc incorrect

**Face :**
argc nâ€™est pas celui attendu. Que faire ?

**Dos :**
â€¢ afficher seulement '\n'
â€¢ rien dâ€™autre

---

## ğŸŸ¥ CARD 4 â€” char signÃ©

**Face :**
Tu utilises char comme index dans seen[256]. Danger ?

**Dos :**
â€¢ valeur nÃ©gative possible
â€¢ accÃ¨s hors tableau
â€¢ caster unsigned char

---

## ğŸŸ¥ CARD 5 â€” avancer aprÃ¨s suppression

**Face :**
Dans remove_if, tu avances cur aprÃ¨s unlink. Risque ?

**Dos :**
â€¢ sauter un maillon
â€¢ suppression incomplÃ¨te

---

## ğŸŸ¥ CARD 6 â€” INT_MIN

**Face :**
itoa sans gÃ©rer INT_MIN ?

**Dos :**
â€¢ overflow
â€¢ valeur fausse
â€¢ tests ratÃ©s

---

## ğŸŸ¥ CARD 7 â€” printf interdit

**Face :**
write est imposÃ© mais tu utilises printf.

**Dos :**
â€¢ interdit
â€¢ note = 0
â€¢ tests KO

---

## ğŸŸ¥ CARD 8 â€” free avant unlink

**Face :**
Tu free un maillon avant de reconnecter la liste.

**Dos :**
â€¢ corruption
â€¢ accÃ¨s mÃ©moire invalide

---

## ğŸŸ¥ CARD 9 â€” NULL oubliÃ©

**Face :**
Tu oublies le NULL final dans split.

**Dos :**
â€¢ parcours infini
â€¢ segfault

---

## ğŸŸ¥ CARD 10 â€” variable non initialisÃ©e

**Face :**
len non initialisÃ© avant comptage.

**Dos :**
â€¢ taille alÃ©atoire
â€¢ malloc faux
â€¢ crash

---

## ğŸŸ¥ CARD 11 â€” double free

**Face :**
Tu free deux fois le mÃªme pointeur.

**Dos :**
â€¢ segfault
â€¢ corruption heap

---

## ğŸŸ¥ CARD 12 â€” mauvais pointeur

**Face :**
Tu Ã©cris `*p = malloc(10)` alors que p est `char *`.

**Dos :**
â€¢ type invalide
â€¢ Ã©crasement mÃ©moire

---

## ğŸŸ¥ CARD 13 â€” return local

**Face :**
Tu retournes lâ€™adresse dâ€™une variable locale.

**Dos :**
â€¢ dangling pointer
â€¢ crash futur

---

## ğŸŸ¥ CARD 14 â€” off-by-one

**Face :**
Boucle i <= len au lieu de i < len.

**Dos :**
â€¢ dÃ©passement
â€¢ corruption

---

## ğŸŸ¥ CARD 15 â€” skip sÃ©parateurs

**Face :**
Tu oublies dâ€™ignorer les sÃ©parateurs dans split.

**Dos :**
â€¢ mots vides
â€¢ mauvaise sortie

---

## ğŸŸ¥ CARD 16 â€” malloc non testÃ©

**Face :**
Tu ne vÃ©rifies pas malloc.

**Dos :**
â€¢ segfault si NULL

---

## ğŸŸ¥ CARD 17 â€” seen pas remis Ã  zÃ©ro

**Face :**
seen[256] non initialisÃ©.

**Dos :**
â€¢ faux doublons
â€¢ comportement alÃ©atoire

---

## ğŸŸ¥ CARD 18 â€” avancer mauvais pointeur

**Face :**
Dans une liste, tu avances cur au mauvais moment.

**Dos :**
â€¢ Ã©lÃ©ment ignorÃ©
â€¢ bug logique

---

## ğŸŸ¥ CARD 19 â€” '\n' oubliÃ©

**Face :**
Lâ€™Ã©noncÃ© demande un newline final, tu lâ€™oublies.

**Dos :**
â€¢ tests automatiques Ã©chouent

---

## ğŸŸ¥ CARD 20 â€” malloc arbitraire

**Face :**
Tu fais malloc(1000) â€œpour Ãªtre largeâ€.

**Dos :**
â€¢ pas robuste
â€¢ tests limites ratÃ©s
â€¢ mauvaise pratique

---

Voici **20 flashcards â€œRÃ©flexes mÃ©moireâ€**, conÃ§ues pour automatiser les bons gestes en exam C : tailles, malloc, free, NULL, ownership, protection, comptage.

---

## ğŸŸ© CARD 1 â€” string malloc

**Face :**
Tu alloues une string copiÃ©e. Quelle taille minimale ?

**Dos :**
â€¢ longueur + 1
â€¢ place pour '\0'

---

## ğŸŸ© CARD 2 â€” malloc check

**Face :**
Quel est le premier test aprÃ¨s malloc ?

**Dos :**
â€¢ if (!ptr) return NULL;

---

## ğŸŸ© CARD 3 â€” tableau de strings

**Face :**
Comment doit se terminer un tableau de strings ?

**Dos :**
â€¢ pointeur NULL final

---

## ğŸŸ© CARD 4 â€” free aprÃ¨s unlink

**Face :**
Quand libÃ©rer un maillon supprimÃ© ?

**Dos :**
â€¢ aprÃ¨s avoir reconnectÃ© la liste

---

## ğŸŸ© CARD 5 â€” sizeof

**Face :**
Pourquoi Ã©crire sizeof(type) * n ?

**Dos :**
â€¢ nombre dâ€™octets correct

---

## ğŸŸ© CARD 6 â€” itoa taille

**Face :**
Quelle taille malloc pour "-42" ?

**Dos :**
â€¢ 4 caractÃ¨res : '-', '4', '2', '\0'

---

## ğŸŸ© CARD 7 â€” pointeur aprÃ¨s free

**Face :**
Que faire aprÃ¨s free(ptr) ?

**Dos :**
â€¢ ptr = NULL (si possible)

---

## ğŸŸ© CARD 8 â€” compter avant malloc

**Face :**
Pourquoi compter avant malloc ?

**Dos :**
â€¢ allouer juste
â€¢ Ã©viter dÃ©passement

---

## ğŸŸ© CARD 9 â€” seen[256]

**Face :**
Pourquoi initialiser seen[256] ?

**Dos :**
â€¢ Ã©viter faux positifs
â€¢ Ã©tat propre

---

## ğŸŸ© CARD 10 â€” owner mÃ©moire

**Face :**
Qui doit free la mÃ©moire retournÃ©e par une fonction ?

**Dos :**
â€¢ lâ€™appelant

---

## ğŸŸ© CARD 11 â€” tableau 2D

**Face :**
Comment allouer un tableau de pointeurs vers mots ?

**Dos :**
â€¢ malloc(nb_mots + 1)
â€¢ NULL final

---

## ğŸŸ© CARD 12 â€” long cast

**Face :**
Pourquoi caster en long dans itoa ?

**Dos :**
â€¢ Ã©viter overflow (INT_MIN)

---

## ğŸŸ© CARD 13 â€” index unsigned

**Face :**
Pourquoi caster en unsigned char ?

**Dos :**
â€¢ Ã©viter index nÃ©gatif

---

## ğŸŸ© CARD 14 â€” variable init

**Face :**
Pourquoi initialiser len = 0 ?

**Dos :**
â€¢ Ã©viter valeur alÃ©atoire

---

## ğŸŸ© CARD 15 â€” free en erreur

**Face :**
Si malloc Ã©choue au milieu de split ?

**Dos :**
â€¢ free ce qui est dÃ©jÃ  allouÃ©

---

## ğŸŸ© CARD 16 â€” buffer fixe

**Face :**
Pourquoi Ã©viter malloc(1000) arbitraire ?

**Dos :**
â€¢ imprÃ©cis
â€¢ fragile

---

## ğŸŸ© CARD 17 â€” '\0' final

**Face :**
Pourquoi ajouter '\0' ?

**Dos :**
â€¢ terminaison string
â€¢ affichage correct

---

## ğŸŸ© CARD 18 â€” double pointeur

**Face :**
Pourquoi t_list ** dans remove_if ?

**Dos :**
â€¢ modifier la tÃªte
â€¢ Ã©viter perdre accÃ¨s

---

## ğŸŸ© CARD 19 â€” sizeof(ptr)

**Face :**
Pourquoi sizeof(ptr) est souvent faux ?

**Dos :**
â€¢ taille pointeur
â€¢ pas taille Ã©lÃ©ment

---

## ğŸŸ© CARD 20 â€” free(NULL)

**Face :**
Que fait free(NULL) ?

**Dos :**
â€¢ rien
â€¢ sÃ»r

---

Voici **20 flashcards â€œPointeursâ€**, Ã©crites pour ancrer les mÃ©canismes essentiels en exam C : adresse, dÃ©rÃ©fÃ©rencement, double pointeur, listes, erreurs classiques.

---

## ğŸŸ¨ CARD 1 â€” dÃ©finition

**Face :**
Quâ€™est-ce quâ€™un pointeur en C ?

**Dos :**
â€¢ une variable qui contient une adresse mÃ©moire

---

## ğŸŸ¨ CARD 2 â€” deref

**Face :**
Que fait `*p` ?

**Dos :**
â€¢ accÃ¨de Ã  la valeur pointÃ©e

---

## ğŸŸ¨ CARD 3 â€” &

**Face :**
Que fait `&x` ?

**Dos :**
â€¢ donne lâ€™adresse de x

---

## ğŸŸ¨ CARD 4 â€” simple vs double

**Face :**
Pourquoi utiliser `t_list **` ?

**Dos :**
â€¢ modifier la tÃªte
â€¢ changer un pointeur

---

## ğŸŸ¨ CARD 5 â€” avancer liste

**Face :**
Quelle ligne fait avancer dans une liste ?

**Dos :**
â€¢ cur = cur->next

---

## ğŸŸ¨ CARD 6 â€” opÃ©rateur

**Face :**
Quel opÃ©rateur pour accÃ©der Ã  un champ via pointeur ?

**Dos :**
â€¢ ->

---

## ğŸŸ¨ CARD 7 â€” pointeur non init

**Face :**
Danger dâ€™un pointeur non initialisÃ© ?

**Dos :**
â€¢ comportement indÃ©fini
â€¢ segfault

---

## ğŸŸ¨ CARD 8 â€” aprÃ¨s free

**Face :**
Peut-on utiliser un pointeur aprÃ¨s free ?

**Dos :**
â€¢ non
â€¢ dangling pointer

---

## ğŸŸ¨ CARD 9 â€” argv

**Face :**
Pourquoi argv est un char ** ?

**Dos :**
â€¢ tableau de strings

---

## ğŸŸ¨ CARD 10 â€” tmp

**Face :**
Pourquoi utiliser un pointeur tmp en liste ?

**Dos :**
â€¢ garder adresse
â€¢ free ensuite

---

## ğŸŸ¨ CARD 11 â€” changer tÃªte

**Face :**
Quelle ligne modifie la tÃªte ?

**Dos :**
â€¢ *begin = (*begin)->next

---

## ğŸŸ¨ CARD 12 â€” deref NULL

**Face :**
Que se passe-t-il si on deref NULL ?

**Dos :**
â€¢ segfault

---

## ğŸŸ¨ CARD 13 â€” swap

**Face :**
Pourquoi swap data plutÃ´t que liens ?

**Dos :**
â€¢ plus simple
â€¢ moins risquÃ©

---

## ğŸŸ¨ CARD 14 â€” prioritÃ© opÃ©rateurs

**Face :**
Pourquoi `*cur->next` est piÃ©geux ?

**Dos :**
â€¢ -> avant *
â€¢ parenthÃ¨ses nÃ©cessaires

---

## ğŸŸ¨ CARD 15 â€” type void *

**Face :**
Que reprÃ©sente void * ?

**Dos :**
â€¢ pointeur gÃ©nÃ©rique

---

## ğŸŸ¨ CARD 16 â€” vÃ©rification

**Face :**
Quand vÃ©rifier un pointeur ?

**Dos :**
â€¢ avant deref

---

## ğŸŸ¨ CARD 17 â€” tableau vs pointeur

**Face :**
DiffÃ©rence char s[10] / char *s ?

**Dos :**
â€¢ tableau vs adresse
â€¢ stockage diffÃ©rent

---

## ğŸŸ¨ CARD 18 â€” return local

**Face :**
Pourquoi ne pas retourner &local ?

**Dos :**
â€¢ pointeur mort
â€¢ stack dÃ©truite

---

## ğŸŸ¨ CARD 19 â€” ++ interdit

**Face :**
Pourquoi ne pas faire cur++ sur une liste ?

**Dos :**
â€¢ pas contigu
â€¢ mÃ©moire arbitraire

---

## ğŸŸ¨ CARD 20 â€” double pointeur danger

**Face :**
Risque principal avec ** ?

**Dos :**
â€¢ modifier mauvaise adresse
â€¢ perdre tÃªte

---

Voici **20 flashcards â€œmallocâ€**, conÃ§ues pour automatiser les bons rÃ©flexes dâ€™allocation en exam C : tailles exactes, protection, ownership, erreurs classiques.

---

## ğŸŸª CARD 1 â€” dÃ©finition

**Face :**
Ã€ quoi sert malloc ?

**Dos :**
â€¢ allouer dynamiquement en heap
â€¢ renvoie un pointeur

---

## ğŸŸª CARD 2 â€” Ã©chec

**Face :**
Que retourne malloc en cas dâ€™Ã©chec ?

**Dos :**
â€¢ NULL

---

## ğŸŸª CARD 3 â€” taille string

**Face :**
Quelle taille malloc pour copier une string ?

**Dos :**
â€¢ longueur + 1
â€¢ '\0'

---

## ğŸŸª CARD 4 â€” sizeof

**Face :**
Pourquoi sizeof(type) * n ?

**Dos :**
â€¢ nombre dâ€™octets correct

---

## ğŸŸª CARD 5 â€” test

**Face :**
Quel test immÃ©diat aprÃ¨s malloc ?

**Dos :**
â€¢ if (!ptr) return NULL

---

## ğŸŸª CARD 6 â€” ownership

**Face :**
Qui doit free la mÃ©moire retournÃ©e ?

**Dos :**
â€¢ lâ€™appelant

---

## ğŸŸª CARD 7 â€” free(NULL)

**Face :**
Que fait free(NULL) ?

**Dos :**
â€¢ rien
â€¢ sÃ»r

---

## ğŸŸª CARD 8 â€” buffer fixe

**Face :**
Pourquoi Ã©viter malloc(1000) arbitraire ?

**Dos :**
â€¢ fragile
â€¢ imprÃ©cis

---

## ğŸŸª CARD 9 â€” sizeof(ptr)

**Face :**
Pourquoi sizeof(ptr) est faux pour tableau ?

**Dos :**
â€¢ taille pointeur
â€¢ pas Ã©lÃ©ment

---

## ğŸŸª CARD 10 â€” 2D

**Face :**
Comment allouer un tableau de mots ?

**Dos :**
â€¢ malloc(nb + 1)
â€¢ NULL final

---

## ğŸŸª CARD 11 â€” libÃ©rer aprÃ¨s unlink

**Face :**
Quand free un maillon supprimÃ© ?

**Dos :**
â€¢ aprÃ¨s reconnecter

---

## ğŸŸª CARD 12 â€” erreur intermÃ©diaire

**Face :**
malloc Ã©choue dans split Ã  mi-chemin ?

**Dos :**
â€¢ free ce qui est dÃ©jÃ  allouÃ©

---

## ğŸŸª CARD 13 â€” calloc

**Face :**
Que fait calloc ?

**Dos :**
â€¢ malloc + mise Ã  zÃ©ro

---

## ğŸŸª CARD 14 â€” realloc

**Face :**
Ã€ quoi sert realloc ?

**Dos :**
â€¢ agrandir / rÃ©duire
â€¢ conserve contenu

---

## ğŸŸª CARD 15 â€” fuite

**Face :**
Quâ€™est-ce quâ€™une fuite mÃ©moire ?

**Dos :**
â€¢ mÃ©moire jamais free

---

## ğŸŸª CARD 16 â€” aprÃ¨s free

**Face :**
Pourquoi mettre ptr = NULL aprÃ¨s free ?

**Dos :**
â€¢ Ã©viter rÃ©utilisation

---

## ğŸŸª CARD 17 â€” taille inclusive

**Face :**
Pourquoi +1 dans ft_range ?

**Dos :**
â€¢ inclure start et end

---

## ğŸŸª CARD 18 â€” itoa

**Face :**
Pourquoi malloc len + sign + 1 ?

**Dos :**
â€¢ '-'
â€¢ '\0'

---

## ğŸŸª CARD 19 â€” check arguments

**Face :**
Pourquoi vÃ©rifier argc avant malloc ?

**Dos :**
â€¢ Ã©viter allocation inutile

---

## ğŸŸª CARD 20 â€” rÃ¨gle absolue

**Face :**
RÃ©flexe numÃ©ro un avec malloc ?

**Dos :**
â€¢ vÃ©rifier NULL

---

Voici **20 flashcards â€œListes chaÃ®nÃ©esâ€**, conÃ§ues pour fixer les mÃ©canismes indispensables en exam C : parcours, suppression, double pointeur, tri, erreurs classiques.

---

## ğŸŸ« CARD 1 â€” rÃ´le next

**Face :**
Ã€ quoi sert le champ next ?

**Dos :**
â€¢ pointer vers le maillon suivant

---

## ğŸŸ« CARD 2 â€” tÃªte

**Face :**
Que reprÃ©sente begin_list ?

**Dos :**
â€¢ pointeur vers la tÃªte

---

## ğŸŸ« CARD 3 â€” double pointeur

**Face :**
Pourquoi passer t_list ** ?

**Dos :**
â€¢ modifier la tÃªte
â€¢ relier aprÃ¨s suppression

---

## ğŸŸ« CARD 4 â€” parcourir

**Face :**
Comment parcourir une liste ?

**Dos :**
â€¢ cur = begin
â€¢ while(cur)
â€¢ cur = cur->next

---

## ğŸŸ« CARD 5 â€” supprimer suivant

**Face :**
Comment retirer cur->next ?

**Dos :**
â€¢ tmp = cur->next
â€¢ cur->next = tmp->next
â€¢ free(tmp)

---

## ğŸŸ« CARD 6 â€” nettoyer tÃªte

**Face :**
Comment supprimer plusieurs tÃªtes ?

**Dos :**
â€¢ while(*begin && cmp(...))
â€¢ tmp = *begin
â€¢ *begin = tmp->next
â€¢ free(tmp)

---

## ğŸŸ« CARD 7 â€” avancer

**Face :**
Quand avancer cur ?

**Dos :**
â€¢ seulement si pas supprimÃ©

---

## ğŸŸ« CARD 8 â€” fin liste

**Face :**
Comment dÃ©tecter la fin ?

**Dos :**
â€¢ cur == NULL

---

## ğŸŸ« CARD 9 â€” liste vide

**Face :**
Que vaut une liste vide ?

**Dos :**
â€¢ pointeur NULL

---

## ğŸŸ« CARD 10 â€” tmp

**Face :**
Pourquoi tmp est indispensable ?

**Dos :**
â€¢ garder adresse
â€¢ free aprÃ¨s

---

## ğŸŸ« CARD 11 â€” sort_list

**Face :**
Quel tri simple utiliser Ã  lâ€™exam ?

**Dos :**
â€¢ bubble sort
â€¢ swap data

---

## ğŸŸ« CARD 12 â€” swapped

**Face :**
Ã€ quoi sert swapped ?

**Dos :**
â€¢ savoir si encore des Ã©changes

---

## ğŸŸ« CARD 13 â€” cmp

**Face :**
Que fait cmp dans sort_list ?

**Dos :**
â€¢ indique ordre correct

---

## ğŸŸ« CARD 14 â€” lstsize

**Face :**
Comment compter les maillons ?

**Dos :**
â€¢ while(lst) count++

---

## ğŸŸ« CARD 15 â€” dernier

**Face :**
Que vaut next du dernier ?

**Dos :**
â€¢ NULL

---

## ğŸŸ« CARD 16 â€” unlink avant free

**Face :**
Pourquoi unlink avant free ?

**Dos :**
â€¢ Ã©viter corruption

---

## ğŸŸ« CARD 17 â€” accÃ¨s sÃ©curisÃ©

**Face :**
Quel test avant cur->next ?

**Dos :**
â€¢ if(cur->next)

---

## ğŸŸ« CARD 18 â€” supprimer dernier

**Face :**
Comment supprimer le dernier ?

**Dos :**
â€¢ parcourir jusquâ€™Ã  avant dernier
â€¢ unlink
â€¢ free

---

## ğŸŸ« CARD 19 â€” rÃ©cursion

**Face :**
Pourquoi Ã©viter rÃ©cursion Ã  lâ€™exam ?

**Dos :**
â€¢ stack
â€¢ complexitÃ©

---

## ğŸŸ« CARD 20 â€” danger principal

**Face :**
PiÃ¨ge majeur avec les listes ?

**Dos :**
â€¢ avancer au mauvais moment
â€¢ perdre un lien

---

Voici **20 flashcards â€œConditions limitesâ€**, faites pour entraÃ®ner ton rÃ©flexe *â€œet si câ€™est le cas bizarre ?â€* avant de coder : chaÃ®nes vides, listes Ã  1 Ã©lÃ©ment, 0, nÃ©gatif, malloc qui Ã©choue.

---

## ğŸŸ¦ CARD 1 â€” itoa INT_MIN

**Face :**
Quel est le cas limite majeur de itoa ?

**Dos :**
â€¢ INT_MIN
â€¢ overflow si non gÃ©rÃ©
â€¢ caster en long

---

## ğŸŸ¦ CARD 2 â€” split vide

**Face :**
split("") doit retourner quoi ?

**Dos :**
â€¢ tableau contenant seulement NULL

---

## ğŸŸ¦ CARD 3 â€” ft_range Ã©galitÃ©

**Face :**
ft_range(5,5) ?

**Dos :**
â€¢ tableau {5}

---

## ğŸŸ¦ CARD 4 â€” liste vide

**Face :**
Que vaut begin_list si la liste est vide ?

**Dos :**
â€¢ NULL

---

## ğŸŸ¦ CARD 5 â€” supprimer tout

**Face :**
remove_if supprime tous les Ã©lÃ©ments. RÃ©sultat ?

**Dos :**
â€¢ *begin devient NULL

---

## ğŸŸ¦ CARD 6 â€” atoi zÃ©ro

**Face :**
atoi("0") ?

**Dos :**
â€¢ 0

---

## ğŸŸ¦ CARD 7 â€” only spaces

**Face :**
split("   ") doit produire ?

**Dos :**
â€¢ tableau NULL

---

## ğŸŸ¦ CARD 8 â€” un seul Ã©lÃ©ment

**Face :**
sort_list avec un seul maillon ?

**Dos :**
â€¢ inchangÃ©

---

## ğŸŸ¦ CARD 9 â€” wdmatch ratÃ©

**Face :**
wdmatch ne trouve pas tous les caractÃ¨res.

**Dos :**
â€¢ afficher '\n'

---

## ğŸŸ¦ CARD 10 â€” start > end

**Face :**
ft_range(3,0) ?

**Dos :**
â€¢ {3,2,1,0}

---

## ğŸŸ¦ CARD 11 â€” itoa(0)

**Face :**
itoa(0) retourne ?

**Dos :**
â€¢ "0"

---

## ğŸŸ¦ CARD 12 â€” foreach vide

**Face :**
ft_list_foreach sur liste vide ?

**Dos :**
â€¢ rien

---

## ğŸŸ¦ CARD 13 â€” aucun match

**Face :**
remove_if ne trouve rien.

**Dos :**
â€¢ liste inchangÃ©e

---

## ğŸŸ¦ CARD 14 â€” tableau final

**Face :**
Comment doit se terminer un tableau de strings ?

**Dos :**
â€¢ NULL

---

## ğŸŸ¦ CARD 15 â€” atoi espaces

**Face :**
atoi("   42") ?

**Dos :**
â€¢ 42

---

## ğŸŸ¦ CARD 16 â€” union vide

**Face :**
union("", "") ?

**Dos :**
â€¢ rien afficher

---

## ğŸŸ¦ CARD 17 â€” dernier mot

**Face :**
Dernier mot sans sÃ©parateur ?

**Dos :**
â€¢ inclure quand mÃªme

---

## ğŸŸ¦ CARD 18 â€” supprimer dernier

**Face :**
remove_if supprime dernier maillon ?

**Dos :**
â€¢ unlink
â€¢ free

---

## ğŸŸ¦ CARD 19 â€” argc faux

**Face :**
argc incorrect.

**Dos :**
â€¢ afficher '\n'

---

## ğŸŸ¦ CARD 20 â€” malloc Ã©choue

**Face :**
malloc Ã©choue dans split ?

**Dos :**
â€¢ free dÃ©jÃ  allouÃ©
â€¢ return NULL

---

Voici **20 flashcards â€œRÃ¨gles implicites des Ã©noncÃ©sâ€**, pensÃ©es pour tâ€™Ã©viter les zÃ©ros bÃªtes Ã  lâ€™exam : sorties exactes, fonctions autorisÃ©es, prototypes stricts, fichiers imposÃ©s.

---

## ğŸŸª CARD 1 â€” argc incorrect

**Face :**
argc nâ€™est pas celui attendu. Que faire ?

**Dos :**
â€¢ afficher uniquement `\n`
â€¢ rien dâ€™autre

---

## ğŸŸª CARD 2 â€” fonctions autorisÃ©es

**Face :**
Une fonction nâ€™est pas listÃ©e dans â€œAllowed functionsâ€.

**Dos :**
â€¢ interdite
â€¢ ne pas lâ€™utiliser

---

## ğŸŸª CARD 3 â€” write imposÃ©

**Face :**
write est la seule fonction autorisÃ©e.

**Dos :**
â€¢ pas printf
â€¢ pas puts
â€¢ pas perror

---

## ğŸŸª CARD 4 â€” sortie exacte

**Face :**
Pourquoi lâ€™output doit Ãªtre strict ?

**Dos :**
â€¢ tests automatiques
â€¢ comparaison exacte

---

## ğŸŸª CARD 5 â€” newline final

**Face :**
Lâ€™Ã©noncÃ© montre un `\n` final.

**Dos :**
â€¢ obligatoire
â€¢ sinon tests KO

---

## ğŸŸª CARD 6 â€” nom de fichier

**Face :**
â€œExpected files : wdmatch.câ€.

**Dos :**
â€¢ un seul fichier
â€¢ nom exact

---

## ğŸŸª CARD 7 â€” prototype

**Face :**
Le prototype doit correspondre exactement ?

**Dos :**
â€¢ oui
â€¢ sinon compilation refusÃ©e

---

## ğŸŸª CARD 8 â€” include fourni

**Face :**
â€œinclude list.h but do not turn it inâ€.

**Dos :**
â€¢ utiliser le header
â€¢ ne pas rendre le fichier

---

## ğŸŸª CARD 9 â€” structure imposÃ©e

**Face :**
Une struct est fournie dans lâ€™Ã©noncÃ©.

**Dos :**
â€¢ ne pas modifier
â€¢ utiliser telle quelle

---

## ğŸŸª CARD 10 â€” pas de debug

**Face :**
Peut-on laisser des printf de debug ?

**Dos :**
â€¢ non
â€¢ sortie strictement contrÃ´lÃ©e

---

## ğŸŸª CARD 11 â€” affichage erreur

**Face :**
Lâ€™Ã©noncÃ© ne demande pas dâ€™erreur explicite.

**Dos :**
â€¢ rester silencieux
â€¢ ou seulement `\n`

---

## ğŸŸª CARD 12 â€” return malloc

**Face :**
Une fonction doit retourner un pointeur.

**Dos :**
â€¢ retourner une adresse valide
â€¢ pas une variable locale

---

## ğŸŸª CARD 13 â€” Allowed functions: malloc

**Face :**
calloc est autorisÃ© ?

**Dos :**
â€¢ non
â€¢ pas listÃ©

---

## ğŸŸª CARD 14 â€” exemples

**Face :**
Les exemples fournis servent Ã  quoi ?

**Dos :**
â€¢ contrat exact
â€¢ format Ã  respecter

---

## ğŸŸª CARD 15 â€” stderr

**Face :**
Afficher sur stderr au lieu de stdout ?

**Dos :**
â€¢ tests ratÃ©s

---

## ğŸŸª CARD 16 â€” afficher trop

**Face :**
Tu affiches plus que demandÃ©.

**Dos :**
â€¢ tests KO

---

## ğŸŸª CARD 17 â€” comportement non prÃ©cisÃ©

**Face :**
Un cas nâ€™est pas dÃ©crit.

**Dos :**
â€¢ rester minimal
â€¢ ne rien inventer

---

## ğŸŸª CARD 18 â€” noms fonctions

**Face :**
Pourquoi respecter les noms exacts ?

**Dos :**
â€¢ linker
â€¢ compilation

---

## ğŸŸª CARD 19 â€” ordre affichage

**Face :**
Changer lâ€™ordre dâ€™affichage ?

**Dos :**
â€¢ interdit
â€¢ tests KO

---

## ğŸŸª CARD 20 â€” rÃ¨gle absolue

**Face :**
RÃ¨gle implicite numÃ©ro un ?

**Dos :**
â€¢ relire lâ€™Ã©noncÃ©
â€¢ respecter chaque mot

---

