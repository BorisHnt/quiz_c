[
  {
    "id": "fc-001",
    "category": "Pointers",
    "question": "Quelle différence entre `int *p` et `int p` ?",
    "answer": "`int *p` est un pointeur vers int; `int p` est une variable int.",
    "explanation": "Le pointeur contient une adresse mémoire. L'entier contient une valeur directe.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-002",
    "category": "Pointers",
    "question": "Que fait l'opérateur `*` dans `*p = 42;` ?",
    "answer": "Il déréférence `p` et écrit 42 à l'adresse pointée.",
    "explanation": "`*` permet d'accéder à la donnée ciblée par l'adresse stockée dans `p`.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-003",
    "category": "Memory",
    "question": "Quel retour de `malloc` faut-il vérifier ?",
    "answer": "Il faut vérifier que le pointeur retourné n'est pas `NULL`.",
    "explanation": "Un retour `NULL` signifie que l'allocation a échoué.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-004",
    "category": "Memory",
    "question": "Pourquoi libérer la mémoire avec `free` ?",
    "answer": "Pour éviter les fuites mémoire et conserver des allocations disponibles.",
    "explanation": "Sans `free`, les blocs restent réservés jusqu'à la fin du processus.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-005",
    "category": "Strings",
    "question": "Pourquoi `strcpy(dest, src)` peut être dangereux ?",
    "answer": "Parce qu'il ne vérifie pas la taille de `dest`.",
    "explanation": "Si `src` est trop long, on provoque un dépassement de tampon.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-006",
    "category": "I/O",
    "question": "Que renvoie `read` en fin de fichier ?",
    "answer": "`read` renvoie 0.",
    "explanation": "Un retour 0 indique qu'il n'y a plus de données à lire.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-007",
    "category": "Compilation",
    "question": "À quoi sert `-Werror` ?",
    "answer": "À traiter chaque warning comme une erreur bloquante.",
    "explanation": "Le compilateur refuse la génération du binaire tant qu'il reste des warnings.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-008",
    "category": "Struct",
    "question": "Différence entre `s.member` et `p->member` ?",
    "answer": "`s.member` accède directement; `p->member` via pointeur.",
    "explanation": "`p->member` équivaut à `(*p).member`.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-009",
    "category": "Arrays",
    "question": "Pourquoi `for (i = 0; i < n; i++)` est la forme sûre ?",
    "answer": "Parce que les indices valides d'un tableau de taille n vont de 0 à n-1.",
    "explanation": "Avec `i <= n`, l'indice n dépasse le tableau.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-010",
    "category": "Functions",
    "question": "Pourquoi une variable locale non initialisée est risquée ?",
    "answer": "Elle contient une valeur indéterminée.",
    "explanation": "Lire cette valeur entraîne un comportement non défini.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-011",
    "category": "Files",
    "question": "Quand utiliser `O_CREAT` avec `open` ?",
    "answer": "Quand on veut créer le fichier s'il n'existe pas.",
    "explanation": "Avec `O_CREAT`, il faut fournir les permissions en troisième argument.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-012",
    "category": "Pointers",
    "question": "Que se passe-t-il si on déréférence un pointeur NULL ?",
    "answer": "Comportement non défini, souvent un crash.",
    "explanation": "L'adresse NULL n'est pas une zone valide pour lire/écrire.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-013",
    "category": "Memory",
    "question": "Différence entre mémoire pile et mémoire tas ?",
    "answer": "La pile est gérée automatiquement; le tas est géré manuellement via `malloc/free`.",
    "explanation": "Les variables locales vivent sur la pile. Les allocations dynamiques vivent sur le tas.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-014",
    "category": "Strings",
    "question": "Pourquoi terminer une chaîne C par `\\0` ?",
    "answer": "Parce que les fonctions de chaîne utilisent ce marqueur pour connaître la fin.",
    "explanation": "Sans terminateur nul, les lectures continuent hors limites.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-015",
    "category": "Compilation",
    "question": "Quelle différence entre erreur et warning ?",
    "answer": "Une erreur bloque la compilation; un warning signale un risque.",
    "explanation": "Un warning peut être transformé en erreur avec `-Werror`.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  }
]
