[
  {
    "id": "fc-001",
    "category": "Patterns",
    "question": "ft_split : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : ignorer les séparateurs avant de marquer un mot | Ordre de travail : compter les mots avant toute allocation | Plan de sortie mémoire : allouer (words + 1) pointeurs puis chaque mot en len + 1 | Validation finale : poser tab[word_count] = NULL avant return",
    "explanation": "Sur ft_split, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-002",
    "category": "Patterns",
    "question": "ft_split : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : compter les mots avant toute allocation | Chemin d’échec prêt : free les mots déjà alloués, free le tableau, return NULL | Parcours maîtrisé : avancer index caractère sans sauter le dernier mot | Retour conforme : poser tab[word_count] = NULL avant return",
    "explanation": "Sur ft_split, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-003",
    "category": "Patterns",
    "question": "ft_range : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : définir step à +1 ou -1 selon start/end | Ordre de travail : calculer size = abs(end - start) + 1 | Plan de sortie mémoire : malloc(size * sizeof(int)) | Validation finale : retourner le pointeur de base, jamais un pointeur avancé",
    "explanation": "Sur ft_range, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-004",
    "category": "Patterns",
    "question": "ft_range : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : calculer size = abs(end - start) + 1 | Chemin d’échec prêt : if (!arr) return NULL immédiatement | Parcours maîtrisé : écrire arr[i], puis value += step | Retour conforme : retourner le pointeur de base, jamais un pointeur avancé",
    "explanation": "Sur ft_range, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-005",
    "category": "Patterns",
    "question": "ft_list_remove_if : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : tester begin_list et *begin_list avant déréférence | Ordre de travail : nettoyer la tête avec while(*begin_list && cmp(...) == 0) | Plan de sortie mémoire : aucun malloc, suppression en place | Validation finale : laisser *begin_list cohérent après toutes suppressions",
    "explanation": "Sur ft_list_remove_if, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-006",
    "category": "Patterns",
    "question": "ft_list_remove_if : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : nettoyer la tête avec while(*begin_list && cmp(...) == 0) | Chemin d’échec prêt : si liste vide, return sans toucher aux pointeurs | Parcours maîtrisé : tmp = cur->next, unlink, free(tmp), puis décider si cur avance | Retour conforme : laisser *begin_list cohérent après toutes suppressions",
    "explanation": "Sur ft_list_remove_if, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-007",
    "category": "Patterns",
    "question": "sort_list : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : si la liste est vide ou à un maillon, return lst | Ordre de travail : boucler tant que swapped == 1 | Plan de sortie mémoire : aucun malloc, tri en place | Validation finale : arrêter après un passage complet sans swap",
    "explanation": "Sur sort_list, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-008",
    "category": "Patterns",
    "question": "sort_list : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : boucler tant que swapped == 1 | Chemin d’échec prêt : si cmp est instable, ne pas casser les liens | Parcours maîtrisé : swap data avec tmp, pas les liens des maillons | Retour conforme : arrêter après un passage complet sans swap",
    "explanation": "Sur sort_list, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-009",
    "category": "Patterns",
    "question": "itoa : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : gérer explicitement le cas n == 0 | Ordre de travail : caster n en long avant traitement du signe | Plan de sortie mémoire : malloc(digits + sign + 1) | Validation finale : poser str[len] = '\\0' avant return",
    "explanation": "Sur itoa, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-010",
    "category": "Patterns",
    "question": "itoa : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : caster n en long avant traitement du signe | Chemin d’échec prêt : if (!str) return NULL | Parcours maîtrisé : remplir depuis la fin puis placer le signe | Retour conforme : poser str[len] = '\\0' avant return",
    "explanation": "Sur itoa, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-011",
    "category": "Patterns",
    "question": "wdmatch : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : if (argc != 3) écrire uniquement un retour ligne | Ordre de travail : parcourir argv[2] et avancer argv[1] uniquement en cas de match | Plan de sortie mémoire : aucun malloc dans la solution standard | Validation finale : afficher argv[1] seulement si tout est consommé dans l’ordre",
    "explanation": "Sur wdmatch, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-012",
    "category": "Patterns",
    "question": "wdmatch : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : parcourir argv[2] et avancer argv[1] uniquement en cas de match | Chemin d’échec prêt : si un caractère manque, ne pas afficher argv[1] | Parcours maîtrisé : i2 avance toujours, i1 avance seulement sur match | Retour conforme : afficher argv[1] seulement si tout est consommé dans l’ordre",
    "explanation": "Sur wdmatch, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-013",
    "category": "Patterns",
    "question": "union : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : caster chaque char en unsigned char avant indexation | Ordre de travail : utiliser seen[256] initialisé à 0 | Plan de sortie mémoire : aucun malloc, tableau local seen | Validation finale : écrire un caractère inédit une seule fois",
    "explanation": "Sur union, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-014",
    "category": "Patterns",
    "question": "union : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : utiliser seen[256] initialisé à 0 | Chemin d’échec prêt : argc invalide, écrire un retour ligne et sortir | Parcours maîtrisé : parcourir la première string puis la seconde | Retour conforme : écrire un caractère inédit une seule fois",
    "explanation": "Sur union, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-015",
    "category": "Patterns",
    "question": "atoi : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : arrêter au premier caractère non numérique | Ordre de travail : ignorer espaces, lire signe, accumuler chiffre par chiffre | Plan de sortie mémoire : aucun malloc nécessaire | Validation finale : return sign * result sans affichage",
    "explanation": "Sur atoi, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-016",
    "category": "Patterns",
    "question": "atoi : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : ignorer espaces, lire signe, accumuler chiffre par chiffre | Chemin d’échec prêt : entrée vide ou signe seul, retourner la valeur prévue par le sujet | Parcours maîtrisé : incrémenter l’index dans toutes les branches de lecture | Retour conforme : return sign * result sans affichage",
    "explanation": "Sur atoi, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-017",
    "category": "Patterns",
    "question": "last_word : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : if (argc != 2), écrire seulement un retour ligne | Ordre de travail : aller en fin de string puis reculer sur séparateurs | Plan de sortie mémoire : aucun malloc, affichage direct | Validation finale : écrire exactement le dernier mot puis un retour ligne",
    "explanation": "Sur last_word, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-018",
    "category": "Patterns",
    "question": "last_word : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : aller en fin de string puis reculer sur séparateurs | Chemin d’échec prêt : si aucun mot trouvé, écrire seulement un retour ligne | Parcours maîtrisé : reculer jusqu’au début du mot puis afficher le segment | Retour conforme : écrire exactement le dernier mot puis un retour ligne",
    "explanation": "Sur last_word, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-019",
    "category": "Patterns",
    "question": "inter : tu lances l’exercice. Quelle checklist exécuter avant la première boucle ?",
    "answer": "Commencer par la garde d’entrée : if (argc != 3), sortie minimale avec retour ligne | Ordre de travail : vérifier l’appartenance dans argv[2] avant d’afficher | Plan de sortie mémoire : aucun malloc, logique en parcours | Validation finale : n’afficher chaque caractère commun qu’une seule fois",
    "explanation": "Sur inter, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Tu gagnes du temps et évites les oublis de dernière minute.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-020",
    "category": "Patterns",
    "question": "inter : tu hésites au milieu du code. Quelle action immédiate te remet dans le bon pattern ?",
    "answer": "Action clé : vérifier l’appartenance dans argv[2] avant d’afficher | Chemin d’échec prêt : pas de caractère commun, afficher seulement un retour ligne | Parcours maîtrisé : parcourir argv[1], scanner argv[2], marquer les déjà affichés | Retour conforme : n’afficher chaque caractère commun qu’une seule fois",
    "explanation": "Sur inter, ce réflexe évite l’improvisation et réduit les erreurs de structure en exam. Le flux reste stable même sous pression chronométrée.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-021",
    "category": "Pièges",
    "question": "ft_split : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier poser tab[word_count] = null avant return | Vérification prioritaire : ignorer les séparateurs avant de marquer un mot | Ordre sûr : avancer index caractère sans sauter le dernier mot | Si erreur : free les mots déjà alloués, free le tableau, return NULL",
    "explanation": "Sur ft_split, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-022",
    "category": "Pièges",
    "question": "ft_split : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : string vide ou composée uniquement de séparateurs | Confirmer la garde : ignorer les séparateurs avant de marquer un mot | Contrôler la sortie exacte : poser tab[word_count] = NULL avant return | Écarter les effets de bord : avancer index caractère sans sauter le dernier mot",
    "explanation": "Sur ft_split, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-023",
    "category": "Pièges",
    "question": "ft_range : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier retourner le pointeur de base, jamais un pointeur avancé | Vérification prioritaire : définir step à +1 ou -1 selon start/end | Ordre sûr : écrire arr[i], puis value += step | Si erreur : if (!arr) return NULL immédiatement",
    "explanation": "Sur ft_range, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-024",
    "category": "Pièges",
    "question": "ft_range : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : start == end doit retourner un tableau de taille 1 | Confirmer la garde : définir step à +1 ou -1 selon start/end | Contrôler la sortie exacte : retourner le pointeur de base, jamais un pointeur avancé | Écarter les effets de bord : écrire arr[i], puis value += step",
    "explanation": "Sur ft_range, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-025",
    "category": "Pièges",
    "question": "ft_list_remove_if : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier laisser *begin_list cohérent après toutes suppressions | Vérification prioritaire : tester begin_list et *begin_list avant déréférence | Ordre sûr : tmp = cur->next, unlink, free(tmp), puis décider si cur avance | Si erreur : si liste vide, return sans toucher aux pointeurs",
    "explanation": "Sur ft_list_remove_if, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-026",
    "category": "Pièges",
    "question": "ft_list_remove_if : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : plusieurs suppressions consécutives | Confirmer la garde : tester begin_list et *begin_list avant déréférence | Contrôler la sortie exacte : laisser *begin_list cohérent après toutes suppressions | Écarter les effets de bord : tmp = cur->next, unlink, free(tmp), puis décider si cur avance",
    "explanation": "Sur ft_list_remove_if, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-027",
    "category": "Pièges",
    "question": "sort_list : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier arrêter après un passage complet sans swap | Vérification prioritaire : si la liste est vide ou à un maillon, return lst | Ordre sûr : swap data avec tmp, pas les liens des maillons | Si erreur : si cmp est instable, ne pas casser les liens",
    "explanation": "Sur sort_list, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-028",
    "category": "Pièges",
    "question": "sort_list : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : liste vide, liste à un maillon, éléments égaux | Confirmer la garde : si la liste est vide ou à un maillon, return lst | Contrôler la sortie exacte : arrêter après un passage complet sans swap | Écarter les effets de bord : swap data avec tmp, pas les liens des maillons",
    "explanation": "Sur sort_list, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-029",
    "category": "Pièges",
    "question": "itoa : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier poser str[len] = '\\0' avant return | Vérification prioritaire : gérer explicitement le cas n == 0 | Ordre sûr : remplir depuis la fin puis placer le signe | Si erreur : if (!str) return NULL",
    "explanation": "Sur itoa, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-030",
    "category": "Pièges",
    "question": "itoa : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : INT_MIN doit rester correct sans overflow | Confirmer la garde : gérer explicitement le cas n == 0 | Contrôler la sortie exacte : poser str[len] = '\\0' avant return | Écarter les effets de bord : remplir depuis la fin puis placer le signe",
    "explanation": "Sur itoa, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-031",
    "category": "Pièges",
    "question": "wdmatch : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier afficher argv[1] seulement si tout est consommé dans l’ordre | Vérification prioritaire : if (argc != 3) écrire uniquement un retour ligne | Ordre sûr : i2 avance toujours, i1 avance seulement sur match | Si erreur : si un caractère manque, ne pas afficher argv[1]",
    "explanation": "Sur wdmatch, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-032",
    "category": "Pièges",
    "question": "wdmatch : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : argv[1] vide doit être géré proprement | Confirmer la garde : if (argc != 3) écrire uniquement un retour ligne | Contrôler la sortie exacte : afficher argv[1] seulement si tout est consommé dans l’ordre | Écarter les effets de bord : i2 avance toujours, i1 avance seulement sur match",
    "explanation": "Sur wdmatch, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-033",
    "category": "Pièges",
    "question": "union : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier écrire un caractère inédit une seule fois | Vérification prioritaire : caster chaque char en unsigned char avant indexation | Ordre sûr : parcourir la première string puis la seconde | Si erreur : argc invalide, écrire un retour ligne et sortir",
    "explanation": "Sur union, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-034",
    "category": "Pièges",
    "question": "union : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : char signé négatif sur caractères étendus | Confirmer la garde : caster chaque char en unsigned char avant indexation | Contrôler la sortie exacte : écrire un caractère inédit une seule fois | Écarter les effets de bord : parcourir la première string puis la seconde",
    "explanation": "Sur union, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-035",
    "category": "Pièges",
    "question": "atoi : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier return sign * result sans affichage | Vérification prioritaire : arrêter au premier caractère non numérique | Ordre sûr : incrémenter l’index dans toutes les branches de lecture | Si erreur : entrée vide ou signe seul, retourner la valeur prévue par le sujet",
    "explanation": "Sur atoi, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-036",
    "category": "Pièges",
    "question": "atoi : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : gérer correctement -0 et les espaces initiaux | Confirmer la garde : arrêter au premier caractère non numérique | Contrôler la sortie exacte : return sign * result sans affichage | Écarter les effets de bord : incrémenter l’index dans toutes les branches de lecture",
    "explanation": "Sur atoi, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-037",
    "category": "Pièges",
    "question": "last_word : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier écrire exactement le dernier mot puis un retour ligne | Vérification prioritaire : if (argc != 2), écrire seulement un retour ligne | Ordre sûr : reculer jusqu’au début du mot puis afficher le segment | Si erreur : si aucun mot trouvé, écrire seulement un retour ligne",
    "explanation": "Sur last_word, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-038",
    "category": "Pièges",
    "question": "last_word : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : espaces et tabulations en fin de chaîne | Confirmer la garde : if (argc != 2), écrire seulement un retour ligne | Contrôler la sortie exacte : écrire exactement le dernier mot puis un retour ligne | Écarter les effets de bord : reculer jusqu’au début du mot puis afficher le segment",
    "explanation": "Sur last_word, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-039",
    "category": "Pièges",
    "question": "inter : le code compile mais la moulinette casse. Quel piège corriges-tu en premier ?",
    "answer": "Piège fréquent : oublier n’afficher chaque caractère commun qu’une seule fois | Vérification prioritaire : if (argc != 3), sortie minimale avec retour ligne | Ordre sûr : parcourir argv[1], scanner argv[2], marquer les déjà affichés | Si erreur : pas de caractère commun, afficher seulement un retour ligne",
    "explanation": "Sur inter, ce point évite un bug typique qui passe en local mais tombe en correction automatique. Ce type de bug apparaît surtout sur les tests cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-040",
    "category": "Pièges",
    "question": "inter : tu vois un comportement aléatoire. Quel test concret lève le doute rapidement ?",
    "answer": "Rejouer le cas limite : doublons multiples dans argv[1] | Confirmer la garde : if (argc != 3), sortie minimale avec retour ligne | Contrôler la sortie exacte : n’afficher chaque caractère commun qu’une seule fois | Écarter les effets de bord : parcourir argv[1], scanner argv[2], marquer les déjà affichés",
    "explanation": "Sur inter, ce point évite un bug typique qui passe en local mais tombe en correction automatique. La correction devient reproductible et non aléatoire.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-041",
    "category": "Réflexes mémoire",
    "question": "ft_split : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : allouer (words + 1) pointeurs puis chaque mot en len + 1 | Test immédiat : free les mots déjà alloués, free le tableau, return NULL | Contrat de libération : appelant responsable du free | Sortie sûre : poser tab[word_count] = NULL avant return",
    "explanation": "Sur ft_split, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-042",
    "category": "Réflexes mémoire",
    "question": "ft_split : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : free les mots déjà alloués, free le tableau, return NULL | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur ft_split, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-043",
    "category": "Réflexes mémoire",
    "question": "ft_range : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : malloc(size * sizeof(int)) | Test immédiat : if (!arr) return NULL immédiatement | Contrat de libération : appelant responsable du free | Sortie sûre : retourner le pointeur de base, jamais un pointeur avancé",
    "explanation": "Sur ft_range, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-044",
    "category": "Réflexes mémoire",
    "question": "ft_range : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : if (!arr) return NULL immédiatement | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur ft_range, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-045",
    "category": "Réflexes mémoire",
    "question": "ft_list_remove_if : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc, suppression en place | Test immédiat : si liste vide, return sans toucher aux pointeurs | Contrat de libération : appelant responsable du free | Sortie sûre : laisser *begin_list cohérent après toutes suppressions",
    "explanation": "Sur ft_list_remove_if, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-046",
    "category": "Réflexes mémoire",
    "question": "ft_list_remove_if : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : si liste vide, return sans toucher aux pointeurs | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur ft_list_remove_if, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-047",
    "category": "Réflexes mémoire",
    "question": "sort_list : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc, tri en place | Test immédiat : si cmp est instable, ne pas casser les liens | Contrat de libération : appelant responsable du free | Sortie sûre : arrêter après un passage complet sans swap",
    "explanation": "Sur sort_list, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-048",
    "category": "Réflexes mémoire",
    "question": "sort_list : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : si cmp est instable, ne pas casser les liens | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur sort_list, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-049",
    "category": "Réflexes mémoire",
    "question": "itoa : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : malloc(digits + sign + 1) | Test immédiat : if (!str) return NULL | Contrat de libération : appelant responsable du free | Sortie sûre : poser str[len] = '\\0' avant return",
    "explanation": "Sur itoa, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-050",
    "category": "Réflexes mémoire",
    "question": "itoa : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : if (!str) return NULL | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur itoa, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-051",
    "category": "Réflexes mémoire",
    "question": "wdmatch : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc dans la solution standard | Test immédiat : si un caractère manque, ne pas afficher argv[1] | Contrat de libération : appelant responsable du free | Sortie sûre : afficher argv[1] seulement si tout est consommé dans l’ordre",
    "explanation": "Sur wdmatch, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-052",
    "category": "Réflexes mémoire",
    "question": "wdmatch : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : si un caractère manque, ne pas afficher argv[1] | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur wdmatch, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-053",
    "category": "Réflexes mémoire",
    "question": "union : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc, tableau local seen | Test immédiat : argc invalide, écrire un retour ligne et sortir | Contrat de libération : appelant responsable du free | Sortie sûre : écrire un caractère inédit une seule fois",
    "explanation": "Sur union, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-054",
    "category": "Réflexes mémoire",
    "question": "union : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : argc invalide, écrire un retour ligne et sortir | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur union, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-055",
    "category": "Réflexes mémoire",
    "question": "atoi : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc nécessaire | Test immédiat : entrée vide ou signe seul, retourner la valeur prévue par le sujet | Contrat de libération : appelant responsable du free | Sortie sûre : return sign * result sans affichage",
    "explanation": "Sur atoi, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-056",
    "category": "Réflexes mémoire",
    "question": "atoi : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : entrée vide ou signe seul, retourner la valeur prévue par le sujet | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur atoi, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-057",
    "category": "Réflexes mémoire",
    "question": "last_word : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc, affichage direct | Test immédiat : si aucun mot trouvé, écrire seulement un retour ligne | Contrat de libération : appelant responsable du free | Sortie sûre : écrire exactement le dernier mot puis un retour ligne",
    "explanation": "Sur last_word, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-058",
    "category": "Réflexes mémoire",
    "question": "last_word : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : si aucun mot trouvé, écrire seulement un retour ligne | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur last_word, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-059",
    "category": "Réflexes mémoire",
    "question": "inter : tu retournes une donnée allouée. Quel réflexe mémoire appliquer tout de suite ?",
    "answer": "Allocation exacte : aucun malloc, logique en parcours | Test immédiat : pas de caractère commun, afficher seulement un retour ligne | Contrat de libération : appelant responsable du free | Sortie sûre : n’afficher chaque caractère commun qu’une seule fois",
    "explanation": "Sur inter, cette décision sécurise mémoire et ownership sans complexifier inutilement. Le contrat mémoire reste clair entre fonction et appelant.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-060",
    "category": "Réflexes mémoire",
    "question": "inter : une allocation intermédiaire échoue. Quelle séquence de cleanup exécuter ?",
    "answer": "Ne jamais continuer après échec : pas de caractère commun, afficher seulement un retour ligne | Libérer ce qui est déjà possédé | Ne pas free une zone jamais allouée | Retourner NULL de façon explicite",
    "explanation": "Sur inter, cette décision sécurise mémoire et ownership sans complexifier inutilement. Ce réflexe évite les fuites silencieuses en EX2-EX4.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-061",
    "category": "Pointeurs",
    "question": "ft_split : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : ignorer les séparateurs avant de marquer un mot | Avancer selon la règle : avancer index caractère sans sauter le dernier mot | Éviter toute adresse locale au return",
    "explanation": "Sur ft_split, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-062",
    "category": "Pointeurs",
    "question": "ft_split : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : poser tab[word_count] = NULL avant return",
    "explanation": "Sur ft_split, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-063",
    "category": "Pointeurs",
    "question": "ft_range : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : définir step à +1 ou -1 selon start/end | Avancer selon la règle : écrire arr[i], puis value += step | Éviter toute adresse locale au return",
    "explanation": "Sur ft_range, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-064",
    "category": "Pointeurs",
    "question": "ft_range : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : retourner le pointeur de base, jamais un pointeur avancé",
    "explanation": "Sur ft_range, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-065",
    "category": "Pointeurs",
    "question": "ft_list_remove_if : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : tester begin_list et *begin_list avant déréférence | Avancer selon la règle : tmp = cur->next, unlink, free(tmp), puis décider si cur avance | Éviter toute adresse locale au return",
    "explanation": "Sur ft_list_remove_if, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-066",
    "category": "Pointeurs",
    "question": "ft_list_remove_if : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : laisser *begin_list cohérent après toutes suppressions",
    "explanation": "Sur ft_list_remove_if, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-067",
    "category": "Pointeurs",
    "question": "sort_list : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : si la liste est vide ou à un maillon, return lst | Avancer selon la règle : swap data avec tmp, pas les liens des maillons | Éviter toute adresse locale au return",
    "explanation": "Sur sort_list, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-068",
    "category": "Pointeurs",
    "question": "sort_list : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : arrêter après un passage complet sans swap",
    "explanation": "Sur sort_list, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-069",
    "category": "Pointeurs",
    "question": "itoa : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : gérer explicitement le cas n == 0 | Avancer selon la règle : remplir depuis la fin puis placer le signe | Éviter toute adresse locale au return",
    "explanation": "Sur itoa, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-070",
    "category": "Pointeurs",
    "question": "itoa : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : poser str[len] = '\\0' avant return",
    "explanation": "Sur itoa, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-071",
    "category": "Pointeurs",
    "question": "wdmatch : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : if (argc != 3) écrire uniquement un retour ligne | Avancer selon la règle : i2 avance toujours, i1 avance seulement sur match | Éviter toute adresse locale au return",
    "explanation": "Sur wdmatch, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-072",
    "category": "Pointeurs",
    "question": "wdmatch : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : afficher argv[1] seulement si tout est consommé dans l’ordre",
    "explanation": "Sur wdmatch, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-073",
    "category": "Pointeurs",
    "question": "union : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : caster chaque char en unsigned char avant indexation | Avancer selon la règle : parcourir la première string puis la seconde | Éviter toute adresse locale au return",
    "explanation": "Sur union, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-074",
    "category": "Pointeurs",
    "question": "union : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : écrire un caractère inédit une seule fois",
    "explanation": "Sur union, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-075",
    "category": "Pointeurs",
    "question": "atoi : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : arrêter au premier caractère non numérique | Avancer selon la règle : incrémenter l’index dans toutes les branches de lecture | Éviter toute adresse locale au return",
    "explanation": "Sur atoi, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-076",
    "category": "Pointeurs",
    "question": "atoi : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : return sign * result sans affichage",
    "explanation": "Sur atoi, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-077",
    "category": "Pointeurs",
    "question": "last_word : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : if (argc != 2), écrire seulement un retour ligne | Avancer selon la règle : reculer jusqu’au début du mot puis afficher le segment | Éviter toute adresse locale au return",
    "explanation": "Sur last_word, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-078",
    "category": "Pointeurs",
    "question": "last_word : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : écrire exactement le dernier mot puis un retour ligne",
    "explanation": "Sur last_word, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-079",
    "category": "Pointeurs",
    "question": "inter : avant un unlink ou une écriture, quel pointeur dois-tu sécuriser ?",
    "answer": "Conserver l’adresse utile dans un temporaire | Déréférencer seulement après garde : if (argc != 3), sortie minimale avec retour ligne | Avancer selon la règle : parcourir argv[1], scanner argv[2], marquer les déjà affichés | Éviter toute adresse locale au return",
    "explanation": "Sur inter, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le temporaire empêche de perdre la chaîne ou le buffer.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-080",
    "category": "Pointeurs",
    "question": "inter : tu modifies la structure puis return. Quel réflexe pointeur évite un pointeur mort ?",
    "answer": "Conserver le pointeur de base pour le return | Ne jamais retourner l’adresse d’une variable locale | Vérifier la validité avant chaque -> ou * | Finaliser avec une sortie cohérente : n’afficher chaque caractère commun qu’une seule fois",
    "explanation": "Sur inter, la stabilité dépend du bon niveau d’indirection et de l’ordre des déréférencements. Le return reste valide après la sortie de fonction.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-081",
    "category": "Malloc",
    "question": "ft_split : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : allouer (words + 1) pointeurs puis chaque mot en len + 1 | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : free les mots déjà alloués, free le tableau, return NULL",
    "explanation": "Sur ft_split, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-082",
    "category": "Malloc",
    "question": "ft_split : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : free les mots déjà alloués, free le tableau, return NULL | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur ft_split, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-083",
    "category": "Malloc",
    "question": "ft_range : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : malloc(size * sizeof(int)) | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : if (!arr) return NULL immédiatement",
    "explanation": "Sur ft_range, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-084",
    "category": "Malloc",
    "question": "ft_range : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : if (!arr) return NULL immédiatement | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur ft_range, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-085",
    "category": "Malloc",
    "question": "ft_list_remove_if : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc, suppression en place | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : si liste vide, return sans toucher aux pointeurs",
    "explanation": "Sur ft_list_remove_if, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-086",
    "category": "Malloc",
    "question": "ft_list_remove_if : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : si liste vide, return sans toucher aux pointeurs | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur ft_list_remove_if, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-087",
    "category": "Malloc",
    "question": "sort_list : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc, tri en place | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : si cmp est instable, ne pas casser les liens",
    "explanation": "Sur sort_list, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-088",
    "category": "Malloc",
    "question": "sort_list : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : si cmp est instable, ne pas casser les liens | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur sort_list, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-089",
    "category": "Malloc",
    "question": "itoa : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : malloc(digits + sign + 1) | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : if (!str) return NULL",
    "explanation": "Sur itoa, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-090",
    "category": "Malloc",
    "question": "itoa : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : if (!str) return NULL | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur itoa, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-091",
    "category": "Malloc",
    "question": "wdmatch : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc dans la solution standard | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : si un caractère manque, ne pas afficher argv[1]",
    "explanation": "Sur wdmatch, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-092",
    "category": "Malloc",
    "question": "wdmatch : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : si un caractère manque, ne pas afficher argv[1] | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur wdmatch, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-093",
    "category": "Malloc",
    "question": "union : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc, tableau local seen | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : argc invalide, écrire un retour ligne et sortir",
    "explanation": "Sur union, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-094",
    "category": "Malloc",
    "question": "union : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : argc invalide, écrire un retour ligne et sortir | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur union, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-095",
    "category": "Malloc",
    "question": "atoi : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc nécessaire | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : entrée vide ou signe seul, retourner la valeur prévue par le sujet",
    "explanation": "Sur atoi, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-096",
    "category": "Malloc",
    "question": "atoi : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : entrée vide ou signe seul, retourner la valeur prévue par le sujet | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur atoi, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-097",
    "category": "Malloc",
    "question": "last_word : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc, affichage direct | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : si aucun mot trouvé, écrire seulement un retour ligne",
    "explanation": "Sur last_word, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-098",
    "category": "Malloc",
    "question": "last_word : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : si aucun mot trouvé, écrire seulement un retour ligne | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur last_word, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-099",
    "category": "Malloc",
    "question": "inter : quelle taille malloc dois-tu poser pour passer les tests limites ?",
    "answer": "Formule exacte : aucun malloc, logique en parcours | Inclure toujours la terminaison nécessaire | Éviter les tailles arbitraires | Tester l’échec avant toute écriture : pas de caractère commun, afficher seulement un retour ligne",
    "explanation": "Sur inter, ce choix d’allocation conditionne directement la réussite sur cas limites. Le sizing exact évite off-by-one et corruption mémoire.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-100",
    "category": "Malloc",
    "question": "inter : tu as un NULL de malloc en plein run. Quelle décision immédiate prendre ?",
    "answer": "Sortir proprement : pas de caractère commun, afficher seulement un retour ligne | Nettoyer les allocations déjà faites | Ne jamais écrire dans un pointeur NULL | Retourner un état d’échec explicite",
    "explanation": "Sur inter, ce choix d’allocation conditionne directement la réussite sur cas limites. Le chemin d’erreur doit être aussi propre que le nominal.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-101",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : tu supprimes en tête. Quel enchaînement évite de perdre la liste ?",
    "answer": "Stocker la tête cible dans tmp | Repointer *begin_list vers le suivant | Free(tmp) après reconnexion | Reboucler tant que la tête match",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le cas tête est le premier point de rupture en exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-102",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : deux maillons consécutifs doivent disparaître. Quel réflexe d’avancement ?",
    "answer": "Ne pas avancer cur après suppression | Rester sur le même cur pour retester cur->next | Utiliser tmp pour unlink puis free | Avancer cur seulement si aucun unlink",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Ce point évite de sauter un maillon à supprimer.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-103",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : avant d’accéder à cur->next->next, quel test est obligatoire ?",
    "answer": "Vérifier cur et cur->next | Ne jamais déréférencer sans garde | Sortir proprement si la chaîne est courte | Reprendre la boucle avec un état sûr",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. La garde évite un segfault sur fin de liste.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-104",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : suppression du dernier maillon. Que fais-tu dans l’ordre ?",
    "answer": "Trouver le maillon précédent | Mettre previous->next à NULL | Free le dernier maillon | Conserver la tête inchangée",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le lien précédent doit être corrigé avant free.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-105",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : liste vide en entrée. Quel comportement attendu à l’exam ?",
    "answer": "Retour immédiat sans déréférence | Aucun free hors contexte | Aucun accès à ->next | Fonction stable et silencieuse",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le cas vide est un test standard de robustesse.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-106",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : dans sort_list, quand arrêtes-tu les passes de tri ?",
    "answer": "Initialiser swapped à 0 en début de passe | Mettre swapped à 1 sur chaque échange | Arrêter quand une passe finit sans swap | Ne pas casser les liens pendant le tri",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le flag swapped supprime les boucles infinies.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-107",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : swap des maillons ou swap des data ? Quelle décision rapide prend-tu ?",
    "answer": "Privilégier le swap de data en exam | Utiliser tmp pour échanger proprement | Éviter de relier les next sans plan complet | Valider cmp avant chaque échange",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le swap de data est plus sûr sous contrainte de temps.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-108",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : après unlink d’un maillon, quel ordre garde l’intégrité mémoire ?",
    "answer": "Reconnexion des liens en premier | Free du maillon supprimé ensuite | Aucun accès au maillon après free | Poursuite du parcours avec pointeur valide",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Free trop tôt provoque corruption et lecture invalide.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-109",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : tous les éléments sont égaux. Quel résultat est correct ?",
    "answer": "Aucun swap inutile | swapped reste à 0 sur la passe | La liste reste stable | La fonction se termine sans boucle infinie",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le tri doit être stable même sans échange.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-110",
    "category": "Listes chaînées",
    "question": "ft_list_remove_if : tu nettoies plusieurs têtes d’affilée. Quel test pilote la boucle ?",
    "answer": "while (*begin_list && cmp(...) == 0) | tmp = *begin_list avant unlink | *begin_list = tmp->next puis free(tmp) | Répéter jusqu’à première tête conservée",
    "explanation": "Sur ft_list_remove_if, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Sans cette boucle, les suppressions en tête restent incomplètes.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-111",
    "category": "Listes chaînées",
    "question": "sort_list : tu supprimes en tête. Quel enchaînement évite de perdre la liste ?",
    "answer": "Stocker la tête cible dans tmp | Repointer *begin_list vers le suivant | Free(tmp) après reconnexion | Reboucler tant que la tête match",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le cas tête est le premier point de rupture en exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-112",
    "category": "Listes chaînées",
    "question": "sort_list : deux maillons consécutifs doivent disparaître. Quel réflexe d’avancement ?",
    "answer": "Ne pas avancer cur après suppression | Rester sur le même cur pour retester cur->next | Utiliser tmp pour unlink puis free | Avancer cur seulement si aucun unlink",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Ce point évite de sauter un maillon à supprimer.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-113",
    "category": "Listes chaînées",
    "question": "sort_list : avant d’accéder à cur->next->next, quel test est obligatoire ?",
    "answer": "Vérifier cur et cur->next | Ne jamais déréférencer sans garde | Sortir proprement si la chaîne est courte | Reprendre la boucle avec un état sûr",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. La garde évite un segfault sur fin de liste.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-114",
    "category": "Listes chaînées",
    "question": "sort_list : suppression du dernier maillon. Que fais-tu dans l’ordre ?",
    "answer": "Trouver le maillon précédent | Mettre previous->next à NULL | Free le dernier maillon | Conserver la tête inchangée",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le lien précédent doit être corrigé avant free.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-115",
    "category": "Listes chaînées",
    "question": "sort_list : liste vide en entrée. Quel comportement attendu à l’exam ?",
    "answer": "Retour immédiat sans déréférence | Aucun free hors contexte | Aucun accès à ->next | Fonction stable et silencieuse",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le cas vide est un test standard de robustesse.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-116",
    "category": "Listes chaînées",
    "question": "sort_list : dans sort_list, quand arrêtes-tu les passes de tri ?",
    "answer": "Initialiser swapped à 0 en début de passe | Mettre swapped à 1 sur chaque échange | Arrêter quand une passe finit sans swap | Ne pas casser les liens pendant le tri",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le flag swapped supprime les boucles infinies.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-117",
    "category": "Listes chaînées",
    "question": "sort_list : swap des maillons ou swap des data ? Quelle décision rapide prend-tu ?",
    "answer": "Privilégier le swap de data en exam | Utiliser tmp pour échanger proprement | Éviter de relier les next sans plan complet | Valider cmp avant chaque échange",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le swap de data est plus sûr sous contrainte de temps.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-118",
    "category": "Listes chaînées",
    "question": "sort_list : après unlink d’un maillon, quel ordre garde l’intégrité mémoire ?",
    "answer": "Reconnexion des liens en premier | Free du maillon supprimé ensuite | Aucun accès au maillon après free | Poursuite du parcours avec pointeur valide",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Free trop tôt provoque corruption et lecture invalide.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-119",
    "category": "Listes chaînées",
    "question": "sort_list : tous les éléments sont égaux. Quel résultat est correct ?",
    "answer": "Aucun swap inutile | swapped reste à 0 sur la passe | La liste reste stable | La fonction se termine sans boucle infinie",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Le tri doit être stable même sans échange.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-120",
    "category": "Listes chaînées",
    "question": "sort_list : tu nettoies plusieurs têtes d’affilée. Quel test pilote la boucle ?",
    "answer": "while (*begin_list && cmp(...) == 0) | tmp = *begin_list avant unlink | *begin_list = tmp->next puis free(tmp) | Répéter jusqu’à première tête conservée",
    "explanation": "Sur sort_list, l’ordre unlink/free/avancement est la clé pour éviter corruption et sauts. Sans cette boucle, les suppressions en tête restent incomplètes.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-121",
    "category": "Conditions limites",
    "question": "ft_split : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : string vide ou composée uniquement de séparateurs | Confirmer la garde : ignorer les séparateurs avant de marquer un mot | Contrôler la sortie : poser tab[word_count] = NULL avant return | Vérifier le comportement en erreur : free les mots déjà alloués, free le tableau, return NULL",
    "explanation": "Sur ft_split, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-122",
    "category": "Conditions limites",
    "question": "ft_split : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur ft_split, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-123",
    "category": "Conditions limites",
    "question": "ft_range : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : start == end doit retourner un tableau de taille 1 | Confirmer la garde : définir step à +1 ou -1 selon start/end | Contrôler la sortie : retourner le pointeur de base, jamais un pointeur avancé | Vérifier le comportement en erreur : if (!arr) return NULL immédiatement",
    "explanation": "Sur ft_range, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-124",
    "category": "Conditions limites",
    "question": "ft_range : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur ft_range, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-125",
    "category": "Conditions limites",
    "question": "ft_list_remove_if : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : plusieurs suppressions consécutives | Confirmer la garde : tester begin_list et *begin_list avant déréférence | Contrôler la sortie : laisser *begin_list cohérent après toutes suppressions | Vérifier le comportement en erreur : si liste vide, return sans toucher aux pointeurs",
    "explanation": "Sur ft_list_remove_if, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-126",
    "category": "Conditions limites",
    "question": "ft_list_remove_if : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur ft_list_remove_if, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-127",
    "category": "Conditions limites",
    "question": "sort_list : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : liste vide, liste à un maillon, éléments égaux | Confirmer la garde : si la liste est vide ou à un maillon, return lst | Contrôler la sortie : arrêter après un passage complet sans swap | Vérifier le comportement en erreur : si cmp est instable, ne pas casser les liens",
    "explanation": "Sur sort_list, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-128",
    "category": "Conditions limites",
    "question": "sort_list : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur sort_list, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-129",
    "category": "Conditions limites",
    "question": "itoa : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : INT_MIN doit rester correct sans overflow | Confirmer la garde : gérer explicitement le cas n == 0 | Contrôler la sortie : poser str[len] = '\\0' avant return | Vérifier le comportement en erreur : if (!str) return NULL",
    "explanation": "Sur itoa, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-130",
    "category": "Conditions limites",
    "question": "itoa : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur itoa, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-131",
    "category": "Conditions limites",
    "question": "wdmatch : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : argv[1] vide doit être géré proprement | Confirmer la garde : if (argc != 3) écrire uniquement un retour ligne | Contrôler la sortie : afficher argv[1] seulement si tout est consommé dans l’ordre | Vérifier le comportement en erreur : si un caractère manque, ne pas afficher argv[1]",
    "explanation": "Sur wdmatch, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-132",
    "category": "Conditions limites",
    "question": "wdmatch : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur wdmatch, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-133",
    "category": "Conditions limites",
    "question": "union : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : char signé négatif sur caractères étendus | Confirmer la garde : caster chaque char en unsigned char avant indexation | Contrôler la sortie : écrire un caractère inédit une seule fois | Vérifier le comportement en erreur : argc invalide, écrire un retour ligne et sortir",
    "explanation": "Sur union, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-134",
    "category": "Conditions limites",
    "question": "union : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur union, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-135",
    "category": "Conditions limites",
    "question": "atoi : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : gérer correctement -0 et les espaces initiaux | Confirmer la garde : arrêter au premier caractère non numérique | Contrôler la sortie : return sign * result sans affichage | Vérifier le comportement en erreur : entrée vide ou signe seul, retourner la valeur prévue par le sujet",
    "explanation": "Sur atoi, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-136",
    "category": "Conditions limites",
    "question": "atoi : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur atoi, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-137",
    "category": "Conditions limites",
    "question": "last_word : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : espaces et tabulations en fin de chaîne | Confirmer la garde : if (argc != 2), écrire seulement un retour ligne | Contrôler la sortie : écrire exactement le dernier mot puis un retour ligne | Vérifier le comportement en erreur : si aucun mot trouvé, écrire seulement un retour ligne",
    "explanation": "Sur last_word, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-138",
    "category": "Conditions limites",
    "question": "last_word : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur last_word, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-139",
    "category": "Conditions limites",
    "question": "inter : quel cas limite testes-tu en premier avant de valider la fonction ?",
    "answer": "Cas critique : doublons multiples dans argv[1] | Confirmer la garde : if (argc != 3), sortie minimale avec retour ligne | Contrôler la sortie : n’afficher chaque caractère commun qu’une seule fois | Vérifier le comportement en erreur : pas de caractère commun, afficher seulement un retour ligne",
    "explanation": "Sur inter, ce cas est testé tôt à l’exam et doit être géré explicitement. Le premier crash exam vient souvent de ce cas ignoré.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-140",
    "category": "Conditions limites",
    "question": "inter : en entrée minimale, quel comportement doit rester stable ?",
    "answer": "Aucune déréférence sans garde | Aucune allocation inutile | Retour déterministe et conforme | Sortie attendue strictement respectée",
    "explanation": "Sur inter, ce cas est testé tôt à l’exam et doit être géré explicitement. Un cas minimal bien géré évite la majorité des rejets cachés.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-141",
    "category": "Règles implicites des énoncés",
    "question": "ft_split : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur ft_split, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-142",
    "category": "Règles implicites des énoncés",
    "question": "ft_split : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : si argc invalide dans un main test, écrire seulement un retour ligne | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur ft_split, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-143",
    "category": "Règles implicites des énoncés",
    "question": "ft_range : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur ft_range, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-144",
    "category": "Règles implicites des énoncés",
    "question": "ft_range : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : respecter exactement le prototype demandé | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur ft_range, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-145",
    "category": "Règles implicites des énoncés",
    "question": "ft_list_remove_if : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur ft_list_remove_if, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-146",
    "category": "Règles implicites des énoncés",
    "question": "ft_list_remove_if : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : garder la signature imposée avec free_fct | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur ft_list_remove_if, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-147",
    "category": "Règles implicites des énoncés",
    "question": "sort_list : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur sort_list, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-148",
    "category": "Règles implicites des énoncés",
    "question": "sort_list : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : respecter la convention cmp(a, b) > 0 pour swap | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur sort_list, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-149",
    "category": "Règles implicites des énoncés",
    "question": "itoa : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur itoa, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-150",
    "category": "Règles implicites des énoncés",
    "question": "itoa : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : la fonction retourne une string, elle ne doit rien afficher | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur itoa, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-151",
    "category": "Règles implicites des énoncés",
    "question": "wdmatch : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur wdmatch, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-152",
    "category": "Règles implicites des énoncés",
    "question": "wdmatch : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : sortie stricte sans texte additionnel | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur wdmatch, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-153",
    "category": "Règles implicites des énoncés",
    "question": "union : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur union, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-154",
    "category": "Règles implicites des énoncés",
    "question": "union : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : respecter le format exact de sortie demandé | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur union, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-155",
    "category": "Règles implicites des énoncés",
    "question": "atoi : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur atoi, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-156",
    "category": "Règles implicites des énoncés",
    "question": "atoi : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : pas de sortie texte dans la fonction | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur atoi, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-157",
    "category": "Règles implicites des énoncés",
    "question": "last_word : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur last_word, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-158",
    "category": "Règles implicites des énoncés",
    "question": "last_word : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : aucun espace en trop dans la sortie | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur last_word, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-159",
    "category": "Règles implicites des énoncés",
    "question": "inter : l’énoncé impose un prototype strict. Quelle vérification fais-tu avant rendu ?",
    "answer": "Signature identique au sujet | Fonctions autorisées uniquement | Aucun print de debug | Sortie formatée exactement comme demandé",
    "explanation": "Sur inter, la conformité de sortie et de signature compte autant que l’algorithme. Même un bon algo est refusé si le contrat est brisé.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-160",
    "category": "Règles implicites des énoncés",
    "question": "inter : argc est invalide dans le main de test. Quel comportement conforme appliques-tu ?",
    "answer": "Règle d’énoncé : sortie stricte sans message de debug | Ne pas ajouter de message personnel | Conserver stdout conforme | Quitter proprement sans effet de bord",
    "explanation": "Sur inter, la conformité de sortie et de signature compte autant que l’algorithme. La moulinette compare la sortie caractère par caractère.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  }
]
