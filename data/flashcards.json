[
  {
    "id": "fc-001",
    "category": "Patterns",
    "question": "Tu dois convertir un int en string. Quel pattern appliquer?",
    "answer": "A mémoriser: Pour itoa, l'ordre clé est: signe, cast long, taille exacte, remplissage de droite à gauche. | Méthode concrète: 1) gérer le signe -> 2) caster en long -> 3) compter chiffres -> 4) malloc taille +1 (+1 si négatif) -> 5) '\\0' final -> 6) remplir à l’envers -> 7) poser '-' si besoin | Erreur fréquente: Sans cast long, INT_MIN déborde; sans bonne taille, la chaîne est corrompue. | Auto-vérification: Teste 0, positif, négatif et INT_MIN.",
    "explanation": "Exemple: `itoa(-2147483648)` doit rester correct. Contexte: Tu dois convertir un int en string. Quel pattern appliquer? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-002",
    "category": "Patterns",
    "question": "Avant de coder split, quel pattern préparer?",
    "answer": "A mémoriser: Pour split, fais d'abord le comptage, ensuite l'allocation, puis la copie mot par mot. | Méthode concrète: 1) définir séparateurs -> 2) ignorer séparateurs -> 3) compter mots -> 4) malloc tableau (mots + NULL) -> 5) pour chaque mot : compter lettres -> 6) malloc mot +1 -> 7) copier -> 8) NULL final | Erreur fréquente: Mélanger comptage et copie crée des off-by-one et un NULL final oublié. | Auto-vérification: Teste chaîne vide, séparateurs seuls et dernier mot sans séparateur final.",
    "explanation": "Exemple: `split(\"  abc  def\")` doit donner 2 mots puis NULL. Contexte: Avant de coder split, quel pattern préparer? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-003",
    "category": "Patterns",
    "question": "Quel est le pattern pour remplir un tableau de start à end?",
    "answer": "A mémoriser: Dans ft_range, taille inclusive + step (+1/-1) est le réflexe central. | Méthode concrète: 1) calculer taille = abs(end-start)+1 -> 2) step = +1 ou -1 -> 3) malloc -> 4) boucle de remplissage -> 5) return ptr | Erreur fréquente: Le bug classique est l'off-by-one sur le nombre d'éléments. | Auto-vérification: Teste start=end, start<end, start>end.",
    "explanation": "Exemple: `ft_range(3,0)` doit produire 3,2,1,0. Contexte: Quel est le pattern pour remplir un tableau de start à end? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-004",
    "category": "Patterns",
    "question": "Comment éviter les doublons de caractères?",
    "answer": "A mémoriser: Anti-doublon: `seen[256]` et index en `unsigned char`. | Méthode concrète: 1) tableau seen[256] -> 2) indexer avec unsigned char -> 3) afficher si seen == 0 -> 4) marquer seen = 1 | Erreur fréquente: Un index signé peut devenir négatif et sortir des bornes. | Auto-vérification: Initialise seen à 0 et marque dès qu'un caractère est accepté.",
    "explanation": "Exemple: un caractère déjà vu n'est plus affiché. Contexte: Comment éviter les doublons de caractères? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-005",
    "category": "Patterns",
    "question": "Quel est le pattern de wdmatch?",
    "answer": "A mémoriser: wdmatch repose sur l'ordre: on scanne la grande chaîne en avançant l'index cible au match. | Méthode concrète: 1) parcourir string 2 -> 2) avancer index string 1 quand match -> 3) fin si index1 == fin -> 4) afficher string 1 si réussi | Erreur fréquente: Un mauvais sens de parcours donne des faux positifs. | Auto-vérification: Valide que toute la petite chaîne est consommée dans l'ordre.",
    "explanation": "Exemple: `abc` matche `aXbYc`, pas `acb`. Contexte: Quel est le pattern de wdmatch? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-006",
    "category": "Patterns",
    "question": "Quel est le pattern de strdup?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) compter longueur -> 2) malloc len +1 -> 3) copier -> 4) '\\0' | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Quel est le pattern de strdup? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-007",
    "category": "Patterns",
    "question": "Comment parcourir une liste?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) cur = begin -> 2) while(cur) -> 3) appliquer f(cur->data) -> 4) cur = cur->next | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Comment parcourir une liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-008",
    "category": "Patterns",
    "question": "Quel est le pattern général?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) nettoyer tête avec while -> 2) utiliser double pointeur -> 3) parcourir avec cur -> 4) tmp = cur->next -> 5) unlink -> 6) free(tmp) | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Quel est le pattern général? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-009",
    "category": "Patterns",
    "question": "Quel pattern simple pour trier une liste?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) bubble sort -> 2) flag swapped -> 3) parcourir -> 4) swap data -> 5) recommencer si swapped | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Quel pattern simple pour trier une liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-010",
    "category": "Patterns",
    "question": "Pattern classique pour atoi?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) ignorer espaces -> 2) gérer signe -> 3) accumuler n = n*10 + digit -> 4) return résultat | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Pattern classique pour atoi? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-011",
    "category": "Patterns",
    "question": "Pattern pour trouver le dernier mot?",
    "answer": "A mémoriser: Pour split, fais d'abord le comptage, ensuite l'allocation, puis la copie mot par mot. | Méthode concrète: 1) aller en fin -> 2) reculer sur séparateurs -> 3) marquer fin -> 4) reculer lettres -> 5) afficher segment | Erreur fréquente: Mélanger comptage et copie crée des off-by-one et un NULL final oublié. | Auto-vérification: Teste chaîne vide, séparateurs seuls et dernier mot sans séparateur final.",
    "explanation": "Exemple: `split(\"  abc  def\")` doit donner 2 mots puis NULL. Contexte: Pattern pour trouver le dernier mot? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-012",
    "category": "Patterns",
    "question": "Comment inverser une string?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) deux indices i/j -> 2) swap -> 3) i++ / j-- -> 4) stop quand i >= j | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Comment inverser une string? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-013",
    "category": "Patterns",
    "question": "Pattern de remplacement simple?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) parcourir string -> 2) if char == cible → remplacer -> 3) write char | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Pattern de remplacement simple? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-014",
    "category": "Patterns",
    "question": "Comment compter les maillons?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) count = 0 -> 2) while(lst) -> 3) count++ -> 4) lst = lst->next | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Comment compter les maillons? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-015",
    "category": "Patterns",
    "question": "Pattern pour afficher une string?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) parcourir -> 2) write(1,&c,1) -> 3) '\\n' si demandé | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Pattern pour afficher une string? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-016",
    "category": "Patterns",
    "question": "Pattern de rotation de lettres?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) tester plage a-z / A-Z -> 2) décaler -> 3) wrap si dépasse -> 4) écrire char | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Pattern de rotation de lettres? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-017",
    "category": "Patterns",
    "question": "Pattern pour parcourir argv?",
    "answer": "A mémoriser: En exam, pattern d'affichage = traitement minimal + sortie exacte. | Méthode concrète: 1) i = 1 -> 2) while(argv[i]) -> 3) traiter -> 4) i++ | Erreur fréquente: Un caractère de trop ou un `\\n` manquant suffit à rater les tests. | Auto-vérification: Vérifie la sortie au caractère près.",
    "explanation": "Exemple: `cat -e` montre les fins de ligne. Contexte: Pattern pour parcourir argv? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-018",
    "category": "Patterns",
    "question": "Comment supprimer plusieurs têtes?",
    "answer": "A mémoriser: Un pattern est une séquence stable: sous pression, tu exécutes l'ordre au lieu d'improviser. | Méthode concrète: 1) while(*begin && cmp(...)==0) -> 2) tmp = *begin -> 3) *begin = tmp->next -> 4) free(tmp) | Erreur fréquente: Improviser l'ordre provoque des oublis sur les cas limites. | Auto-vérification: Refais mentalement chaque étape avant de compiler.",
    "explanation": "Exemple: garde une mini-checklist visible pendant l'exercice. Contexte: Comment supprimer plusieurs têtes? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-019",
    "category": "Patterns",
    "question": "Comment repérer un début de mot?",
    "answer": "A mémoriser: Pour split, fais d'abord le comptage, ensuite l'allocation, puis la copie mot par mot. | Méthode concrète: 1) caractère non séparateur -> 2) précédé par séparateur ou début -> 3) start index | Erreur fréquente: Mélanger comptage et copie crée des off-by-one et un NULL final oublié. | Auto-vérification: Teste chaîne vide, séparateurs seuls et dernier mot sans séparateur final.",
    "explanation": "Exemple: `split(\"  abc  def\")` doit donner 2 mots puis NULL. Contexte: Comment repérer un début de mot? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-020",
    "category": "Patterns",
    "question": "Pattern d’affichage à l’exam?",
    "answer": "A mémoriser: En exam, pattern d'affichage = traitement minimal + sortie exacte. | Méthode concrète: 1) respecter strictement -> 2) write only -> 3) newline final -> 4) rien en trop | Erreur fréquente: Un caractère de trop ou un `\\n` manquant suffit à rater les tests. | Auto-vérification: Vérifie la sortie au caractère près.",
    "explanation": "Exemple: `cat -e` montre les fins de ligne. Contexte: Pattern d’affichage à l’exam? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-021",
    "category": "Pièges",
    "question": "Tu copies une string sans ajouter '\\0'. Que risque-tu?",
    "answer": "A mémoriser: Une string C doit toujours avoir de la place pour `\\0`. | Méthode concrète: 1) lecture hors limites -> 2) affichage aléatoire -> 3) crash possible -> 4) tests KO | Erreur fréquente: Sans terminaison, lecture hors limites et sortie instable. | Auto-vérification: Alloue `len + 1` et pose explicitement `\\0`.",
    "explanation": "Exemple: `malloc(len)` est faux pour copier une string. Contexte: Tu copies une string sans ajouter '\\0'. Que risque-tu? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-022",
    "category": "Pièges",
    "question": "Tu fais malloc(len) pour une string. Problème?",
    "answer": "A mémoriser: Une string C doit toujours avoir de la place pour `\\0`. | Méthode concrète: 1) pas de place pour '\\0' -> 2) écriture hors tableau -> 3) comportement indéfini | Erreur fréquente: Sans terminaison, lecture hors limites et sortie instable. | Auto-vérification: Alloue `len + 1` et pose explicitement `\\0`.",
    "explanation": "Exemple: `malloc(len)` est faux pour copier une string. Contexte: Tu fais malloc(len) pour une string. Problème? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-023",
    "category": "Pièges",
    "question": "argc n’est pas celui attendu. Que faire?",
    "answer": "A mémoriser: Si argc est faux, applique exactement la sortie demandée, sans texte perso. | Méthode concrète: 1) afficher seulement '\\n' -> 2) rien d’autre | Erreur fréquente: Le moindre affichage en trop invalide le rendu. | Auto-vérification: Dans ces sujets, c'est souvent uniquement `\\n`.",
    "explanation": "Exemple: pas de message d'erreur libre si non demandé. Contexte: argc n’est pas celui attendu. Que faire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-024",
    "category": "Pièges",
    "question": "Tu utilises char comme index dans seen[256]. Danger?",
    "answer": "A mémoriser: Pour `seen[256]`, caste toujours en `unsigned char`. | Méthode concrète: 1) valeur négative possible -> 2) accès hors tableau -> 3) caster unsigned char | Erreur fréquente: Un char signé peut pointer hors tableau. | Auto-vérification: Utilise `seen[(unsigned char)c]`.",
    "explanation": "Exemple: tu évites les index négatifs sur caractères étendus. Contexte: Tu utilises char comme index dans seen[256]. Danger? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-025",
    "category": "Pièges",
    "question": "Dans remove_if, tu avances cur après unlink. Risque?",
    "answer": "A mémoriser: En suppression de liste, n'avance jamais au mauvais moment. | Méthode concrète: 1) sauter un maillon -> 2) suppression incomplète | Erreur fréquente: Tu sautes des maillons et rates des suppressions. | Auto-vérification: Séquence sûre: tmp -> unlink -> free -> décider l'avance.",
    "explanation": "Exemple: deux éléments consécutifs à supprimer révèlent le bug. Contexte: Dans remove_if, tu avances cur après unlink. Risque? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-026",
    "category": "Pièges",
    "question": "itoa sans gérer INT_MIN?",
    "answer": "A mémoriser: INT_MIN exige un cast en long avant négation ou modulo. | Méthode concrète: 1) overflow -> 2) valeur fausse -> 3) tests ratés | Erreur fréquente: Sans cast, overflow et résultat faux. | Auto-vérification: Teste explicitement INT_MIN.",
    "explanation": "Exemple: `-2147483648` est le cas révélateur. Contexte: itoa sans gérer INT_MIN? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-027",
    "category": "Pièges",
    "question": "write est imposé mais tu utilises printf.",
    "answer": "A mémoriser: Si `write` est imposé, `printf` est hors contrat. | Méthode concrète: 1) interdit -> 2) note = 0 -> 3) tests KO | Erreur fréquente: Tu peux avoir 0 même si la logique est bonne. | Auto-vérification: Vérifie la liste Allowed functions avant rendu.",
    "explanation": "Exemple: conformité des fonctions est aussi importante que l'algorithme. Contexte: write est imposé mais tu utilises printf. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-028",
    "category": "Pièges",
    "question": "Tu free un maillon avant de reconnecter la liste.",
    "answer": "A mémoriser: En suppression de liste, n'avance jamais au mauvais moment. | Méthode concrète: 1) corruption -> 2) accès mémoire invalide | Erreur fréquente: Tu sautes des maillons et rates des suppressions. | Auto-vérification: Séquence sûre: tmp -> unlink -> free -> décider l'avance.",
    "explanation": "Exemple: deux éléments consécutifs à supprimer révèlent le bug. Contexte: Tu free un maillon avant de reconnecter la liste. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-029",
    "category": "Pièges",
    "question": "Tu oublies le NULL final dans split.",
    "answer": "A mémoriser: Une string C doit toujours avoir de la place pour `\\0`. | Méthode concrète: 1) parcours infini -> 2) segfault | Erreur fréquente: Sans terminaison, lecture hors limites et sortie instable. | Auto-vérification: Alloue `len + 1` et pose explicitement `\\0`.",
    "explanation": "Exemple: `malloc(len)` est faux pour copier une string. Contexte: Tu oublies le NULL final dans split. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-030",
    "category": "Pièges",
    "question": "len non initialisé avant comptage.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) taille aléatoire -> 2) malloc faux -> 3) crash | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: len non initialisé avant comptage. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-031",
    "category": "Pièges",
    "question": "Tu free deux fois le même pointeur.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) segfault -> 2) corruption heap | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu free deux fois le même pointeur. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-032",
    "category": "Pièges",
    "question": "Tu écris `*p = malloc(10)` alors que p est `char *`.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) type invalide -> 2) écrasement mémoire | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu écris `*p = malloc(10)` alors que p est `char *`. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-033",
    "category": "Pièges",
    "question": "Tu retournes l’adresse d’une variable locale.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) dangling pointer -> 2) crash futur | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu retournes l’adresse d’une variable locale. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-034",
    "category": "Pièges",
    "question": "Boucle i <= len au lieu de i < len.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) dépassement -> 2) corruption | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Boucle i <= len au lieu de i < len. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-035",
    "category": "Pièges",
    "question": "Tu oublies d’ignorer les séparateurs dans split.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) mots vides -> 2) mauvaise sortie | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu oublies d’ignorer les séparateurs dans split. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-036",
    "category": "Pièges",
    "question": "Tu ne vérifies pas malloc.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) segfault si NULL | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu ne vérifies pas malloc. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-037",
    "category": "Pièges",
    "question": "seen[256] non initialisé.",
    "answer": "A mémoriser: Pour `seen[256]`, caste toujours en `unsigned char`. | Méthode concrète: 1) faux doublons -> 2) comportement aléatoire | Erreur fréquente: Un char signé peut pointer hors tableau. | Auto-vérification: Utilise `seen[(unsigned char)c]`.",
    "explanation": "Exemple: tu évites les index négatifs sur caractères étendus. Contexte: seen[256] non initialisé. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-038",
    "category": "Pièges",
    "question": "Dans une liste, tu avances cur au mauvais moment.",
    "answer": "A mémoriser: En suppression de liste, n'avance jamais au mauvais moment. | Méthode concrète: 1) élément ignoré -> 2) bug logique | Erreur fréquente: Tu sautes des maillons et rates des suppressions. | Auto-vérification: Séquence sûre: tmp -> unlink -> free -> décider l'avance.",
    "explanation": "Exemple: deux éléments consécutifs à supprimer révèlent le bug. Contexte: Dans une liste, tu avances cur au mauvais moment. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-039",
    "category": "Pièges",
    "question": "L’énoncé demande un newline final, tu l’oublies.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) tests automatiques échouent | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: L’énoncé demande un newline final, tu l’oublies. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-040",
    "category": "Pièges",
    "question": "Tu fais malloc(1000) “pour être large”.",
    "answer": "A mémoriser: Un piège d'exam est souvent discret: anticipe-le avant d'écrire la boucle principale. | Méthode concrète: 1) pas robuste -> 2) tests limites ratés -> 3) mauvaise pratique | Erreur fréquente: Le programme compile, mais casse sur les tests automatiques. | Auto-vérification: Inspecte bornes, terminaison, et ordre des pointeurs.",
    "explanation": "Exemple: relis chaque condition de boucle et chaque incrément. Contexte: Tu fais malloc(1000) “pour être large”. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-041",
    "category": "Réflexes mémoire",
    "question": "Tu alloues une string copiée. Quelle taille minimale?",
    "answer": "A mémoriser: Terminaisons obligatoires: `\\0` pour string, `NULL` pour tableau de strings. | Méthode concrète: 1) longueur + 1 -> 2) place pour '\\0' | Erreur fréquente: Sans terminaison, le parcours lit trop loin. | Auto-vérification: Ajoute la terminaison dès la conception.",
    "explanation": "Exemple: split doit finir par un pointeur NULL. Contexte: Tu alloues une string copiée. Quelle taille minimale? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-042",
    "category": "Réflexes mémoire",
    "question": "Quel est le premier test après malloc?",
    "answer": "A mémoriser: Après malloc, premier réflexe: `if (!ptr)`. | Méthode concrète: 1) if (!ptr) return NULL; | Erreur fréquente: Déréférencer NULL provoque un crash immédiat. | Auto-vérification: Prévois le chemin d'échec avant de remplir.",
    "explanation": "Exemple: en split, libère le déjà alloué si une étape échoue. Contexte: Quel est le premier test après malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-043",
    "category": "Réflexes mémoire",
    "question": "Comment doit se terminer un tableau de strings?",
    "answer": "A mémoriser: Terminaisons obligatoires: `\\0` pour string, `NULL` pour tableau de strings. | Méthode concrète: 1) pointeur NULL final | Erreur fréquente: Sans terminaison, le parcours lit trop loin. | Auto-vérification: Ajoute la terminaison dès la conception.",
    "explanation": "Exemple: split doit finir par un pointeur NULL. Contexte: Comment doit se terminer un tableau de strings? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-044",
    "category": "Réflexes mémoire",
    "question": "Quand libérer un maillon supprimé?",
    "answer": "A mémoriser: La mémoire doit être libérée par le bon owner et dans le bon ordre. | Méthode concrète: 1) après avoir reconnecté la liste | Erreur fréquente: Mauvais owner ou mauvais ordre = fuite ou corruption. | Auto-vérification: Sur liste: reconnecter puis free.",
    "explanation": "Exemple: unlink avant free dans remove_if. Contexte: Quand libérer un maillon supprimé? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-045",
    "category": "Réflexes mémoire",
    "question": "Pourquoi écrire sizeof(type) * n?",
    "answer": "A mémoriser: Calcule toujours en octets réels avec `sizeof(type) * n`. | Méthode concrète: 1) nombre d’octets correct | Erreur fréquente: `sizeof(ptr)` retourne la taille du pointeur, pas de l'élément. | Auto-vérification: Relis chaque formule de malloc.",
    "explanation": "Exemple: un tableau de int demande `sizeof(int) * n`. Contexte: Pourquoi écrire sizeof(type) * n? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-046",
    "category": "Réflexes mémoire",
    "question": "Quelle taille malloc pour \"-42\"?",
    "answer": "A mémoriser: Après malloc, premier réflexe: `if (!ptr)`. | Méthode concrète: 1) 4 caractères : '-', '4', '2', '\\0' | Erreur fréquente: Déréférencer NULL provoque un crash immédiat. | Auto-vérification: Prévois le chemin d'échec avant de remplir.",
    "explanation": "Exemple: en split, libère le déjà alloué si une étape échoue. Contexte: Quelle taille malloc pour \"-42\"? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-047",
    "category": "Réflexes mémoire",
    "question": "Que faire après free(ptr)?",
    "answer": "A mémoriser: La mémoire doit être libérée par le bon owner et dans le bon ordre. | Méthode concrète: 1) ptr = NULL (si possible) | Erreur fréquente: Mauvais owner ou mauvais ordre = fuite ou corruption. | Auto-vérification: Sur liste: reconnecter puis free.",
    "explanation": "Exemple: unlink avant free dans remove_if. Contexte: Que faire après free(ptr)? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-048",
    "category": "Réflexes mémoire",
    "question": "Pourquoi compter avant malloc?",
    "answer": "A mémoriser: Après malloc, premier réflexe: `if (!ptr)`. | Méthode concrète: 1) allouer juste -> 2) éviter dépassement | Erreur fréquente: Déréférencer NULL provoque un crash immédiat. | Auto-vérification: Prévois le chemin d'échec avant de remplir.",
    "explanation": "Exemple: en split, libère le déjà alloué si une étape échoue. Contexte: Pourquoi compter avant malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-049",
    "category": "Réflexes mémoire",
    "question": "Pourquoi initialiser seen[256]?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) éviter faux positifs -> 2) état propre | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Pourquoi initialiser seen[256]? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-050",
    "category": "Réflexes mémoire",
    "question": "Qui doit free la mémoire retournée par une fonction?",
    "answer": "A mémoriser: La mémoire doit être libérée par le bon owner et dans le bon ordre. | Méthode concrète: 1) l’appelant | Erreur fréquente: Mauvais owner ou mauvais ordre = fuite ou corruption. | Auto-vérification: Sur liste: reconnecter puis free.",
    "explanation": "Exemple: unlink avant free dans remove_if. Contexte: Qui doit free la mémoire retournée par une fonction? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-051",
    "category": "Réflexes mémoire",
    "question": "Comment allouer un tableau de pointeurs vers mots?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) malloc(nb_mots + 1) -> 2) NULL final | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Comment allouer un tableau de pointeurs vers mots? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-052",
    "category": "Réflexes mémoire",
    "question": "Pourquoi caster en long dans itoa?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) éviter overflow (INT_MIN) | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Pourquoi caster en long dans itoa? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-053",
    "category": "Réflexes mémoire",
    "question": "Pourquoi caster en unsigned char?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) éviter index négatif | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Pourquoi caster en unsigned char? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-054",
    "category": "Réflexes mémoire",
    "question": "Pourquoi initialiser len = 0?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) éviter valeur aléatoire | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Pourquoi initialiser len = 0? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-055",
    "category": "Réflexes mémoire",
    "question": "Si malloc échoue au milieu de split?",
    "answer": "A mémoriser: Après malloc, premier réflexe: `if (!ptr)`. | Méthode concrète: 1) free ce qui est déjà alloué | Erreur fréquente: Déréférencer NULL provoque un crash immédiat. | Auto-vérification: Prévois le chemin d'échec avant de remplir.",
    "explanation": "Exemple: en split, libère le déjà alloué si une étape échoue. Contexte: Si malloc échoue au milieu de split? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-056",
    "category": "Réflexes mémoire",
    "question": "Pourquoi éviter malloc(1000) arbitraire?",
    "answer": "A mémoriser: Après malloc, premier réflexe: `if (!ptr)`. | Méthode concrète: 1) imprécis -> 2) fragile | Erreur fréquente: Déréférencer NULL provoque un crash immédiat. | Auto-vérification: Prévois le chemin d'échec avant de remplir.",
    "explanation": "Exemple: en split, libère le déjà alloué si une étape échoue. Contexte: Pourquoi éviter malloc(1000) arbitraire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-057",
    "category": "Réflexes mémoire",
    "question": "Pourquoi ajouter '\\0'?",
    "answer": "A mémoriser: Terminaisons obligatoires: `\\0` pour string, `NULL` pour tableau de strings. | Méthode concrète: 1) terminaison string -> 2) affichage correct | Erreur fréquente: Sans terminaison, le parcours lit trop loin. | Auto-vérification: Ajoute la terminaison dès la conception.",
    "explanation": "Exemple: split doit finir par un pointeur NULL. Contexte: Pourquoi ajouter '\\0'? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-058",
    "category": "Réflexes mémoire",
    "question": "Pourquoi t_list ** dans remove_if?",
    "answer": "A mémoriser: Les réflexes mémoire visent la sécurité: taille juste, contrôle d'échec, ownership clair. | Méthode concrète: 1) modifier la tête -> 2) éviter perdre accès | Erreur fréquente: Sans ces automatismes, tu alternes entre fuites, dépassements et crashs. | Auto-vérification: Répète: calcul, malloc, test, usage, free.",
    "explanation": "Exemple: note mentalement qui alloue et qui libère. Contexte: Pourquoi t_list ** dans remove_if? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-059",
    "category": "Réflexes mémoire",
    "question": "Pourquoi sizeof(ptr) est souvent faux?",
    "answer": "A mémoriser: Calcule toujours en octets réels avec `sizeof(type) * n`. | Méthode concrète: 1) taille pointeur -> 2) pas taille élément | Erreur fréquente: `sizeof(ptr)` retourne la taille du pointeur, pas de l'élément. | Auto-vérification: Relis chaque formule de malloc.",
    "explanation": "Exemple: un tableau de int demande `sizeof(int) * n`. Contexte: Pourquoi sizeof(ptr) est souvent faux? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-060",
    "category": "Réflexes mémoire",
    "question": "Que fait free(NULL)?",
    "answer": "A mémoriser: Terminaisons obligatoires: `\\0` pour string, `NULL` pour tableau de strings. | Méthode concrète: 1) rien -> 2) sûr | Erreur fréquente: Sans terminaison, le parcours lit trop loin. | Auto-vérification: Ajoute la terminaison dès la conception.",
    "explanation": "Exemple: split doit finir par un pointeur NULL. Contexte: Que fait free(NULL)? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-061",
    "category": "Pointeurs",
    "question": "Qu’est-ce qu’un pointeur en C?",
    "answer": "A mémoriser: Un pointeur stocke une adresse mémoire, pas la valeur elle-même. | Méthode concrète: 1) une variable qui contient une adresse mémoire | Erreur fréquente: Confondre adresse et valeur fausse les affectations. | Auto-vérification: Associe chaque variable à son type exact.",
    "explanation": "Exemple: `p = &x` relie p à x. Contexte: Qu’est-ce qu’un pointeur en C? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-062",
    "category": "Pointeurs",
    "question": "Que fait `*p`?",
    "answer": "A mémoriser: `*` déréférence, `&` prend une adresse, `->` accède à un champ via pointeur. | Méthode concrète: 1) accède à la valeur pointée | Erreur fréquente: Un déréférencement invalide suffit à planter. | Auto-vérification: Teste la validité avant accès mémoire.",
    "explanation": "Exemple: `cur->next` est sûr si `cur` est non NULL. Contexte: Que fait `*p`? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-063",
    "category": "Pointeurs",
    "question": "Que fait `&x`?",
    "answer": "A mémoriser: `*` déréférence, `&` prend une adresse, `->` accède à un champ via pointeur. | Méthode concrète: 1) donne l’adresse de x | Erreur fréquente: Un déréférencement invalide suffit à planter. | Auto-vérification: Teste la validité avant accès mémoire.",
    "explanation": "Exemple: `cur->next` est sûr si `cur` est non NULL. Contexte: Que fait `&x`? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-064",
    "category": "Pointeurs",
    "question": "Pourquoi utiliser `t_list **`?",
    "answer": "A mémoriser: Le double pointeur est requis quand la tête de liste peut changer. | Méthode concrète: 1) modifier la tête -> 2) changer un pointeur | Erreur fréquente: Avec un simple pointeur, la modification reste locale. | Auto-vérification: Si la structure doit bouger en entrée, passe `**`.",
    "explanation": "Exemple: suppression de têtes successives dans remove_if. Contexte: Pourquoi utiliser `t_list **`? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-065",
    "category": "Pointeurs",
    "question": "Quelle ligne fait avancer dans une liste?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) cur = cur->next | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Quelle ligne fait avancer dans une liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-066",
    "category": "Pointeurs",
    "question": "Quel opérateur pour accéder à un champ via pointeur?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) -> | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Quel opérateur pour accéder à un champ via pointeur? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-067",
    "category": "Pointeurs",
    "question": "Danger d’un pointeur non initialisé?",
    "answer": "A mémoriser: Un pointeur libéré ou non initialisé ne doit jamais être déréférencé. | Méthode concrète: 1) comportement indéfini -> 2) segfault | Erreur fréquente: Comportement indéfini, parfois silencieux puis crash. | Auto-vérification: Après free, neutralise ou abandonne le pointeur.",
    "explanation": "Exemple: sur liste, `cur = cur->next` et jamais `cur++`. Contexte: Danger d’un pointeur non initialisé? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-068",
    "category": "Pointeurs",
    "question": "Peut-on utiliser un pointeur après free?",
    "answer": "A mémoriser: Un pointeur libéré ou non initialisé ne doit jamais être déréférencé. | Méthode concrète: 1) non -> 2) dangling pointer | Erreur fréquente: Comportement indéfini, parfois silencieux puis crash. | Auto-vérification: Après free, neutralise ou abandonne le pointeur.",
    "explanation": "Exemple: sur liste, `cur = cur->next` et jamais `cur++`. Contexte: Peut-on utiliser un pointeur après free? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-069",
    "category": "Pointeurs",
    "question": "Pourquoi argv est un char **?",
    "answer": "A mémoriser: Le double pointeur est requis quand la tête de liste peut changer. | Méthode concrète: 1) tableau de strings | Erreur fréquente: Avec un simple pointeur, la modification reste locale. | Auto-vérification: Si la structure doit bouger en entrée, passe `**`.",
    "explanation": "Exemple: suppression de têtes successives dans remove_if. Contexte: Pourquoi argv est un char **? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-070",
    "category": "Pointeurs",
    "question": "Pourquoi utiliser un pointeur tmp en liste?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) garder adresse -> 2) free ensuite | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Pourquoi utiliser un pointeur tmp en liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-071",
    "category": "Pointeurs",
    "question": "Quelle ligne modifie la tête?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) *begin = (*begin)->next | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Quelle ligne modifie la tête? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-072",
    "category": "Pointeurs",
    "question": "Que se passe-t-il si on deref NULL?",
    "answer": "A mémoriser: `*` déréférence, `&` prend une adresse, `->` accède à un champ via pointeur. | Méthode concrète: 1) segfault | Erreur fréquente: Un déréférencement invalide suffit à planter. | Auto-vérification: Teste la validité avant accès mémoire.",
    "explanation": "Exemple: `cur->next` est sûr si `cur` est non NULL. Contexte: Que se passe-t-il si on deref NULL? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-073",
    "category": "Pointeurs",
    "question": "Pourquoi swap data plutôt que liens?",
    "answer": "A mémoriser: Comprendre les types (`char **`, `void *`, tableau vs pointeur) évite les erreurs structurelles. | Méthode concrète: 1) plus simple -> 2) moins risqué | Erreur fréquente: Mauvais type = mauvais accès et logique cassée. | Auto-vérification: Relis les signatures avant d'implémenter.",
    "explanation": "Exemple: `argv` est un tableau de chaînes, donc `char **`. Contexte: Pourquoi swap data plutôt que liens? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-074",
    "category": "Pointeurs",
    "question": "Pourquoi `*cur->next` est piégeux?",
    "answer": "A mémoriser: `*` déréférence, `&` prend une adresse, `->` accède à un champ via pointeur. | Méthode concrète: 1) -> avant * -> 2) parenthèses nécessaires | Erreur fréquente: Un déréférencement invalide suffit à planter. | Auto-vérification: Teste la validité avant accès mémoire.",
    "explanation": "Exemple: `cur->next` est sûr si `cur` est non NULL. Contexte: Pourquoi `*cur->next` est piégeux? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-075",
    "category": "Pointeurs",
    "question": "Que représente void *?",
    "answer": "A mémoriser: Comprendre les types (`char **`, `void *`, tableau vs pointeur) évite les erreurs structurelles. | Méthode concrète: 1) pointeur générique | Erreur fréquente: Mauvais type = mauvais accès et logique cassée. | Auto-vérification: Relis les signatures avant d'implémenter.",
    "explanation": "Exemple: `argv` est un tableau de chaînes, donc `char **`. Contexte: Que représente void *? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-076",
    "category": "Pointeurs",
    "question": "Quand vérifier un pointeur?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) avant deref | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Quand vérifier un pointeur? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-077",
    "category": "Pointeurs",
    "question": "Différence char s[10] / char *s?",
    "answer": "A mémoriser: La clé des pointeurs est le niveau d'indirection: adresse, valeur pointée, adresse de tête. | Méthode concrète: 1) tableau vs adresse -> 2) stockage différent | Erreur fréquente: Une confusion à ce niveau écrit rapidement au mauvais endroit. | Auto-vérification: Avant `*` ou `->`, valide que le pointeur est bien initialisé.",
    "explanation": "Exemple: distingue clairement `p`, `*p`, `&p`. Contexte: Différence char s[10] / char *s? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-078",
    "category": "Pointeurs",
    "question": "Pourquoi ne pas retourner &local?",
    "answer": "A mémoriser: Un pointeur libéré ou non initialisé ne doit jamais être déréférencé. | Méthode concrète: 1) pointeur mort -> 2) stack détruite | Erreur fréquente: Comportement indéfini, parfois silencieux puis crash. | Auto-vérification: Après free, neutralise ou abandonne le pointeur.",
    "explanation": "Exemple: sur liste, `cur = cur->next` et jamais `cur++`. Contexte: Pourquoi ne pas retourner &local? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-079",
    "category": "Pointeurs",
    "question": "Pourquoi ne pas faire cur++ sur une liste?",
    "answer": "A mémoriser: Un pointeur libéré ou non initialisé ne doit jamais être déréférencé. | Méthode concrète: 1) pas contigu -> 2) mémoire arbitraire | Erreur fréquente: Comportement indéfini, parfois silencieux puis crash. | Auto-vérification: Après free, neutralise ou abandonne le pointeur.",
    "explanation": "Exemple: sur liste, `cur = cur->next` et jamais `cur++`. Contexte: Pourquoi ne pas faire cur++ sur une liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-080",
    "category": "Pointeurs",
    "question": "Risque principal avec **?",
    "answer": "A mémoriser: Le double pointeur est requis quand la tête de liste peut changer. | Méthode concrète: 1) modifier mauvaise adresse -> 2) perdre tête | Erreur fréquente: Avec un simple pointeur, la modification reste locale. | Auto-vérification: Si la structure doit bouger en entrée, passe `**`.",
    "explanation": "Exemple: suppression de têtes successives dans remove_if. Contexte: Risque principal avec **? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-081",
    "category": "Malloc",
    "question": "À quoi sert malloc?",
    "answer": "A mémoriser: `malloc` réserve dynamiquement une zone heap et renvoie son adresse. | Méthode concrète: 1) allouer dynamiquement en heap -> 2) renvoie un pointeur | Erreur fréquente: Sans contrôle d'échec, NULL peut être utilisé par erreur. | Auto-vérification: Premier réflexe: `if (!ptr)`.",
    "explanation": "Exemple: malloc alloue mais n'initialise pas la mémoire. Contexte: À quoi sert malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-082",
    "category": "Malloc",
    "question": "Que retourne malloc en cas d’échec?",
    "answer": "A mémoriser: En échec, malloc renvoie NULL: c'est un cas normal à gérer. | Méthode concrète: 1) NULL | Erreur fréquente: Supposer le succès crée un crash immédiat. | Auto-vérification: Prévois un retour propre ou un cleanup.",
    "explanation": "Exemple: `if (!ptr) return NULL;`. Contexte: Que retourne malloc en cas d’échec? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-083",
    "category": "Malloc",
    "question": "Quelle taille malloc pour copier une string?",
    "answer": "A mémoriser: Pour les strings, compte toujours le `\\0` (et le signe si nécessaire). | Méthode concrète: 1) longueur + 1 -> 2) '\\0' | Erreur fréquente: Un octet manquant suffit à dépasser le buffer. | Auto-vérification: Vérifie la formule complète d'allocation.",
    "explanation": "Exemple: `-42` = 4 cases avec le `\\0`. Contexte: Quelle taille malloc pour copier une string? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-084",
    "category": "Malloc",
    "question": "Pourquoi sizeof(type) * n?",
    "answer": "A mémoriser: Pour un tableau, écris `sizeof(type) * n`, jamais `sizeof(ptr) * n`. | Méthode concrète: 1) nombre d’octets correct | Erreur fréquente: La taille du pointeur n'est pas celle des éléments. | Auto-vérification: Relis chaque multiplicateur d'octets.",
    "explanation": "Exemple: `sizeof(int) * n` pour n entiers. Contexte: Pourquoi sizeof(type) * n? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-085",
    "category": "Malloc",
    "question": "Quel test immédiat après malloc?",
    "answer": "A mémoriser: `malloc` est fiable si taille exacte + test NULL + stratégie de libération. | Méthode concrète: 1) if (!ptr) return NULL | Erreur fréquente: Sinon tu accumules fuite, crash ou corruption. | Auto-vérification: Calcule d'abord, alloue ensuite, vérifie tout de suite.",
    "explanation": "Exemple: chaque allocation a son propriétaire clair. Contexte: Quel test immédiat après malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-086",
    "category": "Malloc",
    "question": "Qui doit free la mémoire retournée?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) l’appelant | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Qui doit free la mémoire retournée? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-087",
    "category": "Malloc",
    "question": "Que fait free(NULL)?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) rien -> 2) sûr | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Que fait free(NULL)? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-088",
    "category": "Malloc",
    "question": "Pourquoi éviter malloc(1000) arbitraire?",
    "answer": "A mémoriser: `malloc` est fiable si taille exacte + test NULL + stratégie de libération. | Méthode concrète: 1) fragile -> 2) imprécis | Erreur fréquente: Sinon tu accumules fuite, crash ou corruption. | Auto-vérification: Calcule d'abord, alloue ensuite, vérifie tout de suite.",
    "explanation": "Exemple: chaque allocation a son propriétaire clair. Contexte: Pourquoi éviter malloc(1000) arbitraire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-089",
    "category": "Malloc",
    "question": "Pourquoi sizeof(ptr) est faux pour tableau?",
    "answer": "A mémoriser: Pour un tableau, écris `sizeof(type) * n`, jamais `sizeof(ptr) * n`. | Méthode concrète: 1) taille pointeur -> 2) pas élément | Erreur fréquente: La taille du pointeur n'est pas celle des éléments. | Auto-vérification: Relis chaque multiplicateur d'octets.",
    "explanation": "Exemple: `sizeof(int) * n` pour n entiers. Contexte: Pourquoi sizeof(ptr) est faux pour tableau? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-090",
    "category": "Malloc",
    "question": "Comment allouer un tableau de mots?",
    "answer": "A mémoriser: Pour un tableau, écris `sizeof(type) * n`, jamais `sizeof(ptr) * n`. | Méthode concrète: 1) malloc(nb + 1) -> 2) NULL final | Erreur fréquente: La taille du pointeur n'est pas celle des éléments. | Auto-vérification: Relis chaque multiplicateur d'octets.",
    "explanation": "Exemple: `sizeof(int) * n` pour n entiers. Contexte: Comment allouer un tableau de mots? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-091",
    "category": "Malloc",
    "question": "Quand free un maillon supprimé?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) après reconnecter | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Quand free un maillon supprimé? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-092",
    "category": "Malloc",
    "question": "malloc échoue dans split à mi-chemin?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) free ce qui est déjà alloué | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: malloc échoue dans split à mi-chemin? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-093",
    "category": "Malloc",
    "question": "Que fait calloc?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) malloc + mise à zéro | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Que fait calloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-094",
    "category": "Malloc",
    "question": "À quoi sert realloc?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) agrandir / réduire -> 2) conserve contenu | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: À quoi sert realloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-095",
    "category": "Malloc",
    "question": "Qu’est-ce qu’une fuite mémoire?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) mémoire jamais free | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Qu’est-ce qu’une fuite mémoire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-096",
    "category": "Malloc",
    "question": "Pourquoi mettre ptr = NULL après free?",
    "answer": "A mémoriser: Ownership et cleanup sont obligatoires: libérer au bon endroit et en cas d'erreur intermédiaire. | Méthode concrète: 1) éviter réutilisation | Erreur fréquente: Sans cleanup, fuite mémoire et état incohérent. | Auto-vérification: Planifie le chemin d'erreur dès le début.",
    "explanation": "Exemple: en split, échec au milieu => libérer tout ce qui précède. Contexte: Pourquoi mettre ptr = NULL après free? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-097",
    "category": "Malloc",
    "question": "Pourquoi +1 dans ft_range?",
    "answer": "A mémoriser: `malloc` est fiable si taille exacte + test NULL + stratégie de libération. | Méthode concrète: 1) inclure start et end | Erreur fréquente: Sinon tu accumules fuite, crash ou corruption. | Auto-vérification: Calcule d'abord, alloue ensuite, vérifie tout de suite.",
    "explanation": "Exemple: chaque allocation a son propriétaire clair. Contexte: Pourquoi +1 dans ft_range? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-098",
    "category": "Malloc",
    "question": "Pourquoi malloc len + sign + 1?",
    "answer": "A mémoriser: `malloc` est fiable si taille exacte + test NULL + stratégie de libération. | Méthode concrète: 1) '-' -> 2) '\\0' | Erreur fréquente: Sinon tu accumules fuite, crash ou corruption. | Auto-vérification: Calcule d'abord, alloue ensuite, vérifie tout de suite.",
    "explanation": "Exemple: chaque allocation a son propriétaire clair. Contexte: Pourquoi malloc len + sign + 1? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-099",
    "category": "Malloc",
    "question": "Pourquoi vérifier argc avant malloc?",
    "answer": "A mémoriser: `malloc` est fiable si taille exacte + test NULL + stratégie de libération. | Méthode concrète: 1) éviter allocation inutile | Erreur fréquente: Sinon tu accumules fuite, crash ou corruption. | Auto-vérification: Calcule d'abord, alloue ensuite, vérifie tout de suite.",
    "explanation": "Exemple: chaque allocation a son propriétaire clair. Contexte: Pourquoi vérifier argc avant malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-100",
    "category": "Malloc",
    "question": "Réflexe numéro un avec malloc?",
    "answer": "A mémoriser: `malloc` réserve dynamiquement une zone heap et renvoie son adresse. | Méthode concrète: 1) vérifier NULL | Erreur fréquente: Sans contrôle d'échec, NULL peut être utilisé par erreur. | Auto-vérification: Premier réflexe: `if (!ptr)`.",
    "explanation": "Exemple: malloc alloue mais n'initialise pas la mémoire. Contexte: Réflexe numéro un avec malloc? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-101",
    "category": "Listes chaînées",
    "question": "À quoi sert le champ next?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) pointer vers le maillon suivant | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: À quoi sert le champ next? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-102",
    "category": "Listes chaînées",
    "question": "Que représente begin_list?",
    "answer": "A mémoriser: Le double pointeur est indispensable pour modifier la tête. | Méthode concrète: 1) pointeur vers la tête | Erreur fréquente: Sinon la nouvelle tête n'est pas propagée. | Auto-vérification: Nettoie les têtes avant le parcours standard.",
    "explanation": "Exemple: remove_if doit gérer des suppressions en tête successives. Contexte: Que représente begin_list? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-103",
    "category": "Listes chaînées",
    "question": "Pourquoi passer t_list **?",
    "answer": "A mémoriser: Le double pointeur est indispensable pour modifier la tête. | Méthode concrète: 1) modifier la tête -> 2) relier après suppression | Erreur fréquente: Sinon la nouvelle tête n'est pas propagée. | Auto-vérification: Nettoie les têtes avant le parcours standard.",
    "explanation": "Exemple: remove_if doit gérer des suppressions en tête successives. Contexte: Pourquoi passer t_list **? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-104",
    "category": "Listes chaînées",
    "question": "Comment parcourir une liste?",
    "answer": "A mémoriser: Parcours robuste: initialiser cur, tester la bonne condition, puis avancer proprement. | Méthode concrète: 1) cur = begin -> 2) while(cur) -> 3) cur = cur->next | Erreur fréquente: Une mauvaise condition saute des éléments ou déréférence NULL. | Auto-vérification: Choisis `while(cur)` vs `while(cur->next)` selon l'opération.",
    "explanation": "Exemple: suppression du suivant nécessite `cur->next` valide. Contexte: Comment parcourir une liste? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-105",
    "category": "Listes chaînées",
    "question": "Comment retirer cur->next?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) tmp = cur->next -> 2) cur->next = tmp->next -> 3) free(tmp) | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: Comment retirer cur->next? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-106",
    "category": "Listes chaînées",
    "question": "Comment supprimer plusieurs têtes?",
    "answer": "A mémoriser: Le double pointeur est indispensable pour modifier la tête. | Méthode concrète: 1) while(*begin && cmp(...)) -> 2) tmp = *begin -> 3) *begin = tmp->next -> 4) free(tmp) | Erreur fréquente: Sinon la nouvelle tête n'est pas propagée. | Auto-vérification: Nettoie les têtes avant le parcours standard.",
    "explanation": "Exemple: remove_if doit gérer des suppressions en tête successives. Contexte: Comment supprimer plusieurs têtes? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-107",
    "category": "Listes chaînées",
    "question": "Quand avancer cur?",
    "answer": "A mémoriser: Parcours robuste: initialiser cur, tester la bonne condition, puis avancer proprement. | Méthode concrète: 1) seulement si pas supprimé | Erreur fréquente: Une mauvaise condition saute des éléments ou déréférence NULL. | Auto-vérification: Choisis `while(cur)` vs `while(cur->next)` selon l'opération.",
    "explanation": "Exemple: suppression du suivant nécessite `cur->next` valide. Contexte: Quand avancer cur? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-108",
    "category": "Listes chaînées",
    "question": "Comment détecter la fin?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) cur == NULL | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: Comment détecter la fin? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-109",
    "category": "Listes chaînées",
    "question": "Que vaut une liste vide?",
    "answer": "A mémoriser: En liste chaînée, l'ordre des pointeurs est la priorité: stocker, relier, libérer, avancer. | Méthode concrète: 1) pointeur NULL | Erreur fréquente: Un ordre mauvais perd un maillon ou casse la chaîne. | Auto-vérification: Conserve un pointeur tmp avant toute suppression.",
    "explanation": "Exemple: traite tête et corps de liste séparément. Contexte: Que vaut une liste vide? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-110",
    "category": "Listes chaînées",
    "question": "Pourquoi tmp est indispensable?",
    "answer": "A mémoriser: Suppression sûre: sauvegarder cible, reconnecter les liens, puis libérer. | Méthode concrète: 1) garder adresse -> 2) free après | Erreur fréquente: Free avant unlink corrompt la structure. | Auto-vérification: Écris la séquence dans cet ordre, sans variation.",
    "explanation": "Exemple: `tmp = cur->next; cur->next = tmp->next; free(tmp);`. Contexte: Pourquoi tmp est indispensable? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-111",
    "category": "Listes chaînées",
    "question": "Quel tri simple utiliser à l’exam?",
    "answer": "A mémoriser: En liste chaînée, l'ordre des pointeurs est la priorité: stocker, relier, libérer, avancer. | Méthode concrète: 1) bubble sort -> 2) swap data | Erreur fréquente: Un ordre mauvais perd un maillon ou casse la chaîne. | Auto-vérification: Conserve un pointeur tmp avant toute suppression.",
    "explanation": "Exemple: traite tête et corps de liste séparément. Contexte: Quel tri simple utiliser à l’exam? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-112",
    "category": "Listes chaînées",
    "question": "À quoi sert swapped?",
    "answer": "A mémoriser: Bubble sort est acceptable si le contrôle `swapped` est correct. | Méthode concrète: 1) savoir si encore des échanges | Erreur fréquente: Mauvais test cmp ou flag swapped laisse la liste mal triée. | Auto-vérification: Continue tant qu'un échange a eu lieu.",
    "explanation": "Exemple: swap data est souvent plus simple que swap liens. Contexte: À quoi sert swapped? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-113",
    "category": "Listes chaînées",
    "question": "Que fait cmp dans sort_list?",
    "answer": "A mémoriser: Bubble sort est acceptable si le contrôle `swapped` est correct. | Méthode concrète: 1) indique ordre correct | Erreur fréquente: Mauvais test cmp ou flag swapped laisse la liste mal triée. | Auto-vérification: Continue tant qu'un échange a eu lieu.",
    "explanation": "Exemple: swap data est souvent plus simple que swap liens. Contexte: Que fait cmp dans sort_list? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-114",
    "category": "Listes chaînées",
    "question": "Comment compter les maillons?",
    "answer": "A mémoriser: Parcours robuste: initialiser cur, tester la bonne condition, puis avancer proprement. | Méthode concrète: 1) while(lst) count++ | Erreur fréquente: Une mauvaise condition saute des éléments ou déréférence NULL. | Auto-vérification: Choisis `while(cur)` vs `while(cur->next)` selon l'opération.",
    "explanation": "Exemple: suppression du suivant nécessite `cur->next` valide. Contexte: Comment compter les maillons? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-115",
    "category": "Listes chaînées",
    "question": "Que vaut next du dernier?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) NULL | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: Que vaut next du dernier? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-116",
    "category": "Listes chaînées",
    "question": "Pourquoi unlink avant free?",
    "answer": "A mémoriser: Suppression sûre: sauvegarder cible, reconnecter les liens, puis libérer. | Méthode concrète: 1) éviter corruption | Erreur fréquente: Free avant unlink corrompt la structure. | Auto-vérification: Écris la séquence dans cet ordre, sans variation.",
    "explanation": "Exemple: `tmp = cur->next; cur->next = tmp->next; free(tmp);`. Contexte: Pourquoi unlink avant free? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-117",
    "category": "Listes chaînées",
    "question": "Quel test avant cur->next?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) if(cur->next) | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: Quel test avant cur->next? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-118",
    "category": "Listes chaînées",
    "question": "Comment supprimer le dernier?",
    "answer": "A mémoriser: `next` relie les maillons; le dernier doit pointer vers NULL. | Méthode concrète: 1) parcourir jusqu’à avant dernier -> 2) unlink -> 3) free | Erreur fréquente: Mauvaise terminaison = parcours infini ou invalide. | Auto-vérification: Valide le dernier lien explicitement.",
    "explanation": "Exemple: `while(cur)` s'arrête sur NULL. Contexte: Comment supprimer le dernier? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-119",
    "category": "Listes chaînées",
    "question": "Pourquoi éviter récursion à l’exam?",
    "answer": "A mémoriser: En liste chaînée, l'ordre des pointeurs est la priorité: stocker, relier, libérer, avancer. | Méthode concrète: 1) stack -> 2) complexité | Erreur fréquente: Un ordre mauvais perd un maillon ou casse la chaîne. | Auto-vérification: Conserve un pointeur tmp avant toute suppression.",
    "explanation": "Exemple: traite tête et corps de liste séparément. Contexte: Pourquoi éviter récursion à l’exam? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-120",
    "category": "Listes chaînées",
    "question": "Piège majeur avec les listes?",
    "answer": "A mémoriser: En liste chaînée, l'ordre des pointeurs est la priorité: stocker, relier, libérer, avancer. | Méthode concrète: 1) avancer au mauvais moment -> 2) perdre un lien | Erreur fréquente: Un ordre mauvais perd un maillon ou casse la chaîne. | Auto-vérification: Conserve un pointeur tmp avant toute suppression.",
    "explanation": "Exemple: traite tête et corps de liste séparément. Contexte: Piège majeur avec les listes? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-121",
    "category": "Conditions limites",
    "question": "Quel est le cas limite majeur de itoa?",
    "answer": "A mémoriser: Pour itoa, les deux tests obligatoires sont 0 et INT_MIN. | Méthode concrète: 1) INT_MIN -> 2) overflow si non géré -> 3) caster en long | Erreur fréquente: Ce sont les premiers cas qui cassent un code incomplet. | Auto-vérification: Vérifie la chaîne produite caractère par caractère.",
    "explanation": "Exemple: `itoa(0)` doit donner `\"0\"`. Contexte: Quel est le cas limite majeur de itoa? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-122",
    "category": "Conditions limites",
    "question": "split(\"\") doit retourner quoi?",
    "answer": "A mémoriser: Avec split, entrée vide ou séparateurs seuls doit renvoyer un tableau valide terminé par NULL. | Méthode concrète: 1) tableau contenant seulement NULL | Erreur fréquente: Sans ça, tu produis des mots fantômes ou un parcours hors borne. | Auto-vérification: Teste `\"\"`, `\"   \"` et dernier mot sans séparateur final.",
    "explanation": "Exemple: split vide => tableau dont la première case est NULL. Contexte: split(\"\") doit retourner quoi? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-123",
    "category": "Conditions limites",
    "question": "ft_range(5,5)?",
    "answer": "A mémoriser: ft_range doit gérer montée, descente et égalité avec taille inclusive. | Méthode concrète: 1) tableau {5} | Erreur fréquente: Oublier start>end donne un résultat partiel ou faux. | Auto-vérification: Valide les trois directions avant rendu.",
    "explanation": "Exemple: `ft_range(5,5)` retourne un seul élément. Contexte: ft_range(5,5)? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-124",
    "category": "Conditions limites",
    "question": "Que vaut begin_list si la liste est vide?",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) NULL | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: Que vaut begin_list si la liste est vide? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-125",
    "category": "Conditions limites",
    "question": "remove_if supprime tous les éléments. Résultat?",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) *begin devient NULL | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: remove_if supprime tous les éléments. Résultat? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-126",
    "category": "Conditions limites",
    "question": "atoi(\"0\")?",
    "answer": "A mémoriser: Les chemins d'erreur doivent rester déterministes et conformes au sujet. | Méthode concrète: 1) 0 | Erreur fréquente: Texte en trop ou erreur mémoire non gérée => tests KO. | Auto-vérification: Respecte sortie minimale et cleanup explicite.",
    "explanation": "Exemple: argc invalide demande souvent uniquement `\\n`. Contexte: atoi(\"0\")? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-127",
    "category": "Conditions limites",
    "question": "split(\" \") doit produire?",
    "answer": "A mémoriser: Avec split, entrée vide ou séparateurs seuls doit renvoyer un tableau valide terminé par NULL. | Méthode concrète: 1) tableau NULL | Erreur fréquente: Sans ça, tu produis des mots fantômes ou un parcours hors borne. | Auto-vérification: Teste `\"\"`, `\"   \"` et dernier mot sans séparateur final.",
    "explanation": "Exemple: split vide => tableau dont la première case est NULL. Contexte: split(\" \") doit produire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-128",
    "category": "Conditions limites",
    "question": "sort_list avec un seul maillon?",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) inchangé | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: sort_list avec un seul maillon? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-129",
    "category": "Conditions limites",
    "question": "wdmatch ne trouve pas tous les caractères.",
    "answer": "A mémoriser: Les chemins d'erreur doivent rester déterministes et conformes au sujet. | Méthode concrète: 1) afficher '\\n' | Erreur fréquente: Texte en trop ou erreur mémoire non gérée => tests KO. | Auto-vérification: Respecte sortie minimale et cleanup explicite.",
    "explanation": "Exemple: argc invalide demande souvent uniquement `\\n`. Contexte: wdmatch ne trouve pas tous les caractères. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-130",
    "category": "Conditions limites",
    "question": "ft_range(3,0)?",
    "answer": "A mémoriser: ft_range doit gérer montée, descente et égalité avec taille inclusive. | Méthode concrète: 1) {3,2,1,0} | Erreur fréquente: Oublier start>end donne un résultat partiel ou faux. | Auto-vérification: Valide les trois directions avant rendu.",
    "explanation": "Exemple: `ft_range(5,5)` retourne un seul élément. Contexte: ft_range(3,0)? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-131",
    "category": "Conditions limites",
    "question": "itoa(0) retourne?",
    "answer": "A mémoriser: Pour itoa, les deux tests obligatoires sont 0 et INT_MIN. | Méthode concrète: 1) \"0\" | Erreur fréquente: Ce sont les premiers cas qui cassent un code incomplet. | Auto-vérification: Vérifie la chaîne produite caractère par caractère.",
    "explanation": "Exemple: `itoa(0)` doit donner `\"0\"`. Contexte: itoa(0) retourne? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-132",
    "category": "Conditions limites",
    "question": "ft_list_foreach sur liste vide?",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) rien | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: ft_list_foreach sur liste vide? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-133",
    "category": "Conditions limites",
    "question": "remove_if ne trouve rien.",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) liste inchangée | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: remove_if ne trouve rien. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-134",
    "category": "Conditions limites",
    "question": "Comment doit se terminer un tableau de strings?",
    "answer": "A mémoriser: Avec split, entrée vide ou séparateurs seuls doit renvoyer un tableau valide terminé par NULL. | Méthode concrète: 1) NULL | Erreur fréquente: Sans ça, tu produis des mots fantômes ou un parcours hors borne. | Auto-vérification: Teste `\"\"`, `\"   \"` et dernier mot sans séparateur final.",
    "explanation": "Exemple: split vide => tableau dont la première case est NULL. Contexte: Comment doit se terminer un tableau de strings? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-135",
    "category": "Conditions limites",
    "question": "atoi(\" 42\")?",
    "answer": "A mémoriser: Les chemins d'erreur doivent rester déterministes et conformes au sujet. | Méthode concrète: 1) 42 | Erreur fréquente: Texte en trop ou erreur mémoire non gérée => tests KO. | Auto-vérification: Respecte sortie minimale et cleanup explicite.",
    "explanation": "Exemple: argc invalide demande souvent uniquement `\\n`. Contexte: atoi(\" 42\")? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-136",
    "category": "Conditions limites",
    "question": "union(\"\", \"\")?",
    "answer": "A mémoriser: Les chemins d'erreur doivent rester déterministes et conformes au sujet. | Méthode concrète: 1) rien afficher | Erreur fréquente: Texte en trop ou erreur mémoire non gérée => tests KO. | Auto-vérification: Respecte sortie minimale et cleanup explicite.",
    "explanation": "Exemple: argc invalide demande souvent uniquement `\\n`. Contexte: union(\"\", \"\")? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-137",
    "category": "Conditions limites",
    "question": "Dernier mot sans séparateur?",
    "answer": "A mémoriser: Avec split, entrée vide ou séparateurs seuls doit renvoyer un tableau valide terminé par NULL. | Méthode concrète: 1) inclure quand même | Erreur fréquente: Sans ça, tu produis des mots fantômes ou un parcours hors borne. | Auto-vérification: Teste `\"\"`, `\"   \"` et dernier mot sans séparateur final.",
    "explanation": "Exemple: split vide => tableau dont la première case est NULL. Contexte: Dernier mot sans séparateur? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-138",
    "category": "Conditions limites",
    "question": "remove_if supprime dernier maillon?",
    "answer": "A mémoriser: Sur liste, vide et un seul maillon doivent rester des cas neutres et sûrs. | Méthode concrète: 1) unlink -> 2) free | Erreur fréquente: Sans garde initiale, tu déréférences NULL. | Auto-vérification: Place les gardes en tout début de fonction.",
    "explanation": "Exemple: remove_if peut terminer avec `*begin_list = NULL`. Contexte: remove_if supprime dernier maillon? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-139",
    "category": "Conditions limites",
    "question": "argc incorrect.",
    "answer": "A mémoriser: Les chemins d'erreur doivent rester déterministes et conformes au sujet. | Méthode concrète: 1) afficher '\\n' | Erreur fréquente: Texte en trop ou erreur mémoire non gérée => tests KO. | Auto-vérification: Respecte sortie minimale et cleanup explicite.",
    "explanation": "Exemple: argc invalide demande souvent uniquement `\\n`. Contexte: argc incorrect. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-140",
    "category": "Conditions limites",
    "question": "malloc échoue dans split?",
    "answer": "A mémoriser: Avec split, entrée vide ou séparateurs seuls doit renvoyer un tableau valide terminé par NULL. | Méthode concrète: 1) free déjà alloué -> 2) return NULL | Erreur fréquente: Sans ça, tu produis des mots fantômes ou un parcours hors borne. | Auto-vérification: Teste `\"\"`, `\"   \"` et dernier mot sans séparateur final.",
    "explanation": "Exemple: split vide => tableau dont la première case est NULL. Contexte: malloc échoue dans split? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-141",
    "category": "Règles implicites",
    "question": "argc n’est pas celui attendu. Que faire?",
    "answer": "A mémoriser: Si argc est invalide, applique strictement la sortie demandée par l'énoncé. | Méthode concrète: 1) afficher uniquement `\\n` -> 2) rien d’autre | Erreur fréquente: Un message ajouté hors contrat fait échouer les tests. | Auto-vérification: Souvent, il faut uniquement afficher `\\n`.",
    "explanation": "Exemple: ne personnalise pas le message d'erreur. Contexte: argc n’est pas celui attendu. Que faire? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-142",
    "category": "Règles implicites",
    "question": "Une fonction n’est pas listée dans “Allowed functions”.",
    "answer": "A mémoriser: La liste des fonctions autorisées est fermée: ce qui n'est pas listé est interdit. | Méthode concrète: 1) interdite -> 2) ne pas l’utiliser | Erreur fréquente: Fonction interdite = rendu invalide. | Auto-vérification: Passe tous tes appels en revue avant de rendre.",
    "explanation": "Exemple: write-only signifie réellement write-only. Contexte: Une fonction n’est pas listée dans “Allowed functions”. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-143",
    "category": "Règles implicites",
    "question": "write est la seule fonction autorisée.",
    "answer": "A mémoriser: La liste des fonctions autorisées est fermée: ce qui n'est pas listé est interdit. | Méthode concrète: 1) pas printf -> 2) pas puts -> 3) pas perror | Erreur fréquente: Fonction interdite = rendu invalide. | Auto-vérification: Passe tous tes appels en revue avant de rendre.",
    "explanation": "Exemple: write-only signifie réellement write-only. Contexte: write est la seule fonction autorisée. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-144",
    "category": "Règles implicites",
    "question": "Pourquoi l’output doit être strict?",
    "answer": "A mémoriser: La sortie doit être exactement celle du sujet: contenu, ordre, flux, newline. | Méthode concrète: 1) tests automatiques -> 2) comparaison exacte | Erreur fréquente: Un seul caractère en trop suffit à rater. | Auto-vérification: Vérifie la sortie caractère par caractère.",
    "explanation": "Exemple: `cat -e` aide à détecter les fins de ligne manquantes. Contexte: Pourquoi l’output doit être strict? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-145",
    "category": "Règles implicites",
    "question": "L’énoncé montre un `\\n` final.",
    "answer": "A mémoriser: La sortie doit être exactement celle du sujet: contenu, ordre, flux, newline. | Méthode concrète: 1) obligatoire -> 2) sinon tests KO | Erreur fréquente: Un seul caractère en trop suffit à rater. | Auto-vérification: Vérifie la sortie caractère par caractère.",
    "explanation": "Exemple: `cat -e` aide à détecter les fins de ligne manquantes. Contexte: L’énoncé montre un `\\n` final. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-146",
    "category": "Règles implicites",
    "question": "“Expected files : wdmatch.c”.",
    "answer": "A mémoriser: Noms de fichiers, prototypes et structures imposées doivent rester identiques. | Méthode concrète: 1) un seul fichier -> 2) nom exact | Erreur fréquente: La compilation ou le linkage peut échouer même avec bonne logique. | Auto-vérification: Compare symboles et signatures avec l'énoncé.",
    "explanation": "Exemple: `Expected files: wdmatch.c` impose ce nom exact. Contexte: “Expected files : wdmatch.c”. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-147",
    "category": "Règles implicites",
    "question": "Le prototype doit correspondre exactement?",
    "answer": "A mémoriser: Noms de fichiers, prototypes et structures imposées doivent rester identiques. | Méthode concrète: 1) oui -> 2) sinon compilation refusée | Erreur fréquente: La compilation ou le linkage peut échouer même avec bonne logique. | Auto-vérification: Compare symboles et signatures avec l'énoncé.",
    "explanation": "Exemple: `Expected files: wdmatch.c` impose ce nom exact. Contexte: Le prototype doit correspondre exactement? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-148",
    "category": "Règles implicites",
    "question": "“include list.h but do not turn it in”.",
    "answer": "A mémoriser: Noms de fichiers, prototypes et structures imposées doivent rester identiques. | Méthode concrète: 1) utiliser le header -> 2) ne pas rendre le fichier | Erreur fréquente: La compilation ou le linkage peut échouer même avec bonne logique. | Auto-vérification: Compare symboles et signatures avec l'énoncé.",
    "explanation": "Exemple: `Expected files: wdmatch.c` impose ce nom exact. Contexte: “include list.h but do not turn it in”. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-149",
    "category": "Règles implicites",
    "question": "Une struct est fournie dans l’énoncé.",
    "answer": "A mémoriser: Noms de fichiers, prototypes et structures imposées doivent rester identiques. | Méthode concrète: 1) ne pas modifier -> 2) utiliser telle quelle | Erreur fréquente: La compilation ou le linkage peut échouer même avec bonne logique. | Auto-vérification: Compare symboles et signatures avec l'énoncé.",
    "explanation": "Exemple: `Expected files: wdmatch.c` impose ce nom exact. Contexte: Une struct est fournie dans l’énoncé. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-150",
    "category": "Règles implicites",
    "question": "Peut-on laisser des printf de debug?",
    "answer": "A mémoriser: La liste des fonctions autorisées est fermée: ce qui n'est pas listé est interdit. | Méthode concrète: 1) non -> 2) sortie strictement contrôlée | Erreur fréquente: Fonction interdite = rendu invalide. | Auto-vérification: Passe tous tes appels en revue avant de rendre.",
    "explanation": "Exemple: write-only signifie réellement write-only. Contexte: Peut-on laisser des printf de debug? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-151",
    "category": "Règles implicites",
    "question": "L’énoncé ne demande pas d’erreur explicite.",
    "answer": "A mémoriser: En exam 42, conformité du contrat = aussi important que l'algorithme. | Méthode concrète: 1) rester silencieux -> 2) ou seulement `\\n` | Erreur fréquente: Une solution logique peut être refusée pour non-conformité de forme. | Auto-vérification: Fais une revue finale: output, fonctions autorisées, signatures, fichiers.",
    "explanation": "Exemple: traite l'énoncé comme une API stricte. Contexte: L’énoncé ne demande pas d’erreur explicite. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-152",
    "category": "Règles implicites",
    "question": "Une fonction doit retourner un pointeur.",
    "answer": "A mémoriser: La liste des fonctions autorisées est fermée: ce qui n'est pas listé est interdit. | Méthode concrète: 1) retourner une adresse valide -> 2) pas une variable locale | Erreur fréquente: Fonction interdite = rendu invalide. | Auto-vérification: Passe tous tes appels en revue avant de rendre.",
    "explanation": "Exemple: write-only signifie réellement write-only. Contexte: Une fonction doit retourner un pointeur. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-153",
    "category": "Règles implicites",
    "question": "calloc est autorisé?",
    "answer": "A mémoriser: La liste des fonctions autorisées est fermée: ce qui n'est pas listé est interdit. | Méthode concrète: 1) non -> 2) pas listé | Erreur fréquente: Fonction interdite = rendu invalide. | Auto-vérification: Passe tous tes appels en revue avant de rendre.",
    "explanation": "Exemple: write-only signifie réellement write-only. Contexte: calloc est autorisé? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-154",
    "category": "Règles implicites",
    "question": "Les exemples fournis servent à quoi?",
    "answer": "A mémoriser: En exam 42, conformité du contrat = aussi important que l'algorithme. | Méthode concrète: 1) contrat exact -> 2) format à respecter | Erreur fréquente: Une solution logique peut être refusée pour non-conformité de forme. | Auto-vérification: Fais une revue finale: output, fonctions autorisées, signatures, fichiers.",
    "explanation": "Exemple: traite l'énoncé comme une API stricte. Contexte: Les exemples fournis servent à quoi? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-155",
    "category": "Règles implicites",
    "question": "Afficher sur stderr au lieu de stdout?",
    "answer": "A mémoriser: La sortie doit être exactement celle du sujet: contenu, ordre, flux, newline. | Méthode concrète: 1) tests ratés | Erreur fréquente: Un seul caractère en trop suffit à rater. | Auto-vérification: Vérifie la sortie caractère par caractère.",
    "explanation": "Exemple: `cat -e` aide à détecter les fins de ligne manquantes. Contexte: Afficher sur stderr au lieu de stdout? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-156",
    "category": "Règles implicites",
    "question": "Tu affiches plus que demandé.",
    "answer": "A mémoriser: En exam 42, conformité du contrat = aussi important que l'algorithme. | Méthode concrète: 1) tests KO | Erreur fréquente: Une solution logique peut être refusée pour non-conformité de forme. | Auto-vérification: Fais une revue finale: output, fonctions autorisées, signatures, fichiers.",
    "explanation": "Exemple: traite l'énoncé comme une API stricte. Contexte: Tu affiches plus que demandé. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-157",
    "category": "Règles implicites",
    "question": "Un cas n’est pas décrit.",
    "answer": "A mémoriser: Quand le sujet ne précise pas, reste minimal et conforme. | Méthode concrète: 1) rester minimal -> 2) ne rien inventer | Erreur fréquente: Ajouter du comportement inventé casse les tests. | Auto-vérification: Supprime les debug prints et relis l'énoncé une dernière fois.",
    "explanation": "Exemple: la meilleure protection est une relecture finale complète. Contexte: Un cas n’est pas décrit. Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-158",
    "category": "Règles implicites",
    "question": "Pourquoi respecter les noms exacts?",
    "answer": "A mémoriser: Noms de fichiers, prototypes et structures imposées doivent rester identiques. | Méthode concrète: 1) linker -> 2) compilation | Erreur fréquente: La compilation ou le linkage peut échouer même avec bonne logique. | Auto-vérification: Compare symboles et signatures avec l'énoncé.",
    "explanation": "Exemple: `Expected files: wdmatch.c` impose ce nom exact. Contexte: Pourquoi respecter les noms exacts? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-159",
    "category": "Règles implicites",
    "question": "Changer l’ordre d’affichage?",
    "answer": "A mémoriser: La sortie doit être exactement celle du sujet: contenu, ordre, flux, newline. | Méthode concrète: 1) interdit -> 2) tests KO | Erreur fréquente: Un seul caractère en trop suffit à rater. | Auto-vérification: Vérifie la sortie caractère par caractère.",
    "explanation": "Exemple: `cat -e` aide à détecter les fins de ligne manquantes. Contexte: Changer l’ordre d’affichage? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-160",
    "category": "Règles implicites",
    "question": "Règle implicite numéro un?",
    "answer": "A mémoriser: Quand le sujet ne précise pas, reste minimal et conforme. | Méthode concrète: 1) relire l’énoncé -> 2) respecter chaque mot | Erreur fréquente: Ajouter du comportement inventé casse les tests. | Auto-vérification: Supprime les debug prints et relis l'énoncé une dernière fois.",
    "explanation": "Exemple: la meilleure protection est une relecture finale complète. Contexte: Règle implicite numéro un? Garde ce réflexe en tête avant de coder pour sécuriser le comportement sur les cas réels de l'exam.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  }
]
