[
  {
    "id": "fc-001",
    "category": "Patterns",
    "question": "Tu dois convertir un int en string. Quel pattern appliquer ?",
    "answer": "Checklist opérationnelle: 1) gérer le signe | 2) caster en long | 3) compter chiffres | 4) malloc taille +1 (+1 si négatif) | 5) '\\0' final | 6) remplir à l’envers | 7) poser '-' si besoin. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite itoa dans le thème « Patterns ». En pratique: commence par gérer le signe, enchaîne avec caster en long, puis termine par poser '-' si besoin. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Tu dois convertir un int en string. Quel pattern appliquer ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-002",
    "category": "Patterns",
    "question": "Avant de coder split, quel pattern préparer ?",
    "answer": "Checklist opérationnelle: 1) définir séparateurs | 2) ignorer séparateurs | 3) compter mots | 4) malloc tableau (mots + NULL) | 5) pour chaque mot : compter lettres | 6) malloc mot +1 | 7) copier | 8) NULL final. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite split dans le thème « Patterns ». En pratique: commence par définir séparateurs, enchaîne avec ignorer séparateurs, puis termine par NULL final. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Avant de coder split, quel pattern préparer ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-003",
    "category": "Patterns",
    "question": "Quel est le pattern pour remplir un tableau de start à end ?",
    "answer": "Checklist opérationnelle: 1) calculer taille = abs(end-start)+1 | 2) step = +1 ou -1 | 3) malloc | 4) boucle de remplissage | 5) return ptr. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite ft_range dans le thème « Patterns ». En pratique: commence par calculer taille = abs(end-start)+1, enchaîne avec step = +1 ou -1, puis termine par return ptr. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Quel est le pattern pour remplir un tableau de start à end ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-004",
    "category": "Patterns",
    "question": "Comment éviter les doublons de caractères ?",
    "answer": "Checklist opérationnelle: 1) tableau seen[256] | 2) indexer avec unsigned char | 3) afficher si seen == 0 | 4) marquer seen = 1. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite union/inter dans le thème « Patterns ». En pratique: commence par tableau seen[256], enchaîne avec indexer avec unsigned char, puis termine par marquer seen = 1. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment éviter les doublons de caractères ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-005",
    "category": "Patterns",
    "question": "Quel est le pattern de wdmatch ?",
    "answer": "Checklist opérationnelle: 1) parcourir string 2 | 2) avancer index string 1 quand match | 3) fin si index1 == fin | 4) afficher string 1 si réussi. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite wdmatch dans le thème « Patterns ». En pratique: commence par parcourir string 2, enchaîne avec avancer index string 1 quand match, puis termine par afficher string 1 si réussi. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Quel est le pattern de wdmatch ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-006",
    "category": "Patterns",
    "question": "Quel est le pattern de strdup ?",
    "answer": "Checklist opérationnelle: 1) compter longueur | 2) malloc len +1 | 3) copier | 4) '\\0'. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite strdup dans le thème « Patterns ». En pratique: commence par compter longueur, enchaîne avec malloc len +1, puis termine par '\\0'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Quel est le pattern de strdup ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-007",
    "category": "Patterns",
    "question": "Comment parcourir une liste ?",
    "answer": "Checklist opérationnelle: 1) cur = begin | 2) while(cur) | 3) appliquer f(cur->data) | 4) cur = cur->next. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite list_foreach dans le thème « Patterns ». En pratique: commence par cur = begin, enchaîne avec while(cur), puis termine par cur = cur->next. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment parcourir une liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-008",
    "category": "Patterns",
    "question": "Quel est le pattern général ?",
    "answer": "Checklist opérationnelle: 1) nettoyer tête avec while | 2) utiliser double pointeur | 3) parcourir avec cur | 4) tmp = cur->next | 5) unlink | 6) free(tmp). Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite list_remove_if dans le thème « Patterns ». En pratique: commence par nettoyer tête avec while, enchaîne avec utiliser double pointeur, puis termine par free(tmp). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Quel est le pattern général ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-009",
    "category": "Patterns",
    "question": "Quel pattern simple pour trier une liste ?",
    "answer": "Checklist opérationnelle: 1) bubble sort | 2) flag swapped | 3) parcourir | 4) swap data | 5) recommencer si swapped. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite sort_list dans le thème « Patterns ». En pratique: commence par bubble sort, enchaîne avec flag swapped, puis termine par recommencer si swapped. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Quel pattern simple pour trier une liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-010",
    "category": "Patterns",
    "question": "Pattern classique pour atoi ?",
    "answer": "Checklist opérationnelle: 1) ignorer espaces | 2) gérer signe | 3) accumuler n = n*10 + digit | 4) return résultat. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite atoi dans le thème « Patterns ». En pratique: commence par ignorer espaces, enchaîne avec gérer signe, puis termine par return résultat. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern classique pour atoi ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-011",
    "category": "Patterns",
    "question": "Pattern pour trouver le dernier mot ?",
    "answer": "Checklist opérationnelle: 1) aller en fin | 2) reculer sur séparateurs | 3) marquer fin | 4) reculer lettres | 5) afficher segment. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite last_word dans le thème « Patterns ». En pratique: commence par aller en fin, enchaîne avec reculer sur séparateurs, puis termine par afficher segment. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern pour trouver le dernier mot ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-012",
    "category": "Patterns",
    "question": "Comment inverser une string ?",
    "answer": "Checklist opérationnelle: 1) deux indices i/j | 2) swap | 3) i++ / j-- | 4) stop quand i >= j. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite strrev dans le thème « Patterns ». En pratique: commence par deux indices i/j, enchaîne avec swap, puis termine par stop quand i >= j. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment inverser une string ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-013",
    "category": "Patterns",
    "question": "Pattern de remplacement simple ?",
    "answer": "Checklist opérationnelle: 1) parcourir string | 2) if char == cible → remplacer | 3) write char. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite search and replace dans le thème « Patterns ». En pratique: commence par parcourir string, enchaîne avec if char == cible → remplacer, puis termine par write char. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern de remplacement simple ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-014",
    "category": "Patterns",
    "question": "Comment compter les maillons ?",
    "answer": "Checklist opérationnelle: 1) count = 0 | 2) while(lst) | 3) count++ | 4) lst = lst->next. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite lstsize dans le thème « Patterns ». En pratique: commence par count = 0, enchaîne avec while(lst), puis termine par lst = lst->next. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment compter les maillons ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-015",
    "category": "Patterns",
    "question": "Pattern pour afficher une string ?",
    "answer": "Checklist opérationnelle: 1) parcourir | 2) write(1,&c,1) | 3) '\\n' si demandé. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite putstr dans le thème « Patterns ». En pratique: commence par parcourir, enchaîne avec write(1,&c,1), puis termine par '\\n' si demandé. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern pour afficher une string ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-016",
    "category": "Patterns",
    "question": "Pattern de rotation de lettres ?",
    "answer": "Checklist opérationnelle: 1) tester plage a-z / A-Z | 2) décaler | 3) wrap si dépasse | 4) écrire char. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite rot13 / rotone dans le thème « Patterns ». En pratique: commence par tester plage a-z / A-Z, enchaîne avec décaler, puis termine par écrire char. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern de rotation de lettres ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-017",
    "category": "Patterns",
    "question": "Pattern pour parcourir argv ?",
    "answer": "Checklist opérationnelle: 1) i = 1 | 2) while(argv[i]) | 3) traiter | 4) i++. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite foreach argv dans le thème « Patterns ». En pratique: commence par i = 1, enchaîne avec while(argv[i]), puis termine par i++. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern pour parcourir argv ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-018",
    "category": "Patterns",
    "question": "Comment supprimer plusieurs têtes ?",
    "answer": "Checklist opérationnelle: 1) while(*begin && cmp(...)==0) | 2) tmp = *begin | 3) *begin = tmp->next | 4) free(tmp). Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite ft_list_remove_if tête dans le thème « Patterns ». En pratique: commence par while(*begin && cmp(...)==0), enchaîne avec tmp = *begin, puis termine par free(tmp). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment supprimer plusieurs têtes ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-019",
    "category": "Patterns",
    "question": "Comment repérer un début de mot ?",
    "answer": "Checklist opérationnelle: 1) caractère non séparateur | 2) précédé par séparateur ou début | 3) start index. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite split : détecter mot dans le thème « Patterns ». En pratique: commence par caractère non séparateur, enchaîne avec précédé par séparateur ou début, puis termine par start index. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Comment repérer un début de mot ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-020",
    "category": "Patterns",
    "question": "Pattern d’affichage à l’exam ?",
    "answer": "Checklist opérationnelle: 1) respecter strictement | 2) write only | 3) newline final | 4) rien en trop. Objectif: appliquer une méthode stable et rapide en exam.",
    "explanation": "Cette carte traite affichage exam dans le thème « Patterns ». En pratique: commence par respecter strictement, enchaîne avec write only, puis termine par rien en trop. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'ordre des étapes est inversé. Repère rapide: relis la question (« Pattern d’affichage à l’exam ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-021",
    "category": "Pièges",
    "question": "Tu copies une string sans ajouter '\\0'. Que risque-tu ?",
    "answer": "Checklist opérationnelle: 1) lecture hors limites | 2) affichage aléatoire | 3) crash possible | 4) tests KO. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite string sans '\\0' dans le thème « Pièges ». En pratique: commence par lecture hors limites, enchaîne avec affichage aléatoire, puis termine par tests KO. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu copies une string sans ajouter '\\0'. Que risque-tu ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-022",
    "category": "Pièges",
    "question": "Tu fais malloc(len) pour une string. Problème ?",
    "answer": "Checklist opérationnelle: 1) pas de place pour '\\0' | 2) écriture hors tableau | 3) comportement indéfini. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite malloc trop petit dans le thème « Pièges ». En pratique: commence par pas de place pour '\\0', enchaîne avec écriture hors tableau, puis termine par comportement indéfini. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu fais malloc(len) pour une string. Problème ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-023",
    "category": "Pièges",
    "question": "argc n’est pas celui attendu. Que faire ?",
    "answer": "Checklist opérationnelle: 1) afficher seulement '\\n' | 2) rien d’autre. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite argc incorrect dans le thème « Pièges ». Séquence minimale: afficher seulement '\\n', puis rien d’autre. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« argc n’est pas celui attendu. Que faire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-024",
    "category": "Pièges",
    "question": "Tu utilises char comme index dans seen[256]. Danger ?",
    "answer": "Checklist opérationnelle: 1) valeur négative possible | 2) accès hors tableau | 3) caster unsigned char. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite char signé dans le thème « Pièges ». En pratique: commence par valeur négative possible, enchaîne avec accès hors tableau, puis termine par caster unsigned char. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu utilises char comme index dans seen[256]. Danger ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-025",
    "category": "Pièges",
    "question": "Dans remove_if, tu avances cur après unlink. Risque ?",
    "answer": "Checklist opérationnelle: 1) sauter un maillon | 2) suppression incomplète. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite avancer après suppression dans le thème « Pièges ». Séquence minimale: sauter un maillon, puis suppression incomplète. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Dans remove_if, tu avances cur après unlink. Risque ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-026",
    "category": "Pièges",
    "question": "itoa sans gérer INT_MIN ?",
    "answer": "Checklist opérationnelle: 1) overflow | 2) valeur fausse | 3) tests ratés. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite INT_MIN dans le thème « Pièges ». En pratique: commence par overflow, enchaîne avec valeur fausse, puis termine par tests ratés. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« itoa sans gérer INT_MIN ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-027",
    "category": "Pièges",
    "question": "write est imposé mais tu utilises printf ?",
    "answer": "Checklist opérationnelle: 1) interdit | 2) note = 0 | 3) tests KO. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite printf interdit dans le thème « Pièges ». En pratique: commence par interdit, enchaîne avec note = 0, puis termine par tests KO. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« write est imposé mais tu utilises printf ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-028",
    "category": "Pièges",
    "question": "Tu free un maillon avant de reconnecter la liste ?",
    "answer": "Checklist opérationnelle: 1) corruption | 2) accès mémoire invalide. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite free avant unlink dans le thème « Pièges ». Séquence minimale: corruption, puis accès mémoire invalide. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu free un maillon avant de reconnecter la liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-029",
    "category": "Pièges",
    "question": "Tu oublies le NULL final dans split ?",
    "answer": "Checklist opérationnelle: 1) parcours infini | 2) segfault. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite NULL oublié dans le thème « Pièges ». Séquence minimale: parcours infini, puis segfault. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu oublies le NULL final dans split ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-030",
    "category": "Pièges",
    "question": "len non initialisé avant comptage ?",
    "answer": "Checklist opérationnelle: 1) taille aléatoire | 2) malloc faux | 3) crash. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite variable non initialisée dans le thème « Pièges ». En pratique: commence par taille aléatoire, enchaîne avec malloc faux, puis termine par crash. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« len non initialisé avant comptage ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-031",
    "category": "Pièges",
    "question": "Tu free deux fois le même pointeur ?",
    "answer": "Checklist opérationnelle: 1) segfault | 2) corruption heap. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite double free dans le thème « Pièges ». Séquence minimale: segfault, puis corruption heap. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu free deux fois le même pointeur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-032",
    "category": "Pièges",
    "question": "Tu écris `*p = malloc(10)` alors que p est `char *` ?",
    "answer": "Checklist opérationnelle: 1) type invalide | 2) écrasement mémoire. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite mauvais pointeur dans le thème « Pièges ». Séquence minimale: type invalide, puis écrasement mémoire. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu écris `*p = malloc(10)` alors que p est `char *` ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-033",
    "category": "Pièges",
    "question": "Tu retournes l’adresse d’une variable locale ?",
    "answer": "Checklist opérationnelle: 1) dangling pointer | 2) crash futur. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite return local dans le thème « Pièges ». Séquence minimale: dangling pointer, puis crash futur. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu retournes l’adresse d’une variable locale ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-034",
    "category": "Pièges",
    "question": "Boucle i <= len au lieu de i < len ?",
    "answer": "Checklist opérationnelle: 1) dépassement | 2) corruption. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite off-by-one dans le thème « Pièges ». Séquence minimale: dépassement, puis corruption. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Boucle i <= len au lieu de i < len ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-035",
    "category": "Pièges",
    "question": "Tu oublies d’ignorer les séparateurs dans split ?",
    "answer": "Checklist opérationnelle: 1) mots vides | 2) mauvaise sortie. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite skip séparateurs dans le thème « Pièges ». Séquence minimale: mots vides, puis mauvaise sortie. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu oublies d’ignorer les séparateurs dans split ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-036",
    "category": "Pièges",
    "question": "Tu ne vérifies pas malloc ?",
    "answer": "Checklist opérationnelle: 1) segfault si NULL. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite malloc non testé dans le thème « Pièges ». Point central: segfault si NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu ne vérifies pas malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-037",
    "category": "Pièges",
    "question": "seen[256] non initialisé ?",
    "answer": "Checklist opérationnelle: 1) faux doublons | 2) comportement aléatoire. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite seen pas remis à zéro dans le thème « Pièges ». Séquence minimale: faux doublons, puis comportement aléatoire. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« seen[256] non initialisé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-038",
    "category": "Pièges",
    "question": "Dans une liste, tu avances cur au mauvais moment ?",
    "answer": "Checklist opérationnelle: 1) élément ignoré | 2) bug logique. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite avancer mauvais pointeur dans le thème « Pièges ». Séquence minimale: élément ignoré, puis bug logique. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Dans une liste, tu avances cur au mauvais moment ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-039",
    "category": "Pièges",
    "question": "L’énoncé demande un newline final, tu l’oublies ?",
    "answer": "Checklist opérationnelle: 1) tests automatiques échouent. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite '\\n' oublié dans le thème « Pièges ». Point central: tests automatiques échouent. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« L’énoncé demande un newline final, tu l’oublies ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-040",
    "category": "Pièges",
    "question": "Tu fais malloc(1000) “pour être large” ?",
    "answer": "Checklist opérationnelle: 1) pas robuste | 2) tests limites ratés | 3) mauvaise pratique. Objectif: éviter les erreurs qui cassent les tests.",
    "explanation": "Cette carte traite malloc arbitraire dans le thème « Pièges ». En pratique: commence par pas robuste, enchaîne avec tests limites ratés, puis termine par mauvaise pratique. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: une erreur silencieuse passe inaperçue en local. Repère rapide: relis la question (« Tu fais malloc(1000) “pour être large” ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-041",
    "category": "Réflexes mémoire",
    "question": "Tu alloues une string copiée. Quelle taille minimale ?",
    "answer": "Checklist opérationnelle: 1) longueur + 1 | 2) place pour '\\0'. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite string malloc dans le thème « Réflexes mémoire ». Séquence minimale: longueur + 1, puis place pour '\\0'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Tu alloues une string copiée. Quelle taille minimale ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-042",
    "category": "Réflexes mémoire",
    "question": "Quel est le premier test après malloc ?",
    "answer": "Checklist opérationnelle: 1) if (!ptr) return NULL;. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite malloc check dans le thème « Réflexes mémoire ». Point central: if (!ptr) return NULL;. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Quel est le premier test après malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-043",
    "category": "Réflexes mémoire",
    "question": "Comment doit se terminer un tableau de strings ?",
    "answer": "Checklist opérationnelle: 1) pointeur NULL final. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite tableau de strings dans le thème « Réflexes mémoire ». Point central: pointeur NULL final. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Comment doit se terminer un tableau de strings ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-044",
    "category": "Réflexes mémoire",
    "question": "Quand libérer un maillon supprimé ?",
    "answer": "Checklist opérationnelle: 1) après avoir reconnecté la liste. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite free après unlink dans le thème « Réflexes mémoire ». Point central: après avoir reconnecté la liste. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Quand libérer un maillon supprimé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-045",
    "category": "Réflexes mémoire",
    "question": "Pourquoi écrire sizeof(type) * n ?",
    "answer": "Checklist opérationnelle: 1) nombre d’octets correct. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite sizeof dans le thème « Réflexes mémoire ». Point central: nombre d’octets correct. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi écrire sizeof(type) * n ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-046",
    "category": "Réflexes mémoire",
    "question": "Quelle taille malloc pour \"-42\" ?",
    "answer": "Checklist opérationnelle: 1) 4 caractères : '-', '4', '2', '\\0'. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite itoa taille dans le thème « Réflexes mémoire ». Point central: 4 caractères : '-', '4', '2', '\\0'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Quelle taille malloc pour \"-42\" ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-047",
    "category": "Réflexes mémoire",
    "question": "Que faire après free(ptr) ?",
    "answer": "Checklist opérationnelle: 1) ptr = NULL (si possible). Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite pointeur après free dans le thème « Réflexes mémoire ». Point central: ptr = NULL (si possible). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Que faire après free(ptr) ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-048",
    "category": "Réflexes mémoire",
    "question": "Pourquoi compter avant malloc ?",
    "answer": "Checklist opérationnelle: 1) allouer juste | 2) éviter dépassement. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite compter avant malloc dans le thème « Réflexes mémoire ». Séquence minimale: allouer juste, puis éviter dépassement. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi compter avant malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-049",
    "category": "Réflexes mémoire",
    "question": "Pourquoi initialiser seen[256] ?",
    "answer": "Checklist opérationnelle: 1) éviter faux positifs | 2) état propre. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite seen[256] dans le thème « Réflexes mémoire ». Séquence minimale: éviter faux positifs, puis état propre. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi initialiser seen[256] ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-050",
    "category": "Réflexes mémoire",
    "question": "Qui doit free la mémoire retournée par une fonction ?",
    "answer": "Checklist opérationnelle: 1) l’appelant. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite owner mémoire dans le thème « Réflexes mémoire ». Point central: l’appelant. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Qui doit free la mémoire retournée par une fonction ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-051",
    "category": "Réflexes mémoire",
    "question": "Comment allouer un tableau de pointeurs vers mots ?",
    "answer": "Checklist opérationnelle: 1) malloc(nb_mots + 1) | 2) NULL final. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite tableau 2D dans le thème « Réflexes mémoire ». Séquence minimale: malloc(nb_mots + 1), puis NULL final. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Comment allouer un tableau de pointeurs vers mots ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-052",
    "category": "Réflexes mémoire",
    "question": "Pourquoi caster en long dans itoa ?",
    "answer": "Checklist opérationnelle: 1) éviter overflow (INT_MIN). Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite long cast dans le thème « Réflexes mémoire ». Point central: éviter overflow (INT_MIN). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi caster en long dans itoa ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-053",
    "category": "Réflexes mémoire",
    "question": "Pourquoi caster en unsigned char ?",
    "answer": "Checklist opérationnelle: 1) éviter index négatif. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite index unsigned dans le thème « Réflexes mémoire ». Point central: éviter index négatif. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi caster en unsigned char ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-054",
    "category": "Réflexes mémoire",
    "question": "Pourquoi initialiser len = 0 ?",
    "answer": "Checklist opérationnelle: 1) éviter valeur aléatoire. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite variable init dans le thème « Réflexes mémoire ». Point central: éviter valeur aléatoire. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi initialiser len = 0 ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-055",
    "category": "Réflexes mémoire",
    "question": "Si malloc échoue au milieu de split ?",
    "answer": "Checklist opérationnelle: 1) free ce qui est déjà alloué. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite free en erreur dans le thème « Réflexes mémoire ». Point central: free ce qui est déjà alloué. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Si malloc échoue au milieu de split ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-056",
    "category": "Réflexes mémoire",
    "question": "Pourquoi éviter malloc(1000) arbitraire ?",
    "answer": "Checklist opérationnelle: 1) imprécis | 2) fragile. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite buffer fixe dans le thème « Réflexes mémoire ». Séquence minimale: imprécis, puis fragile. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi éviter malloc(1000) arbitraire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-057",
    "category": "Réflexes mémoire",
    "question": "Pourquoi ajouter '\\0' ?",
    "answer": "Checklist opérationnelle: 1) terminaison string | 2) affichage correct. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite '\\0' final dans le thème « Réflexes mémoire ». Séquence minimale: terminaison string, puis affichage correct. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi ajouter '\\0' ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-058",
    "category": "Réflexes mémoire",
    "question": "Pourquoi t_list dans remove_if ?",
    "answer": "Checklist opérationnelle: 1) modifier la tête | 2) éviter perdre accès. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite double pointeur dans le thème « Réflexes mémoire ». Séquence minimale: modifier la tête, puis éviter perdre accès. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi t_list dans remove_if ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-059",
    "category": "Réflexes mémoire",
    "question": "Pourquoi sizeof(ptr) est souvent faux ?",
    "answer": "Checklist opérationnelle: 1) taille pointeur | 2) pas taille élément. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite sizeof(ptr) dans le thème « Réflexes mémoire ». Séquence minimale: taille pointeur, puis pas taille élément. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Pourquoi sizeof(ptr) est souvent faux ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-060",
    "category": "Réflexes mémoire",
    "question": "Que fait free(NULL) ? (free(NULL), Réflexes mémoire)",
    "answer": "Checklist opérationnelle: 1) rien | 2) sûr. Objectif: sécuriser les allocations et les libérations.",
    "explanation": "Cette carte traite free(NULL) dans le thème « Réflexes mémoire ». Séquence minimale: rien, puis sûr. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la taille ou la libération est mal gérée. Repère rapide: relis la question (« Que fait free(NULL) ? (free(NULL), Réflexes mémoire) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-061",
    "category": "Pointeurs",
    "question": "Qu’est-ce qu’un pointeur en C ?",
    "answer": "Checklist opérationnelle: 1) une variable qui contient une adresse mémoire. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite définition dans le thème « Pointeurs ». Point central: une variable qui contient une adresse mémoire. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Qu’est-ce qu’un pointeur en C ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-062",
    "category": "Pointeurs",
    "question": "Que fait `*p` ? (deref, Pointeurs)",
    "answer": "Checklist opérationnelle: 1) accède à la valeur pointée. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite deref dans le thème « Pointeurs ». Point central: accède à la valeur pointée. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Que fait `*p` ? (deref, Pointeurs) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-063",
    "category": "Pointeurs",
    "question": "Que fait `&x` ? (&, Pointeurs)",
    "answer": "Checklist opérationnelle: 1) donne l’adresse de x. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite & dans le thème « Pointeurs ». Point central: donne l’adresse de x. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Que fait `&x` ? (&, Pointeurs) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-064",
    "category": "Pointeurs",
    "question": "Pourquoi utiliser `t_list ` ?",
    "answer": "Checklist opérationnelle: 1) modifier la tête | 2) changer un pointeur. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite simple vs double dans le thème « Pointeurs ». Séquence minimale: modifier la tête, puis changer un pointeur. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi utiliser `t_list ` ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-065",
    "category": "Pointeurs",
    "question": "Quelle ligne fait avancer dans une liste ?",
    "answer": "Checklist opérationnelle: 1) cur = cur->next. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite avancer liste dans le thème « Pointeurs ». Point central: cur = cur->next. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Quelle ligne fait avancer dans une liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-066",
    "category": "Pointeurs",
    "question": "Quel opérateur pour accéder à un champ via pointeur ?",
    "answer": "Checklist opérationnelle: 1) ->. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite opérateur dans le thème « Pointeurs ». Point central: ->. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Quel opérateur pour accéder à un champ via pointeur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-067",
    "category": "Pointeurs",
    "question": "Danger d’un pointeur non initialisé ?",
    "answer": "Checklist opérationnelle: 1) comportement indéfini | 2) segfault. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite pointeur non init dans le thème « Pointeurs ». Séquence minimale: comportement indéfini, puis segfault. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Danger d’un pointeur non initialisé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-068",
    "category": "Pointeurs",
    "question": "Peut-on utiliser un pointeur après free ?",
    "answer": "Checklist opérationnelle: 1) non | 2) dangling pointer. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite après free dans le thème « Pointeurs ». Séquence minimale: non, puis dangling pointer. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Peut-on utiliser un pointeur après free ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-069",
    "category": "Pointeurs",
    "question": "Pourquoi argv est un char ?",
    "answer": "Checklist opérationnelle: 1) tableau de strings. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite argv dans le thème « Pointeurs ». Point central: tableau de strings. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi argv est un char ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-070",
    "category": "Pointeurs",
    "question": "Pourquoi utiliser un pointeur tmp en liste ?",
    "answer": "Checklist opérationnelle: 1) garder adresse | 2) free ensuite. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite tmp dans le thème « Pointeurs ». Séquence minimale: garder adresse, puis free ensuite. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi utiliser un pointeur tmp en liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-071",
    "category": "Pointeurs",
    "question": "Quelle ligne modifie la tête ?",
    "answer": "Checklist opérationnelle: 1) *begin = (*begin)->next. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite changer tête dans le thème « Pointeurs ». Point central: *begin = (*begin)->next. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Quelle ligne modifie la tête ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-072",
    "category": "Pointeurs",
    "question": "Que se passe-t-il si on deref NULL ?",
    "answer": "Checklist opérationnelle: 1) segfault. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite deref NULL dans le thème « Pointeurs ». Point central: segfault. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Que se passe-t-il si on deref NULL ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-073",
    "category": "Pointeurs",
    "question": "Pourquoi swap data plutôt que liens ?",
    "answer": "Checklist opérationnelle: 1) plus simple | 2) moins risqué. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite swap dans le thème « Pointeurs ». Séquence minimale: plus simple, puis moins risqué. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi swap data plutôt que liens ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-074",
    "category": "Pointeurs",
    "question": "Pourquoi `*cur->next` est piégeux ?",
    "answer": "Checklist opérationnelle: 1) -> avant * | 2) parenthèses nécessaires. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite priorité opérateurs dans le thème « Pointeurs ». Séquence minimale: -> avant *, puis parenthèses nécessaires. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi `*cur->next` est piégeux ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-075",
    "category": "Pointeurs",
    "question": "Que représente void * ?",
    "answer": "Checklist opérationnelle: 1) pointeur générique. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite type void * dans le thème « Pointeurs ». Point central: pointeur générique. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Que représente void * ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-076",
    "category": "Pointeurs",
    "question": "Quand vérifier un pointeur ?",
    "answer": "Checklist opérationnelle: 1) avant deref. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite vérification dans le thème « Pointeurs ». Point central: avant deref. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Quand vérifier un pointeur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-077",
    "category": "Pointeurs",
    "question": "Différence char s[10] / char *s ?",
    "answer": "Checklist opérationnelle: 1) tableau vs adresse | 2) stockage différent. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite tableau vs pointeur dans le thème « Pointeurs ». Séquence minimale: tableau vs adresse, puis stockage différent. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Différence char s[10] / char *s ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-078",
    "category": "Pointeurs",
    "question": "Pourquoi ne pas retourner &local ?",
    "answer": "Checklist opérationnelle: 1) pointeur mort | 2) stack détruite. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite return local dans le thème « Pointeurs ». Séquence minimale: pointeur mort, puis stack détruite. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi ne pas retourner &local ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-079",
    "category": "Pointeurs",
    "question": "Pourquoi ne pas faire cur++ sur une liste ?",
    "answer": "Checklist opérationnelle: 1) pas contigu | 2) mémoire arbitraire. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite ++ interdit dans le thème « Pointeurs ». Séquence minimale: pas contigu, puis mémoire arbitraire. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Pourquoi ne pas faire cur++ sur une liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "easy",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-080",
    "category": "Pointeurs",
    "question": "Risque principal avec un double pointeur ?",
    "answer": "Checklist opérationnelle: 1) modifier mauvaise adresse | 2) perdre tête. Objectif: manipuler adresses et déréférencement proprement.",
    "explanation": "Cette carte traite double pointeur danger dans le thème « Pointeurs ». Séquence minimale: modifier mauvaise adresse, puis perdre tête. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le pointeur devient invalide ou pointe au mauvais endroit. Repère rapide: relis la question (« Risque principal avec un double pointeur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-081",
    "category": "Malloc",
    "question": "À quoi sert malloc ? (définition, Malloc)",
    "answer": "Checklist opérationnelle: 1) allouer dynamiquement en heap | 2) renvoie un pointeur. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite définition dans le thème « Malloc ». Séquence minimale: allouer dynamiquement en heap, puis renvoie un pointeur. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« À quoi sert malloc ? (définition, Malloc) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-082",
    "category": "Malloc",
    "question": "Que retourne malloc en cas d’échec ?",
    "answer": "Checklist opérationnelle: 1) NULL. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite échec dans le thème « Malloc ». Point central: NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Que retourne malloc en cas d’échec ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-083",
    "category": "Malloc",
    "question": "Quelle taille malloc pour copier une string ?",
    "answer": "Checklist opérationnelle: 1) longueur + 1 | 2) '\\0'. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite taille string dans le thème « Malloc ». Séquence minimale: longueur + 1, puis '\\0'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Quelle taille malloc pour copier une string ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-084",
    "category": "Malloc",
    "question": "Pourquoi sizeof(type) * n ?",
    "answer": "Checklist opérationnelle: 1) nombre d’octets correct. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite sizeof dans le thème « Malloc ». Point central: nombre d’octets correct. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi sizeof(type) * n ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-085",
    "category": "Malloc",
    "question": "Quel test immédiat après malloc ?",
    "answer": "Checklist opérationnelle: 1) if (!ptr) return NULL. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite test dans le thème « Malloc ». Point central: if (!ptr) return NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Quel test immédiat après malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-086",
    "category": "Malloc",
    "question": "Qui doit free la mémoire retournée ?",
    "answer": "Checklist opérationnelle: 1) l’appelant. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite ownership dans le thème « Malloc ». Point central: l’appelant. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Qui doit free la mémoire retournée ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-087",
    "category": "Malloc",
    "question": "Que fait free(NULL) ? (free(NULL), Malloc)",
    "answer": "Checklist opérationnelle: 1) rien | 2) sûr. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite free(NULL) dans le thème « Malloc ». Séquence minimale: rien, puis sûr. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Que fait free(NULL) ? (free(NULL), Malloc) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-088",
    "category": "Malloc",
    "question": "Pourquoi éviter malloc(1000) arbitraire ?",
    "answer": "Checklist opérationnelle: 1) fragile | 2) imprécis. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite buffer fixe dans le thème « Malloc ». Séquence minimale: fragile, puis imprécis. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi éviter malloc(1000) arbitraire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-089",
    "category": "Malloc",
    "question": "Pourquoi sizeof(ptr) est faux pour tableau ?",
    "answer": "Checklist opérationnelle: 1) taille pointeur | 2) pas élément. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite sizeof(ptr) dans le thème « Malloc ». Séquence minimale: taille pointeur, puis pas élément. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi sizeof(ptr) est faux pour tableau ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-090",
    "category": "Malloc",
    "question": "Comment allouer un tableau de mots ?",
    "answer": "Checklist opérationnelle: 1) malloc(nb + 1) | 2) NULL final. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite 2D dans le thème « Malloc ». Séquence minimale: malloc(nb + 1), puis NULL final. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Comment allouer un tableau de mots ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-091",
    "category": "Malloc",
    "question": "Quand free un maillon supprimé ?",
    "answer": "Checklist opérationnelle: 1) après reconnecter. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite libérer après unlink dans le thème « Malloc ». Point central: après reconnecter. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Quand free un maillon supprimé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-092",
    "category": "Malloc",
    "question": "malloc échoue dans split à mi-chemin ?",
    "answer": "Checklist opérationnelle: 1) free ce qui est déjà alloué. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite erreur intermédiaire dans le thème « Malloc ». Point central: free ce qui est déjà alloué. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« malloc échoue dans split à mi-chemin ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-093",
    "category": "Malloc",
    "question": "Que fait calloc ? (calloc, Malloc)",
    "answer": "Checklist opérationnelle: 1) malloc + mise à zéro. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite calloc dans le thème « Malloc ». Point central: malloc + mise à zéro. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Que fait calloc ? (calloc, Malloc) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-094",
    "category": "Malloc",
    "question": "À quoi sert realloc ? (realloc, Malloc)",
    "answer": "Checklist opérationnelle: 1) agrandir / réduire | 2) conserve contenu. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite realloc dans le thème « Malloc ». Séquence minimale: agrandir / réduire, puis conserve contenu. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« À quoi sert realloc ? (realloc, Malloc) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-095",
    "category": "Malloc",
    "question": "Qu’est-ce qu’une fuite mémoire ?",
    "answer": "Checklist opérationnelle: 1) mémoire jamais free. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite fuite dans le thème « Malloc ». Point central: mémoire jamais free. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Qu’est-ce qu’une fuite mémoire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-096",
    "category": "Malloc",
    "question": "Pourquoi mettre ptr = NULL après free ?",
    "answer": "Checklist opérationnelle: 1) éviter réutilisation. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite après free dans le thème « Malloc ». Point central: éviter réutilisation. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi mettre ptr = NULL après free ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-097",
    "category": "Malloc",
    "question": "Pourquoi +1 dans ft_range ?",
    "answer": "Checklist opérationnelle: 1) inclure start et end. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite taille inclusive dans le thème « Malloc ». Point central: inclure start et end. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi +1 dans ft_range ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-098",
    "category": "Malloc",
    "question": "Pourquoi malloc len + sign + 1 ?",
    "answer": "Checklist opérationnelle: 1) '-' | 2) '\\0'. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite itoa dans le thème « Malloc ». Séquence minimale: '-', puis '\\0'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi malloc len + sign + 1 ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-099",
    "category": "Malloc",
    "question": "Pourquoi vérifier argc avant malloc ?",
    "answer": "Checklist opérationnelle: 1) éviter allocation inutile. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite check arguments dans le thème « Malloc ». Point central: éviter allocation inutile. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Pourquoi vérifier argc avant malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-100",
    "category": "Malloc",
    "question": "Réflexe numéro un avec malloc ?",
    "answer": "Checklist opérationnelle: 1) vérifier NULL. Objectif: allouer juste et gérer les échecs proprement.",
    "explanation": "Cette carte traite règle absolue dans le thème « Malloc ». Point central: vérifier NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: l'allocation est sous-dimensionnée ou non vérifiée. Repère rapide: relis la question (« Réflexe numéro un avec malloc ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-101",
    "category": "Listes chaînées",
    "question": "À quoi sert le champ next ?",
    "answer": "Checklist opérationnelle: 1) pointer vers le maillon suivant. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite rôle next dans le thème « Listes chaînées ». Point central: pointer vers le maillon suivant. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« À quoi sert le champ next ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-102",
    "category": "Listes chaînées",
    "question": "Que représente begin_list ?",
    "answer": "Checklist opérationnelle: 1) pointeur vers la tête. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite tête dans le thème « Listes chaînées ». Point central: pointeur vers la tête. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Que représente begin_list ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-103",
    "category": "Listes chaînées",
    "question": "Pourquoi passer t_list ?",
    "answer": "Checklist opérationnelle: 1) modifier la tête | 2) relier après suppression. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite double pointeur dans le thème « Listes chaînées ». Séquence minimale: modifier la tête, puis relier après suppression. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Pourquoi passer t_list ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-104",
    "category": "Listes chaînées",
    "question": "Comment parcourir une liste ?",
    "answer": "Checklist opérationnelle: 1) cur = begin | 2) while(cur) | 3) cur = cur->next. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite parcourir dans le thème « Listes chaînées ». En pratique: commence par cur = begin, enchaîne avec while(cur), puis termine par cur = cur->next. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment parcourir une liste ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-105",
    "category": "Listes chaînées",
    "question": "Comment retirer cur->next ?",
    "answer": "Checklist opérationnelle: 1) tmp = cur->next | 2) cur->next = tmp->next | 3) free(tmp). Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite supprimer suivant dans le thème « Listes chaînées ». En pratique: commence par tmp = cur->next, enchaîne avec cur->next = tmp->next, puis termine par free(tmp). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment retirer cur->next ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-106",
    "category": "Listes chaînées",
    "question": "Comment supprimer plusieurs têtes ?",
    "answer": "Checklist opérationnelle: 1) while(*begin && cmp(...)) | 2) tmp = *begin | 3) *begin = tmp->next | 4) free(tmp). Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite nettoyer tête dans le thème « Listes chaînées ». En pratique: commence par while(*begin && cmp(...)), enchaîne avec tmp = *begin, puis termine par free(tmp). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment supprimer plusieurs têtes ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-107",
    "category": "Listes chaînées",
    "question": "Quand avancer cur ? (avancer, Listes chaînées)",
    "answer": "Checklist opérationnelle: 1) seulement si pas supprimé. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite avancer dans le thème « Listes chaînées ». Point central: seulement si pas supprimé. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Quand avancer cur ? (avancer, Listes chaînées) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-108",
    "category": "Listes chaînées",
    "question": "Comment détecter la fin ?",
    "answer": "Checklist opérationnelle: 1) cur == NULL. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite fin liste dans le thème « Listes chaînées ». Point central: cur == NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment détecter la fin ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-109",
    "category": "Listes chaînées",
    "question": "Que vaut une liste vide ?",
    "answer": "Checklist opérationnelle: 1) pointeur NULL. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite liste vide dans le thème « Listes chaînées ». Point central: pointeur NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Que vaut une liste vide ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-110",
    "category": "Listes chaînées",
    "question": "Pourquoi tmp est indispensable ?",
    "answer": "Checklist opérationnelle: 1) garder adresse | 2) free après. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite tmp dans le thème « Listes chaînées ». Séquence minimale: garder adresse, puis free après. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Pourquoi tmp est indispensable ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-111",
    "category": "Listes chaînées",
    "question": "Quel tri simple utiliser à l’exam ?",
    "answer": "Checklist opérationnelle: 1) bubble sort | 2) swap data. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite sort_list dans le thème « Listes chaînées ». Séquence minimale: bubble sort, puis swap data. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Quel tri simple utiliser à l’exam ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-112",
    "category": "Listes chaînées",
    "question": "À quoi sert swapped ? (swapped, Listes chaînées)",
    "answer": "Checklist opérationnelle: 1) savoir si encore des échanges. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite swapped dans le thème « Listes chaînées ». Point central: savoir si encore des échanges. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« À quoi sert swapped ? (swapped, Listes chaînées) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-113",
    "category": "Listes chaînées",
    "question": "Que fait cmp dans sort_list ?",
    "answer": "Checklist opérationnelle: 1) indique ordre correct. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite cmp dans le thème « Listes chaînées ». Point central: indique ordre correct. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Que fait cmp dans sort_list ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-114",
    "category": "Listes chaînées",
    "question": "Comment compter les maillons ?",
    "answer": "Checklist opérationnelle: 1) while(lst) count++. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite lstsize dans le thème « Listes chaînées ». Point central: while(lst) count++. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment compter les maillons ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-115",
    "category": "Listes chaînées",
    "question": "Que vaut next du dernier ?",
    "answer": "Checklist opérationnelle: 1) NULL. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite dernier dans le thème « Listes chaînées ». Point central: NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Que vaut next du dernier ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-116",
    "category": "Listes chaînées",
    "question": "Pourquoi unlink avant free ?",
    "answer": "Checklist opérationnelle: 1) éviter corruption. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite unlink avant free dans le thème « Listes chaînées ». Point central: éviter corruption. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Pourquoi unlink avant free ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-117",
    "category": "Listes chaînées",
    "question": "Quel test avant cur->next ?",
    "answer": "Checklist opérationnelle: 1) if(cur->next). Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite accès sécurisé dans le thème « Listes chaînées ». Point central: if(cur->next). Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Quel test avant cur->next ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-118",
    "category": "Listes chaînées",
    "question": "Comment supprimer le dernier ?",
    "answer": "Checklist opérationnelle: 1) parcourir jusqu’à avant dernier | 2) unlink | 3) free. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite supprimer dernier dans le thème « Listes chaînées ». En pratique: commence par parcourir jusqu’à avant dernier, enchaîne avec unlink, puis termine par free. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Comment supprimer le dernier ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-119",
    "category": "Listes chaînées",
    "question": "Pourquoi éviter récursion à l’exam ?",
    "answer": "Checklist opérationnelle: 1) stack | 2) complexité. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite récursion dans le thème « Listes chaînées ». Séquence minimale: stack, puis complexité. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Pourquoi éviter récursion à l’exam ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-120",
    "category": "Listes chaînées",
    "question": "Piège majeur avec les listes ?",
    "answer": "Checklist opérationnelle: 1) avancer au mauvais moment | 2) perdre un lien. Objectif: préserver les liens sans perdre de maillons.",
    "explanation": "Cette carte traite danger principal dans le thème « Listes chaînées ». Séquence minimale: avancer au mauvais moment, puis perdre un lien. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: un lien est perdu pendant la suppression. Repère rapide: relis la question (« Piège majeur avec les listes ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-121",
    "category": "Conditions limites",
    "question": "Quel est le cas limite majeur de itoa ?",
    "answer": "Checklist opérationnelle: 1) INT_MIN | 2) overflow si non géré | 3) caster en long. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite itoa INT_MIN dans le thème « Conditions limites ». En pratique: commence par INT_MIN, enchaîne avec overflow si non géré, puis termine par caster en long. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« Quel est le cas limite majeur de itoa ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-122",
    "category": "Conditions limites",
    "question": "split(\"\") doit retourner quoi ?",
    "answer": "Checklist opérationnelle: 1) tableau contenant seulement NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite split vide dans le thème « Conditions limites ». Point central: tableau contenant seulement NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« split(\"\") doit retourner quoi ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-123",
    "category": "Conditions limites",
    "question": "ft_range(5,5) ? (ft_range égalité, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) tableau {5}. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite ft_range égalité dans le thème « Conditions limites ». Point central: tableau {5}. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« ft_range(5,5) ? (ft_range égalité, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-124",
    "category": "Conditions limites",
    "question": "Que vaut begin_list si la liste est vide ?",
    "answer": "Checklist opérationnelle: 1) NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite liste vide dans le thème « Conditions limites ». Point central: NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« Que vaut begin_list si la liste est vide ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-125",
    "category": "Conditions limites",
    "question": "remove_if supprime tous les éléments. Résultat ?",
    "answer": "Checklist opérationnelle: 1) *begin devient NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite supprimer tout dans le thème « Conditions limites ». Point central: *begin devient NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« remove_if supprime tous les éléments. Résultat ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-126",
    "category": "Conditions limites",
    "question": "atoi(\"0\") ? (atoi zéro, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) 0. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite atoi zéro dans le thème « Conditions limites ». Point central: 0. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« atoi(\"0\") ? (atoi zéro, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-127",
    "category": "Conditions limites",
    "question": "split(\" \") doit produire ?",
    "answer": "Checklist opérationnelle: 1) tableau NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite only spaces dans le thème « Conditions limites ». Point central: tableau NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« split(\" \") doit produire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-128",
    "category": "Conditions limites",
    "question": "sort_list avec un seul maillon ?",
    "answer": "Checklist opérationnelle: 1) inchangé. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite un seul élément dans le thème « Conditions limites ». Point central: inchangé. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« sort_list avec un seul maillon ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-129",
    "category": "Conditions limites",
    "question": "wdmatch ne trouve pas tous les caractères ?",
    "answer": "Checklist opérationnelle: 1) afficher '\\n'. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite wdmatch raté dans le thème « Conditions limites ». Point central: afficher '\\n'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« wdmatch ne trouve pas tous les caractères ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-130",
    "category": "Conditions limites",
    "question": "ft_range(3,0) ? (start > end, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) {3,2,1,0}. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite start > end dans le thème « Conditions limites ». Point central: {3,2,1,0}. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« ft_range(3,0) ? (start > end, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-131",
    "category": "Conditions limites",
    "question": "itoa(0) retourne ? (itoa(0), Conditions limites)",
    "answer": "Checklist opérationnelle: 1) \"0\". Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite itoa(0) dans le thème « Conditions limites ». Point central: \"0\". Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« itoa(0) retourne ? (itoa(0), Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-132",
    "category": "Conditions limites",
    "question": "ft_list_foreach sur liste vide ?",
    "answer": "Checklist opérationnelle: 1) rien. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite foreach vide dans le thème « Conditions limites ». Point central: rien. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« ft_list_foreach sur liste vide ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-133",
    "category": "Conditions limites",
    "question": "remove_if ne trouve rien ?",
    "answer": "Checklist opérationnelle: 1) liste inchangée. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite aucun match dans le thème « Conditions limites ». Point central: liste inchangée. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« remove_if ne trouve rien ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-134",
    "category": "Conditions limites",
    "question": "Comment doit se terminer un tableau de strings ?",
    "answer": "Checklist opérationnelle: 1) NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite tableau final dans le thème « Conditions limites ». Point central: NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« Comment doit se terminer un tableau de strings ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-135",
    "category": "Conditions limites",
    "question": "atoi(\" 42\") ? (atoi espaces, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) 42. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite atoi espaces dans le thème « Conditions limites ». Point central: 42. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« atoi(\" 42\") ? (atoi espaces, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-136",
    "category": "Conditions limites",
    "question": "union(\"\", \"\") ? (union vide, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) rien afficher. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite union vide dans le thème « Conditions limites ». Point central: rien afficher. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« union(\"\", \"\") ? (union vide, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-137",
    "category": "Conditions limites",
    "question": "Dernier mot sans séparateur ?",
    "answer": "Checklist opérationnelle: 1) inclure quand même. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite dernier mot dans le thème « Conditions limites ». Point central: inclure quand même. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« Dernier mot sans séparateur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-138",
    "category": "Conditions limites",
    "question": "remove_if supprime dernier maillon ?",
    "answer": "Checklist opérationnelle: 1) unlink | 2) free. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite supprimer dernier dans le thème « Conditions limites ». Séquence minimale: unlink, puis free. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« remove_if supprime dernier maillon ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-139",
    "category": "Conditions limites",
    "question": "argc incorrect ? (argc faux, Conditions limites)",
    "answer": "Checklist opérationnelle: 1) afficher '\\n'. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite argc faux dans le thème « Conditions limites ». Point central: afficher '\\n'. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« argc incorrect ? (argc faux, Conditions limites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-140",
    "category": "Conditions limites",
    "question": "malloc échoue dans split ?",
    "answer": "Checklist opérationnelle: 1) free déjà alloué | 2) return NULL. Objectif: passer les cas extrêmes sans comportement incohérent.",
    "explanation": "Cette carte traite malloc échoue dans le thème « Conditions limites ». Séquence minimale: free déjà alloué, puis return NULL. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: le cas vide ou extrême n'est pas couvert. Repère rapide: relis la question (« malloc échoue dans split ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-141",
    "category": "Règles implicites",
    "question": "argc n’est pas celui attendu. Que faire ?",
    "answer": "Checklist opérationnelle: 1) afficher uniquement `\\n` | 2) rien d’autre. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite argc incorrect dans le thème « Règles implicites ». Séquence minimale: afficher uniquement `\\n`, puis rien d’autre. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« argc n’est pas celui attendu. Que faire ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-142",
    "category": "Règles implicites",
    "question": "Une fonction n’est pas listée dans “Allowed functions” ?",
    "answer": "Checklist opérationnelle: 1) interdite | 2) ne pas l’utiliser. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite fonctions autorisées dans le thème « Règles implicites ». Séquence minimale: interdite, puis ne pas l’utiliser. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Une fonction n’est pas listée dans “Allowed functions” ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-143",
    "category": "Règles implicites",
    "question": "write est la seule fonction autorisée ?",
    "answer": "Checklist opérationnelle: 1) pas printf | 2) pas puts | 3) pas perror. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite write imposé dans le thème « Règles implicites ». En pratique: commence par pas printf, enchaîne avec pas puts, puis termine par pas perror. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« write est la seule fonction autorisée ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-144",
    "category": "Règles implicites",
    "question": "Pourquoi l’output doit être strict ?",
    "answer": "Checklist opérationnelle: 1) tests automatiques | 2) comparaison exacte. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite sortie exacte dans le thème « Règles implicites ». Séquence minimale: tests automatiques, puis comparaison exacte. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Pourquoi l’output doit être strict ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-145",
    "category": "Règles implicites",
    "question": "L’énoncé montre un `\\n` final ?",
    "answer": "Checklist opérationnelle: 1) obligatoire | 2) sinon tests KO. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite newline final dans le thème « Règles implicites ». Séquence minimale: obligatoire, puis sinon tests KO. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« L’énoncé montre un `\\n` final ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-146",
    "category": "Règles implicites",
    "question": "“Expected files : wdmatch.c” ?",
    "answer": "Checklist opérationnelle: 1) un seul fichier | 2) nom exact. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite nom de fichier dans le thème « Règles implicites ». Séquence minimale: un seul fichier, puis nom exact. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« “Expected files : wdmatch.c” ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-147",
    "category": "Règles implicites",
    "question": "Le prototype doit correspondre exactement ?",
    "answer": "Checklist opérationnelle: 1) oui | 2) sinon compilation refusée. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite prototype dans le thème « Règles implicites ». Séquence minimale: oui, puis sinon compilation refusée. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Le prototype doit correspondre exactement ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-148",
    "category": "Règles implicites",
    "question": "“include list.h but do not turn it in” ?",
    "answer": "Checklist opérationnelle: 1) utiliser le header | 2) ne pas rendre le fichier. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite include fourni dans le thème « Règles implicites ». Séquence minimale: utiliser le header, puis ne pas rendre le fichier. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« “include list.h but do not turn it in” ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-149",
    "category": "Règles implicites",
    "question": "Une struct est fournie dans l’énoncé ?",
    "answer": "Checklist opérationnelle: 1) ne pas modifier | 2) utiliser telle quelle. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite structure imposée dans le thème « Règles implicites ». Séquence minimale: ne pas modifier, puis utiliser telle quelle. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Une struct est fournie dans l’énoncé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-150",
    "category": "Règles implicites",
    "question": "Peut-on laisser des printf de debug ?",
    "answer": "Checklist opérationnelle: 1) non | 2) sortie strictement contrôlée. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite pas de debug dans le thème « Règles implicites ». Séquence minimale: non, puis sortie strictement contrôlée. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Peut-on laisser des printf de debug ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-151",
    "category": "Règles implicites",
    "question": "L’énoncé ne demande pas d’erreur explicite ?",
    "answer": "Checklist opérationnelle: 1) rester silencieux | 2) ou seulement `\\n`. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite affichage erreur dans le thème « Règles implicites ». Séquence minimale: rester silencieux, puis ou seulement `\\n`. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« L’énoncé ne demande pas d’erreur explicite ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-152",
    "category": "Règles implicites",
    "question": "Une fonction doit retourner un pointeur ?",
    "answer": "Checklist opérationnelle: 1) retourner une adresse valide | 2) pas une variable locale. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite return malloc dans le thème « Règles implicites ». Séquence minimale: retourner une adresse valide, puis pas une variable locale. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Une fonction doit retourner un pointeur ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-153",
    "category": "Règles implicites",
    "question": "calloc est autorisé ? (Allowed functions: malloc, Règles implicites)",
    "answer": "Checklist opérationnelle: 1) non | 2) pas listé. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite Allowed functions: malloc dans le thème « Règles implicites ». Séquence minimale: non, puis pas listé. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« calloc est autorisé ? (Allowed functions: malloc, Règles implicites) ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-154",
    "category": "Règles implicites",
    "question": "Les exemples fournis servent à quoi ?",
    "answer": "Checklist opérationnelle: 1) contrat exact | 2) format à respecter. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite exemples dans le thème « Règles implicites ». Séquence minimale: contrat exact, puis format à respecter. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Les exemples fournis servent à quoi ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-155",
    "category": "Règles implicites",
    "question": "Afficher sur stderr au lieu de stdout ?",
    "answer": "Checklist opérationnelle: 1) tests ratés. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite stderr dans le thème « Règles implicites ». Point central: tests ratés. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Afficher sur stderr au lieu de stdout ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "hard",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-156",
    "category": "Règles implicites",
    "question": "Tu affiches plus que demandé ?",
    "answer": "Checklist opérationnelle: 1) tests KO. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite afficher trop dans le thème « Règles implicites ». Point central: tests KO. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Tu affiches plus que demandé ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-157",
    "category": "Règles implicites",
    "question": "Un cas n’est pas décrit ?",
    "answer": "Checklist opérationnelle: 1) rester minimal | 2) ne rien inventer. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite comportement non précisé dans le thème « Règles implicites ». Séquence minimale: rester minimal, puis ne rien inventer. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Un cas n’est pas décrit ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-158",
    "category": "Règles implicites",
    "question": "Pourquoi respecter les noms exacts ?",
    "answer": "Checklist opérationnelle: 1) linker | 2) compilation. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite noms fonctions dans le thème « Règles implicites ». Séquence minimale: linker, puis compilation. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Pourquoi respecter les noms exacts ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-159",
    "category": "Règles implicites",
    "question": "Changer l’ordre d’affichage ?",
    "answer": "Checklist opérationnelle: 1) interdit | 2) tests KO. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite ordre affichage dans le thème « Règles implicites ». Séquence minimale: interdit, puis tests KO. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Changer l’ordre d’affichage ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  },
  {
    "id": "fc-160",
    "category": "Règles implicites",
    "question": "Règle implicite numéro un ?",
    "answer": "Checklist opérationnelle: 1) relire l’énoncé | 2) respecter chaque mot. Objectif: respecter strictement le contrat du sujet.",
    "explanation": "Cette carte traite règle absolue dans le thème « Règles implicites ». Séquence minimale: relire l’énoncé, puis respecter chaque mot. Pourquoi c'est utile: l'ordre proposé te donne une exécution reproductible, même sous contrainte de temps. Point de vigilance: la sortie n'est pas exactement celle attendue. Repère rapide: relis la question (« Règle implicite numéro un ? ») et vérifie que chaque étape est couverte dans ton code.",
    "difficulty": "medium",
    "successCount": 0,
    "failCount": 0,
    "lastSeen": 0,
    "nextDue": 0
  }
]
